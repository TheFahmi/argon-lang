// ============================================
// CRYO STANDARD LIBRARY: SET (v2.19.0)
// Set operations (union, intersection, etc)
// ============================================

// Set is represented as array with unique elements

// Create empty set
fn setNew() {
    let s = [];
    return s;
}

// Create set from array (removes duplicates)
fn setFrom(arr) {
    let result = [];
    let i = 0;
    while (i < len(arr)) {
        if (setHas(result, arr[i]) == false) {
            result = push(result, arr[i]);
        }
        i = i + 1;
    }
    return result;
}

// Get set size
fn setSize(s) {
    return len(s);
}

// Check if set is empty
fn setIsEmpty(s) {
    return len(s) == 0;
}

// Check if element exists in set
fn setHas(s, elem) {
    let i = 0;
    while (i < len(s)) {
        if (s[i] == elem) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Add element to set (returns new set)
fn setAdd(s, elem) {
    if (setHas(s, elem)) {
        return s;
    }
    return push(s, elem);
}

// Remove element from set (returns new set)
fn setRemove(s, elem) {
    let result = [];
    let i = 0;
    while (i < len(s)) {
        if (s[i] != elem) {
            result = push(result, s[i]);
        }
        i = i + 1;
    }
    return result;
}

// Union of two sets (A + B)
fn setUnion(s1, s2) {
    let result = s1;
    let i = 0;
    while (i < len(s2)) {
        if (setHas(result, s2[i]) == false) {
            result = push(result, s2[i]);
        }
        i = i + 1;
    }
    return result;
}

// Intersection of two sets (A & B)
fn setIntersection(s1, s2) {
    let result = [];
    let i = 0;
    while (i < len(s1)) {
        if (setHas(s2, s1[i])) {
            result = push(result, s1[i]);
        }
        i = i + 1;
    }
    return result;
}

// Difference of two sets (A - B)
fn setDifference(s1, s2) {
    let result = [];
    let i = 0;
    while (i < len(s1)) {
        if (setHas(s2, s1[i]) == false) {
            result = push(result, s1[i]);
        }
        i = i + 1;
    }
    return result;
}

// Symmetric difference (A xor B)
fn setSymmetricDifference(s1, s2) {
    let diff1 = setDifference(s1, s2);
    let diff2 = setDifference(s2, s1);
    return setUnion(diff1, diff2);
}

// Check if s1 is subset of s2
fn setIsSubset(s1, s2) {
    let i = 0;
    while (i < len(s1)) {
        if (setHas(s2, s1[i]) == false) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Check if s1 is proper subset of s2
fn setIsProperSubset(s1, s2) {
    if (len(s1) >= len(s2)) {
        return false;
    }
    return setIsSubset(s1, s2);
}

// Check if s1 is superset of s2
fn setIsSuperset(s1, s2) {
    return setIsSubset(s2, s1);
}

// Check if two sets are equal
fn setEquals(s1, s2) {
    if (len(s1) != len(s2)) {
        return false;
    }
    return setIsSubset(s1, s2);
}

// Check if two sets are disjoint
fn setIsDisjoint(s1, s2) {
    let i = 0;
    while (i < len(s1)) {
        if (setHas(s2, s1[i])) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Clear set
fn setClear() {
    let s = [];
    return s;
}

// Convert set to array
fn setToArray(s) {
    return s;
}

// Get first element (or null if empty)
fn setFirst(s) {
    if (len(s) == 0) {
        return null;
    }
    return s[0];
}

// Convert set to string
fn setToString(s) {
    let result = "{";
    let i = 0;
    while (i < len(s)) {
        if (i > 0) {
            result = result + ", ";
        }
        result = result + s[i];
        i = i + 1;
    }
    return result + "}";
}
