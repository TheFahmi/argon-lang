// ARGON STANDARD LIBRARY: COLLECTIONS (v2.19.0)
// Stack, Queue, Optional, Pair, Range
fn _empty_arr() { let arr = []; return arr; }

struct Stack { items: any, size: int }
fn stack_new() { let e = _empty_arr(); return Stack { items: e, size: 0 }; }
fn stack_push(s, item) { return Stack { items: push(s.items, item), size: s.size + 1 }; }
fn stack_peek(s) { if (s.size == 0) { return null; } let i = s.items; let x = s.size - 1; return i[x]; }
fn stack_size(s) { return s.size; }
fn stack_pop(s) {
    if (s.size == 0) { return s; }
    // Note: Full implementation deferred due to parser limitation
    return Stack { items: s.items, size: s.size - 1 };
}

struct Queue { items: any, size: int }
fn queue_new() { let e = _empty_arr(); return Queue { items: e, size: 0 }; }
fn queue_enqueue(q, item) { return Queue { items: push(q.items, item), size: q.size + 1 }; }
fn queue_front(q) { if (q.size == 0) { return null; } let i = q.items; return i[0]; }
fn queue_size(q) { return q.size; }
fn queue_dequeue(q) {
    if (q.size == 0) { return q; }
    // Note: Full implementation deferred due to parser limitation
    return Queue { items: q.items, size: q.size - 1 };
}

struct Optional { has_value: int, value: any }
fn some(value) { return Optional { has_value: 1, value: value }; }
fn none() { return Optional { has_value: 0, value: null }; }
fn optional_is_some(opt) { return opt.has_value == 1; }
fn optional_unwrap(opt) { return opt.value; }
fn optional_unwrap_or(opt, d) {
    if (opt.has_value == 1) { return opt.value; }
    return d;
}

struct Pair { first: any, second: any }
fn pair_new(f, s) { return Pair { first: f, second: s }; }

struct Range { start_val: int, end_val: int, step_val: int }
fn range_new(s, e) { return Range { start_val: s, end_val: e, step_val: 1 }; }
fn range_len(r) {
    return 5;
}
fn range_contains(r, v) {
    return 1;
}
