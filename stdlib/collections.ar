// ============================================
// ARGON STANDARD LIBRARY: COLLECTIONS (v2.11.0)
// Generic-like collections using dynamic typing
// ============================================

// Helper to create empty array
fn _empty_arr() {
    let arr = [];
    return arr;
}

// ============================================
// STACK (LIFO)
// ============================================

struct Stack {
    items: any,
    size: int
}

fn stack_new() {
    let empty = _empty_arr();
    return Stack {
        items: empty,
        size: 0
    };
}

fn stack_push(s, item) {
    return Stack {
        items: push(s.items, item),
        size: s.size + 1
    };
}

fn stack_pop(s) {
    if (s.size == 0) {
        return s;
    }
    let new_items = _empty_arr();
    let i = 0;
    while (i < s.size - 1) {
        new_items = push(new_items, s.items[i]);
        i = i + 1;
    }
    return Stack {
        items: new_items,
        size: s.size - 1
    };
}

fn stack_peek(s) {
    if (s.size == 0) {
        return null;
    }
    return s.items[s.size - 1];
}

fn stack_is_empty(s) {
    return s.size == 0;
}

fn stack_size(s) {
    return s.size;
}

// ============================================
// QUEUE (FIFO)
// ============================================

struct Queue {
    items: any,
    size: int
}

fn queue_new() {
    let empty = _empty_arr();
    return Queue {
        items: empty,
        size: 0
    };
}

fn queue_enqueue(q, item) {
    return Queue {
        items: push(q.items, item),
        size: q.size + 1
    };
}

fn queue_dequeue(q) {
    if (q.size == 0) {
        return q;
    }
    let new_items = _empty_arr();
    let i = 1;
    while (i < q.size) {
        new_items = push(new_items, q.items[i]);
        i = i + 1;
    }
    return Queue {
        items: new_items,
        size: q.size - 1
    };
}

fn queue_front(q) {
    if (q.size == 0) {
        return null;
    }
    return q.items[0];
}

fn queue_is_empty(q) {
    return q.size == 0;
}

fn queue_size(q) {
    return q.size;
}

// ============================================
// OPTIONAL (Maybe type)
// ============================================

struct Optional {
    has_value: bool,
    value: any
}

fn some(value) {
    return Optional {
        has_value: true,
        value: value
    };
}

fn none() {
    return Optional {
        has_value: false,
        value: null
    };
}

fn optional_is_some(opt) {
    return opt.has_value;
}

fn optional_is_none(opt) {
    if (opt.has_value) {
        return false;
    }
    return true;
}

fn optional_unwrap(opt) {
    return opt.value;
}

fn optional_unwrap_or(opt, default_val) {
    if (opt.has_value) {
        return opt.value;
    }
    return default_val;
}

// ============================================
// TUPLE (Pair, Triple)
// ============================================

struct Pair {
    first: any,
    second: any
}

fn pair_new(first, second) {
    return Pair {
        first: first,
        second: second
    };
}

struct Triple {
    first: any,
    second: any,
    third: any
}

fn triple_new(first, second, third) {
    return Triple {
        first: first,
        second: second,
        third: third
    };
}

// ============================================
// RANGE
// ============================================

struct Range {
    start_val: int,
    end_val: int,
    step_val: int
}

fn range_new(start, end_v) {
    return Range {
        start_val: start,
        end_val: end_v,
        step_val: 1
    };
}

fn range_with_step(start, end_v, step) {
    return Range {
        start_val: start,
        end_val: end_v,
        step_val: step
    };
}

fn range_contains(r, value) {
    if (value < r.start_val) {
        return false;
    }
    if (value >= r.end_val) {
        return false;
    }
    return true;
}

fn range_len(r) {
    let diff = r.end_val - r.start_val;
    return diff / r.step_val;
}

fn range_to_array(r) {
    let result = _empty_arr();
    let i = r.start_val;
    while (i < r.end_val) {
        result = push(result, i);
        i = i + r.step_val;
    }
    return result;
}
