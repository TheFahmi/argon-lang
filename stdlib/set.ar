// ============================================
// ARGON STANDARD LIBRARY: SET (v2.18.0)
// Set operations (union, intersection, etc)
// ============================================

// Set is represented as array with unique elements

// Create empty set
fn set_new() {
    let s = [];
    return s;
}

// Create set from array (removes duplicates)
fn set_from(arr) {
    let result = [];
    let i = 0;
    while (i < len(arr)) {
        if (set_has(result, arr[i]) == false) {
            result = push(result, arr[i]);
        }
        i = i + 1;
    }
    return result;
}

// Get set size
fn set_size(s) {
    return len(s);
}

// Check if set is empty
fn set_is_empty(s) {
    return len(s) == 0;
}

// Check if element exists in set
fn set_has(s, elem) {
    let i = 0;
    while (i < len(s)) {
        if (s[i] == elem) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Add element to set (returns new set)
fn set_add(s, elem) {
    if (set_has(s, elem)) {
        return s;
    }
    return push(s, elem);
}

// Remove element from set (returns new set)
fn set_remove(s, elem) {
    let result = [];
    let i = 0;
    while (i < len(s)) {
        if (s[i] != elem) {
            result = push(result, s[i]);
        }
        i = i + 1;
    }
    return result;
}

// Union of two sets (A + B)
fn set_union(s1, s2) {
    let result = s1;
    let i = 0;
    while (i < len(s2)) {
        if (set_has(result, s2[i]) == false) {
            result = push(result, s2[i]);
        }
        i = i + 1;
    }
    return result;
}

// Intersection of two sets (A & B)
fn set_intersection(s1, s2) {
    let result = [];
    let i = 0;
    while (i < len(s1)) {
        if (set_has(s2, s1[i])) {
            result = push(result, s1[i]);
        }
        i = i + 1;
    }
    return result;
}

// Difference of two sets (A - B)
fn set_difference(s1, s2) {
    let result = [];
    let i = 0;
    while (i < len(s1)) {
        if (set_has(s2, s1[i]) == false) {
            result = push(result, s1[i]);
        }
        i = i + 1;
    }
    return result;
}

// Symmetric difference (A xor B)
fn set_symmetric_difference(s1, s2) {
    let diff1 = set_difference(s1, s2);
    let diff2 = set_difference(s2, s1);
    return set_union(diff1, diff2);
}

// Check if s1 is subset of s2
fn set_is_subset(s1, s2) {
    let i = 0;
    while (i < len(s1)) {
        if (set_has(s2, s1[i]) == false) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Check if s1 is proper subset of s2
fn set_is_proper_subset(s1, s2) {
    if (len(s1) >= len(s2)) {
        return false;
    }
    return set_is_subset(s1, s2);
}

// Check if s1 is superset of s2
fn set_is_superset(s1, s2) {
    return set_is_subset(s2, s1);
}

// Check if two sets are equal
fn set_equals(s1, s2) {
    if (len(s1) != len(s2)) {
        return false;
    }
    return set_is_subset(s1, s2);
}

// Check if two sets are disjoint
fn set_is_disjoint(s1, s2) {
    let i = 0;
    while (i < len(s1)) {
        if (set_has(s2, s1[i])) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Clear set
fn set_clear() {
    let s = [];
    return s;
}

// Convert set to array
fn set_to_array(s) {
    return s;
}

// Get first element (or null if empty)
fn set_first(s) {
    if (len(s) == 0) {
        return null;
    }
    return s[0];
}

// Convert set to string
fn set_to_string(s) {
    let result = "{";
    let i = 0;
    while (i < len(s)) {
        if (i > 0) {
            result = result + ", ";
        }
        result = result + s[i];
        i = i + 1;
    }
    return result + "}";
}
