// ============================================
// CRYO WASM STANDARD LIBRARY
// WebAssembly utilities and interop
// Part of Cryo Stdlib v2.19.0
// ============================================

// =================== WASM MEMORY ===================

// Allocate memory in WASM linear memory
fn wasmAlloc(size: i32) {
    return @wasmCall("cryo_alloc", size);
}

// Free allocated memory (no-op for bump allocator)
fn wasmFree(ptr: i32) {
    // No-op for simple bump allocator
}

// =================== WASM MEMORY ACCESS ===================

// Store 32-bit integer at offset
fn wasmStoreI32(base: i32, offset: i32, value: i32) {
    @wasmStoreI32(base + offset, value);
}

// Load 32-bit integer from offset
fn wasmLoadI32(base: i32, offset: i32) {
    return @wasmLoadI32(base + offset);
}

// Store 64-bit integer at offset
fn wasmStoreI64(base: i32, offset: i32, value: i64) {
    @wasmStoreI64(base + offset, value);
}

// Load 64-bit integer from offset
fn wasmLoadI64(base: i32, offset: i32) {
    return @wasmLoadI64(base + offset);
}

// Store byte at offset
fn wasmStoreByte(base: i32, offset: i32, value: i32) {
    @wasmStore8(base + offset, value);
}

// Load byte from offset
fn wasmLoadByte(base: i32, offset: i32) {
    return @wasmLoad8U(base + offset);
}

// =================== WASM STRING UTILITIES ===================

// Get string length (null-terminated)
fn wasmStrlen(ptr: i32) {
    let len = 0;
    while (wasmLoadByte(ptr, len) != 0) {
        len = len + 1;
    }
    return len;
}

// Copy string to new location
fn wasmStrcpy(dest: i32, src: i32) {
    let i = 0;
    let c = wasmLoadByte(src, i);
    while (c != 0) {
        wasmStoreByte(dest, i, c);
        i = i + 1;
        c = wasmLoadByte(src, i);
    }
    wasmStoreByte(dest, i, 0);  // Null terminator
    return dest;
}

// Concatenate strings
fn wasmStrcat(dest: i32, src: i32) {
    let dest_len = wasmStrlen(dest);
    let i = 0;
    let c = wasmLoadByte(src, i);
    while (c != 0) {
        wasmStoreByte(dest, dest_len + i, c);
        i = i + 1;
        c = wasmLoadByte(src, i);
    }
    wasmStoreByte(dest, dest_len + i, 0);
    return dest;
}

// =================== WASM ARRAY UTILITIES ===================

// Create array in WASM memory
// Format: [length: i32, capacity: i32, ...elements: i64]
fn wasmArrayNew(capacity: i32) {
    // Allocate: 8 bytes header + capacity * 8 bytes
    let size = 8 + capacity * 8;
    let ptr = wasmAlloc(size);
    wasmStoreI32(ptr, 0, 0);         // length = 0
    wasmStoreI32(ptr, 4, capacity);  // capacity
    return ptr;
}

// Get array length
fn wasmArrayLen(arr: i32) {
    return wasmLoadI32(arr, 0);
}

// Get array element
fn wasmArrayGet(arr: i32, index: i32) {
    // Skip 8 byte header, each element is 8 bytes
    return wasmLoadI64(arr, 8 + index * 8);
}

// Set array element
fn wasmArraySet(arr: i32, index: i32, value: i64) {
    wasmStoreI64(arr, 8 + index * 8, value);
}

// Push element to array
fn wasmArrayPush(arr: i32, value: i64) {
    let len = wasmArrayLen(arr);
    wasmStoreI32(arr, 0, len + 1);  // Increment length
    wasmStoreI64(arr, 8 + len * 8, value);
    return arr;
}

// =================== WASM I/O ===================

// Print string (WASI fd_write)
fn wasmPrint(ptr: i32, len: i32) {
    @wasmCall("print", ptr, len);
}

// Print string with newline
fn wasmPrintln(ptr: i32, len: i32) {
    @wasmCall("println", ptr, len);
}

// =================== WASM MATH ===================

fn wasmMin(a: i64, b: i64) {
    if (a < b) {
        return a;
    }
    return b;
}

fn wasmMax(a: i64, b: i64) {
    if (a > b) {
        return a;
    }
    return b;
}

fn wasmAbs(x: i64) {
    if (x < 0) {
        return 0 - x;
    }
    return x;
}

fn wasmClamp(x: i64, min: i64, max: i64) {
    if (x < min) {
        return min;
    }
    if (x > max) {
        return max;
    }
    return x;
}

// =================== WASM EXPORTS HELPER ===================

// This module provides utility functions that can be used
// in WASM-targeted Cryo programs. When compiling with
// --target wasm32, these functions will be available.
