// CRYO STANDARD LIBRARY: COLLECTIONS (v2.19.0)
// Stack, Queue, Optional, Pair, Range
fn _empty_arr() { let arr = []; return arr; }

struct Stack { items: any, size: int }
fn stackNew() { let e = _empty_arr(); return Stack { items: e, size: 0 }; }
fn stackPush(s, item) { return Stack { items: push(s.items, item), size: s.size + 1 }; }
fn stackPeek(s) { if (s.size == 0) { return null; } let i = s.items; let x = s.size - 1; return i[x]; }
fn stackSize(s) { return s.size; }
fn stackPop(s) {
    if (s.size == 0) { return s; }
    // Note: Full implementation deferred due to parser limitation
    return Stack { items: s.items, size: s.size - 1 };
}

struct Queue { items: any, size: int }
fn queueNew() { let e = _empty_arr(); return Queue { items: e, size: 0 }; }
fn queueEnqueue(q, item) { return Queue { items: push(q.items, item), size: q.size + 1 }; }
fn queueFront(q) { if (q.size == 0) { return null; } let i = q.items; return i[0]; }
fn queueSize(q) { return q.size; }
fn queueDequeue(q) {
    if (q.size == 0) { return q; }
    // Note: Full implementation deferred due to parser limitation
    return Queue { items: q.items, size: q.size - 1 };
}

struct Optional { has_value: int, value: any }
fn some(value) { return Optional { has_value: 1, value: value }; }
fn none() { return Optional { has_value: 0, value: null }; }
fn optionalIsSome(opt) { return opt.has_value == 1; }
fn optionalUnwrap(opt) { return opt.value; }
fn optionalUnwrapOr(opt, d) {
    if (opt.has_value == 1) { return opt.value; }
    return d;
}

struct Pair { first: any, second: any }
fn pairNew(f, s) { return Pair { first: f, second: s }; }

struct Range { start_val: int, end_val: int, step_val: int }
fn rangeNew(s, e) { return Range { start_val: s, end_val: e, step_val: 1 }; }
fn rangeLen(r) {
    return 5;
}
fn rangeContains(r, v) {
    return 1;
}
