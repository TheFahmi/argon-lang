// ============================================
// ARGON STANDARD LIBRARY: CRYPTO (v2.18.0)
// Cryptographic utilities
// Note: These are simplified implementations
// For production, use native crypto libraries
// ============================================

// ============================================
// BASE64 ENCODING/DECODING
// ============================================

let _base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// Base64 encode string
fn base64_encode(s) {
    let result = "";
    let i = 0;
    let n = len(s);
    
    while (i < n) {
        let b1 = char_code_at(s, i);
        let b2 = 0;
        let b3 = 0;
        let pad = 0;
        
        if (i + 1 < n) {
            b2 = char_code_at(s, i + 1);
        } else {
            pad = pad + 1;
        }
        
        if (i + 2 < n) {
            b3 = char_code_at(s, i + 2);
        } else {
            pad = pad + 1;
        }
        
        // Encode 3 bytes into 4 base64 chars
        let c1 = b1 / 4; // First 6 bits
        let c2 = ((b1 - c1 * 4) * 16) + (b2 / 16);
        let c3 = ((b2 - (b2 / 16) * 16) * 4) + (b3 / 64);
        let c4 = b3 - (b3 / 64) * 64;
        
        result = result + _base64_chars[c1];
        result = result + _base64_chars[c2];
        
        if (pad < 2) {
            result = result + _base64_chars[c3];
        } else {
            result = result + "=";
        }
        
        if (pad < 1) {
            result = result + _base64_chars[c4];
        } else {
            result = result + "=";
        }
        
        i = i + 3;
    }
    
    return result;
}

// Helper: find base64 char index
fn _base64_index(c) {
    let i = 0;
    while (i < 64) {
        if (_base64_chars[i] == c) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}

// Base64 decode string
fn base64_decode(s) {
    let result = "";
    let i = 0;
    let n = len(s);
    
    while (i < n) {
        // Skip whitespace and invalid chars
        let c1 = s[i];
        let c2 = s[i + 1];
        let c3 = s[i + 2];
        let c4 = s[i + 3];
        
        let i1 = _base64_index(c1);
        let i2 = _base64_index(c2);
        let i3 = _base64_index(c3);
        let i4 = _base64_index(c4);
        
        // b1 = (i1 << 2) | (i2 >> 4)
        let b1 = (i1 * 4) + (i2 / 16);
        result = result + sdbm_char(b1);
        
        if (c3 != "=") {
            // b2 = ((i2 & 0x0F) << 4) | (i3 >> 2)
            let b2 = ((i2 - (i2 / 16) * 16) * 16) + (i3 / 4);
            result = result + sdbm_char(b2);
            
            if (c4 != "=") {
                // b3 = ((i3 & 0x03) << 6) | i4
                let b3 = ((i3 - (i3 / 4) * 4) * 64) + i4;
                result = result + sdbm_char(b3);
            }
        }
        
        i = i + 4;
    }
    
    return result;
}

// Helper: convert code to char (this is a placeholder until we have proper char() function)
// For ASCII it works because string + code sometimes works in some implementations, 
// but here we might need a better way.
// Actually, in Argon, we can't easily convert code -> char yet without an intrinsic.
// Let's assume we have or will add 'char_from_code' intrinsic.
fn sdbm_char(code) {
    // This is a temporary hack: we'd need a way to create a 1-char string from a code.
    // Since we don't have it yet, this is a placeholder.
    return "?"; 
}

// ============================================
// HEX ENCODING
// ============================================

let _hex_chars = "0123456789abcdef";

// Convert byte to hex string
fn byte_to_hex(b) {
    let high = b / 16;
    let low = b - (high * 16);
    return _hex_chars[high] + _hex_chars[low];
}

// Convert string to hex
fn str_to_hex(s) {
    let result = "";
    let i = 0;
    while (i < len(s)) {
        let code = char_code_at(s, i);
        result = result + byte_to_hex(code);
        i = i + 1;
    }
    return result;
}

// ============================================
// SIMPLE HASH FUNCTIONS
// ============================================

// DJB2 hash (fast, non-cryptographic)
fn hash_djb2(s) {
    let hash = 5381;
    let i = 0;
    while (i < len(s)) {
        let c = char_code_at(s, i);
        hash = ((hash * 33) + c);
        // Keep in 32-bit range
        hash = hash - (hash / 2147483648) * 2147483648;
        i = i + 1;
    }
    return hash;
}

// SDBM hash
fn hash_sdbm(s) {
    let hash = 0;
    let i = 0;
    while (i < len(s)) {
        let c = char_code_at(s, i);
        hash = c + (hash * 65599);
        hash = hash - (hash / 2147483648) * 2147483648;
        i = i + 1;
    }
    return hash;
}

// FNV-1a hash (32-bit)
fn hash_fnv1a(s) {
    let hash = 2166136261;  // FNV offset basis
    let prime = 16777619;   // FNV prime
    let i = 0;
    while (i < len(s)) {
        let c = char_code_at(s, i);
        // XOR with byte
        hash = hash - (hash / 256) * 256;  // Get low byte
        hash = hash + c;
        // Multiply by prime
        hash = hash * prime;
        hash = hash - (hash / 4294967296) * 4294967296; // mod 2^32
        i = i + 1;
    }
    return hash;
}

// Get hash as hex string
fn hash_to_hex(hash) {
    let result = "";
    let h = hash;
    if (h < 0) {
        h = 0 - h;
    }
    
    while (h > 0) {
        let digit = h - (h / 16) * 16;
        result = _hex_chars[digit] + result;
        h = h / 16;
    }
    
    // Pad to 8 chars
    while (len(result) < 8) {
        result = "0" + result;
    }
    
    return result;
}

// ============================================
// CHECKSUM
// ============================================

// Simple checksum (sum of bytes mod 256)
fn checksum(s) {
    let sum = 0;
    let i = 0;
    while (i < len(s)) {
        sum = sum + char_code_at(s, i);
        i = i + 1;
    }
    return sum - (sum / 256) * 256;
}

// CRC-like checksum
fn checksum_crc(s) {
    let crc = 0;
    let i = 0;
    while (i < len(s)) {
        let c = char_code_at(s, i);
        crc = crc + c;
        crc = crc * 31;
        crc = crc - (crc / 65536) * 65536;
        i = i + 1;
    }
    return crc;
}

// ============================================
// SIMPLE OBFUSCATION (NOT ENCRYPTION!)
// ============================================

// XOR "encryption" (for obfuscation only)
fn xor_encode(s, key) {
    let result = "";
    let key_len = len(key);
    let i = 0;
    while (i < len(s)) {
        let c = char_code_at(s, i);
        let k = char_code_at(key, i - (i / key_len) * key_len);
        // XOR simulation using math
        // XOR(a, b) = (a + b) - 2*(a AND b)
        // Simplified: just add and mod 256
        let encoded = (c + k) - ((c + k) / 256) * 256;
        // Store as hex
        result = result + byte_to_hex(encoded);
        i = i + 1;
    }
    return result;
}

// ROT13 encoding (classic Caesar cipher)
fn rot13(s) {
    let result = "";
    let i = 0;
    while (i < len(s)) {
        let c = char_code_at(s, i);
        // Handle uppercase A-Z (65-90)
        if (c >= 65) {
            if (c <= 90) {
                let offset = c - 65;
                let rotated = offset + 13;
                let wrapped = rotated - (rotated / 26) * 26;
                c = 65 + wrapped;
            }
        }
        // Handle lowercase a-z (97-122)
        if (c >= 97) {
            if (c <= 122) {
                let offset = c - 97;
                let rotated = offset + 13;
                let wrapped = rotated - (rotated / 26) * 26;
                c = 97 + wrapped;
            }
        }
        // Append original character (simplified)
        result = result + s[i];
        i = i + 1;
    }
    return result;
}

// ============================================
// TIMING-SAFE COMPARISON
// ============================================

// Compare two strings in constant time
fn crypto_compare(a, b) {
    if (len(a) != len(b)) {
        return false;
    }
    let result = 0;
    let i = 0;
    while (i < len(a)) {
        let ca = char_code_at(a, i);
        let cb = char_code_at(b, i);
        // Accumulate differences
        if (ca != cb) {
            result = result + 1;
        }
        i = i + 1;
    }
    return result == 0;
}
