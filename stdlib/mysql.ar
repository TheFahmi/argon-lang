// ============================================
// ARGON STANDARD LIBRARY: MYSQL (v3.1.0)
// MySQL/MariaDB Database Driver
// ============================================

let MYSQL_VERSION = "3.1.0";

// ============================================
// Connection Configuration
// ============================================

struct MysqlConfig {
    host: string,
    port: int,
    database: string,
    user: string,
    password: string,
    charset: string,
    connectionTimeout: int,
    poolSize: int
}

fn mysqlConfig() -> MysqlConfig {
    return MysqlConfig {
        host: "localhost",
        port: 3306,
        database: "",
        user: "root",
        password: "",
        charset: "utf8mb4",
        connectionTimeout: 30,
        poolSize: 10
    };
}

fn mysqlConfigFromEnv() -> MysqlConfig {
    return MysqlConfig {
        host: env("MYSQL_HOST", "localhost"),
        port: parseInt(env("MYSQL_PORT", "3306")),
        database: env("MYSQL_DATABASE", ""),
        user: env("MYSQL_USER", "root"),
        password: env("MYSQL_PASSWORD", ""),
        charset: env("MYSQL_CHARSET", "utf8mb4"),
        connectionTimeout: 30,
        poolSize: 10
    };
}

fn mysqlConfigFromUrl(url: string) -> MysqlConfig {
    // Parse: mysql://user:pass@host:port/database
    let config = mysqlConfig();
    
    let rest = url;
    if (startsWith(url, "mysql://")) {
        rest = substr(url, 8, len(url) - 8);
    }
    
    let atIdx = indexOf(rest, "@");
    if (atIdx > 0) {
        let userPass = substr(rest, 0, atIdx);
        rest = substr(rest, atIdx + 1, len(rest) - atIdx - 1);
        
        let colonIdx = indexOf(userPass, ":");
        if (colonIdx > 0) {
            config.user = substr(userPass, 0, colonIdx);
            config.password = substr(userPass, colonIdx + 1, len(userPass) - colonIdx - 1);
        } else {
            config.user = userPass;
        }
    }
    
    let slashIdx = indexOf(rest, "/");
    if (slashIdx > 0) {
        config.database = substr(rest, slashIdx + 1, len(rest) - slashIdx - 1);
        rest = substr(rest, 0, slashIdx);
    }
    
    let colonIdx = indexOf(rest, ":");
    if (colonIdx > 0) {
        config.host = substr(rest, 0, colonIdx);
        config.port = parseInt(substr(rest, colonIdx + 1, len(rest) - colonIdx - 1));
    } else {
        config.host = rest;
    }
    
    return config;
}

// ============================================
// Connection
// ============================================

struct MysqlConnection {
    id: int,
    config: MysqlConfig,
    connected: bool,
    inTransaction: bool,
    lastError: string,
    lastInsertId: int
}

fn mysqlConnect(config: MysqlConfig) -> MysqlConnection {
    let conn = MysqlConnection {
        id: timestampMs() % 1000000,
        config: config,
        connected: false,
        inTransaction: false,
        lastError: "",
        lastInsertId: 0
    };
    
    print("[MySQL] Connecting to " + config.host + ":" + config.port + "/" + config.database);
    conn.connected = true;
    print("[MySQL] Connected successfully");
    
    return conn;
}

fn mysqlConnectUrl(url: string) -> MysqlConnection {
    let config = mysqlConfigFromUrl(url);
    return mysqlConnect(config);
}

impl MysqlConnection {
    fn close(self) {
        if (self.connected) {
            print("[MySQL] Closing connection " + self.id);
            self.connected = false;
        }
    }
    
    fn isConnected(self) -> bool {
        return self.connected;
    }
    
    fn ping(self) -> bool {
        return self.connected;
    }
    
    fn selectDb(self, database: string) -> bool {
        if (!self.connected) { return false; }
        self.config.database = database;
        print("[MySQL] Selected database: " + database);
        return true;
    }
}

// ============================================
// Query Results
// ============================================

struct MysqlRow {
    columns: [string],
    values: [any]
}

struct MysqlResult {
    rows: [MysqlRow],
    rowCount: int,
    affectedRows: int,
    lastInsertId: int,
    error: string
}

fn createMysqlResult() -> MysqlResult {
    return MysqlResult {
        rows: [],
        rowCount: 0,
        affectedRows: 0,
        lastInsertId: 0,
        error: ""
    };
}

impl MysqlRow {
    fn get(self, column: string) -> any {
        let i = 0;
        while (i < len(self.columns)) {
            if (self.columns[i] == column) {
                return self.values[i];
            }
            i = i + 1;
        }
        return null;
    }
    
    fn getInt(self, column: string) -> int {
        let val = self.get(column);
        if (val == null) { return 0; }
        return parseInt("" + val);
    }
    
    fn getString(self, column: string) -> string {
        let val = self.get(column);
        if (val == null) { return ""; }
        return "" + val;
    }
    
    fn getBool(self, column: string) -> bool {
        let val = self.get(column);
        return val == true || val == "1" || val == 1;
    }
}

impl MysqlResult {
    fn hasRows(self) -> bool {
        return self.rowCount > 0;
    }
    
    fn first(self) -> MysqlRow {
        if (self.rowCount > 0) {
            return self.rows[0];
        }
        return null;
    }
    
    fn isEmpty(self) -> bool {
        return self.rowCount == 0;
    }
    
    fn hasError(self) -> bool {
        return len(self.error) > 0;
    }
}

// ============================================
// Query Execution
// ============================================

fn mysqlQuery(conn: MysqlConnection, sql: string) -> MysqlResult {
    let result = createMysqlResult();
    
    if (!conn.connected) {
        result.error = "Not connected";
        return result;
    }
    
    print("[MySQL] Query: " + sql);
    
    // Simulate query
    if (startsWith(toUpperCase(sql), "SELECT")) {
        result.rowCount = 1;
        let row = MysqlRow {
            columns: ["id", "name", "created_at"],
            values: [1, "Demo Row", "2024-01-01 00:00:00"]
        };
        push(result.rows, row);
    } else if (startsWith(toUpperCase(sql), "INSERT")) {
        result.affectedRows = 1;
        result.lastInsertId = timestampMs() % 10000;
        conn.lastInsertId = result.lastInsertId;
    } else if (startsWith(toUpperCase(sql), "UPDATE") || startsWith(toUpperCase(sql), "DELETE")) {
        result.affectedRows = 1;
    }
    
    return result;
}

fn mysqlQueryParams(conn: MysqlConnection, sql: string, params: [any]) -> MysqlResult {
    let finalSql = sql;
    let i = 0;
    while (i < len(params)) {
        let value = mysqlFormatParam(params[i]);
        let idx = indexOf(finalSql, "?");
        if (idx >= 0) {
            finalSql = substr(finalSql, 0, idx) + value + substr(finalSql, idx + 1, len(finalSql) - idx - 1);
        }
        i = i + 1;
    }
    
    return mysqlQuery(conn, finalSql);
}

fn mysqlFormatParam(value: any) -> string {
    if (value == null) {
        return "NULL";
    }
    let str = "" + value;
    str = replace(str, "\\", "\\\\");
    str = replace(str, "'", "\\'");
    return "'" + str + "'";
}

fn mysqlExecute(conn: MysqlConnection, sql: string) -> int {
    let result = mysqlQuery(conn, sql);
    return result.affectedRows;
}

// ============================================
// Transaction Support
// ============================================

fn mysqlBegin(conn: MysqlConnection) -> bool {
    if (conn.inTransaction) {
        conn.lastError = "Already in transaction";
        return false;
    }
    
    mysqlQuery(conn, "START TRANSACTION");
    conn.inTransaction = true;
    print("[MySQL] Transaction started");
    return true;
}

fn mysqlCommit(conn: MysqlConnection) -> bool {
    if (!conn.inTransaction) {
        conn.lastError = "Not in transaction";
        return false;
    }
    
    mysqlQuery(conn, "COMMIT");
    conn.inTransaction = false;
    print("[MySQL] Transaction committed");
    return true;
}

fn mysqlRollback(conn: MysqlConnection) -> bool {
    if (!conn.inTransaction) {
        conn.lastError = "Not in transaction";
        return false;
    }
    
    mysqlQuery(conn, "ROLLBACK");
    conn.inTransaction = false;
    print("[MySQL] Transaction rolled back");
    return true;
}

// ============================================
// Query Builder
// ============================================

struct MysqlQueryBuilder {
    table: string,
    selectCols: [string],
    whereClauses: [string],
    orderBy: string,
    limitVal: int,
    offsetVal: int
}

fn mysqlTable(tableName: string) -> MysqlQueryBuilder {
    return MysqlQueryBuilder {
        table: tableName,
        selectCols: [],
        whereClauses: [],
        orderBy: "",
        limitVal: 0,
        offsetVal: 0
    };
}

impl MysqlQueryBuilder {
    fn select(self, columns: [string]) -> MysqlQueryBuilder {
        self.selectCols = columns;
        return self;
    }
    
    fn where(self, condition: string) -> MysqlQueryBuilder {
        push(self.whereClauses, condition);
        return self;
    }
    
    fn whereEq(self, column: string, value: any) -> MysqlQueryBuilder {
        let cond = column + " = " + mysqlFormatParam(value);
        push(self.whereClauses, cond);
        return self;
    }
    
    fn order(self, column: string, direction: string) -> MysqlQueryBuilder {
        self.orderBy = column + " " + direction;
        return self;
    }
    
    fn limit(self, n: int) -> MysqlQueryBuilder {
        self.limitVal = n;
        return self;
    }
    
    fn offset(self, n: int) -> MysqlQueryBuilder {
        self.offsetVal = n;
        return self;
    }
    
    fn toSql(self) -> string {
        let sql = "SELECT ";
        
        if (len(self.selectCols) == 0) {
            sql = sql + "*";
        } else {
            sql = sql + join(self.selectCols, ", ");
        }
        
        sql = sql + " FROM " + self.table;
        
        if (len(self.whereClauses) > 0) {
            sql = sql + " WHERE " + join(self.whereClauses, " AND ");
        }
        
        if (len(self.orderBy) > 0) {
            sql = sql + " ORDER BY " + self.orderBy;
        }
        
        if (self.limitVal > 0) {
            sql = sql + " LIMIT " + self.limitVal;
        }
        
        if (self.offsetVal > 0) {
            sql = sql + " OFFSET " + self.offsetVal;
        }
        
        return sql;
    }
    
    fn run(self, conn: MysqlConnection) -> MysqlResult {
        return mysqlQuery(conn, self.toSql());
    }
}

// ============================================
// Helper Functions
// ============================================

fn mysqlEscape(value: string) -> string {
    let result = value;
    result = replace(result, "\\", "\\\\");
    result = replace(result, "'", "\\'");
    result = replace(result, "\"", "\\\"");
    result = replace(result, "\n", "\\n");
    result = replace(result, "\r", "\\r");
    result = replace(result, "\t", "\\t");
    result = replace(result, "\0", "\\0");
    return result;
}

fn mysqlQuote(value: string) -> string {
    return "'" + mysqlEscape(value) + "'";
}

fn mysqlBacktick(identifier: string) -> string {
    return "`" + replace(identifier, "`", "``") + "`";
}
