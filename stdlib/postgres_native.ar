// ============================================
// ARGON POSTGRESQL CLIENT (Native Implementation)
// PostgreSQL Wire Protocol v3.0
// ============================================

let PG_VERSION = "1.0.0";

// Connection struct
struct PgConnection {
    socket: int,
    connected: bool,
    host: string,
    port: int,
    user: string,
    database: string,
    backend_pid: int,
    backend_key: int
}

// Query result
struct PgResult {
    success: bool,
    rows: any,
    columns: any,
    affected: int,
    error: string
}

// ============================================
// BYTE UTILITIES
// ============================================

fn int32_to_bytes(n) {
    let bytes = [];
    push(bytes, (n / 16777216) % 256);
    push(bytes, (n / 65536) % 256);
    push(bytes, (n / 256) % 256);
    push(bytes, n % 256);
    return bytes;
}

fn bytes_to_int32(bytes, offset) {
    let b0 = bytes[offset];
    let b1 = bytes[offset + 1];
    let b2 = bytes[offset + 2];
    let b3 = bytes[offset + 3];
    return b0 * 16777216 + b1 * 65536 + b2 * 256 + b3;
}

fn bytes_to_int16(bytes, offset) {
    return bytes[offset] * 256 + bytes[offset + 1];
}

fn string_to_bytes(s) {
    return @string_to_bytes(s);
}

fn bytes_to_string(bytes) {
    return @bytes_to_string(bytes);
}

fn append_bytes(dest, src) {
    let i = 0;
    while (i < len(src)) {
        push(dest, src[i]);
        i = i + 1;
    }
}

fn append_string(dest, s) {
    let bytes = string_to_bytes(s);
    append_bytes(dest, bytes);
}

fn append_cstring(dest, s) {
    append_string(dest, s);
    push(dest, 0);  // null terminator
}

// ============================================
// PROTOCOL MESSAGES
// ============================================

fn build_startup_message(user, database) {
    // Startup message format:
    // Length (4 bytes) + Protocol version (4 bytes) + Parameters + \0\0
    
    let params = [];
    append_cstring(params, "user");
    append_cstring(params, user);
    append_cstring(params, "database");
    append_cstring(params, database);
    push(params, 0);  // End of parameters
    
    // Protocol version 3.0 = 196608 (0x00030000)
    let version = [];
    push(version, 0);
    push(version, 3);
    push(version, 0);
    push(version, 0);
    
    // Total length = 4 (length) + 4 (version) + params
    let total_len = 4 + 4 + len(params);
    
    let msg = [];
    append_bytes(msg, int32_to_bytes(total_len));
    append_bytes(msg, version);
    append_bytes(msg, params);
    
    return msg;
}

fn build_query_message(query) {
    // Query message: 'Q' + length (4) + query + \0
    let query_bytes = [];
    append_string(query_bytes, query);
    push(query_bytes, 0);
    
    let total_len = 4 + len(query_bytes);
    
    let msg = [];
    push(msg, 81);  // 'Q'
    append_bytes(msg, int32_to_bytes(total_len));
    append_bytes(msg, query_bytes);
    
    return msg;
}

fn build_terminate_message() {
    // Terminate: 'X' + length (4)
    let msg = [];
    push(msg, 88);  // 'X'
    append_bytes(msg, int32_to_bytes(4));
    return msg;
}

// ============================================
// CONNECTION
// ============================================

fn pg_connect(host, port, user, database) {
    print("[PG] Connecting to " + host + ":" + port + "...");
    
    let socket = @tcp_connect(host, port);
    if (socket < 0) {
        print("[PG] Failed to connect!");
        return null;
    }
    
    print("[PG] TCP connected, sending startup message...");
    
    // Send startup message
    let startup = build_startup_message(user, database);
    @tcp_write_raw(socket, startup);
    
    // Read response
    let conn = PgConnection {
        socket: socket,
        connected: false,
        host: host,
        port: port,
        user: user,
        database: database,
        backend_pid: 0,
        backend_key: 0
    };
    
    // Handle authentication
    let auth_ok = handle_auth(conn);
    
    if (auth_ok) {
        conn.connected = true;
        print("[PG] Connected successfully!");
    } else {
        print("[PG] Authentication failed!");
        @argon_socket_close(socket);
        return null;
    }
    
    return conn;
}

fn handle_auth(conn) {
    // Read messages until ReadyForQuery or error
    let ready = false;
    let max_attempts = 50;  // Increased to handle many parameter status messages
    let attempts = 0;
    
    while (!ready && attempts < max_attempts) {
        attempts = attempts + 1;
        
        // Read message type (1 byte) + length (4 bytes)
        let header = @tcp_read_raw(conn.socket, 5);
        if (len(header) < 5) {
            print("[PG] Failed to read header");
            return false;
        }
        
        let msg_type = header[0];
        let msg_len = bytes_to_int32(header, 1) - 4;
        
        // Read message body
        let body = [];
        if (msg_len > 0) {
            body = @tcp_read_raw(conn.socket, msg_len);
        }
        
        // Handle message types
        if (msg_type == 82) {  // 'R' - Authentication
            let auth_type = bytes_to_int32(body, 0);
            if (auth_type == 0) {
                print("[PG] Authentication OK (trust mode)");
            } else if (auth_type == 3) {
                print("[PG] Clear text password required (not supported)");
                return false;
            } else if (auth_type == 5) {
                print("[PG] MD5 password required (not supported yet)");
                return false;
            } else {
                print("[PG] Unknown auth type: " + auth_type);
            }
        } else if (msg_type == 75) {  // 'K' - BackendKeyData
            conn.backend_pid = bytes_to_int32(body, 0);
            conn.backend_key = bytes_to_int32(body, 4);
            print("[PG] Backend PID: " + conn.backend_pid);
        } else if (msg_type == 83) {  // 'S' - ParameterStatus
            // Parse parameter name and value
            let param = read_cstring(body, 0);
            print("[PG] Parameter: " + param);
        } else if (msg_type == 90) {  // 'Z' - ReadyForQuery
            print("[PG] Ready for query!");
            ready = true;
        } else if (msg_type == 69) {  // 'E' - Error
            print("[PG] Error from server");
            return false;
        }
    }
    
    return ready;
}

fn read_cstring(bytes, offset) {
    let result = [];
    let i = offset;
    while (i < len(bytes) && bytes[i] != 0) {
        push(result, bytes[i]);
        i = i + 1;
    }
    return bytes_to_string(result);
}

// ============================================
// QUERY EXECUTION
// ============================================

fn pg_query(conn, sql) {
    if (!conn.connected) {
        return PgResult { success: false, rows: [], columns: [], affected: 0, error: "Not connected" };
    }
    
    print("[PG] Executing: " + sql);
    
    // Send query
    let query_msg = build_query_message(sql);
    @tcp_write_raw(conn.socket, query_msg);
    
    // Parse response
    let result = PgResult {
        success: false,
        rows: [],
        columns: [],
        affected: 0,
        error: ""
    };
    
    let done = false;
    let max_messages = 100;
    let msg_count = 0;
    
    while (!done && msg_count < max_messages) {
        msg_count = msg_count + 1;
        
        let header = @tcp_read_raw(conn.socket, 5);
        if (len(header) < 5) {
            result.error = "Failed to read response";
            return result;
        }
        
        let msg_type = header[0];
        let msg_len = bytes_to_int32(header, 1) - 4;
        
        let body = [];
        if (msg_len > 0) {
            body = @tcp_read_raw(conn.socket, msg_len);
        }
        
        if (msg_type == 84) {  // 'T' - RowDescription
            // Parse column names
            let num_cols = bytes_to_int16(body, 0);
            print("[PG] Columns: " + num_cols);
            // Note: Full column parsing would go here
            result.columns = num_cols;
        } else if (msg_type == 68) {  // 'D' - DataRow
            let num_values = bytes_to_int16(body, 0);
            print("[PG] Row with " + num_values + " values");
            // Note: Full row parsing would go here
            push(result.rows, body);
        } else if (msg_type == 67) {  // 'C' - CommandComplete
            let tag = read_cstring(body, 0);
            print("[PG] Command complete: " + tag);
            result.success = true;
        } else if (msg_type == 90) {  // 'Z' - ReadyForQuery
            done = true;
        } else if (msg_type == 69) {  // 'E' - ErrorResponse
            result.error = "Query error";
            print("[PG] Query error");
        }
    }
    
    return result;
}

// ============================================
// DISCONNECT
// ============================================

fn pg_close(conn) {
    if (conn.connected) {
        let term = build_terminate_message();
        @tcp_write_raw(conn.socket, term);
        @argon_socket_close(conn.socket);
        conn.connected = false;
        print("[PG] Connection closed");
    }
}

// ============================================
// CONVENIENCE FUNCTIONS
// ============================================

fn pg_exec(conn, sql) {
    let result = pg_query(conn, sql);
    return result.success;
}
