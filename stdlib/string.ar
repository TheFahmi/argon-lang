// ============================================
// ARGON STANDARD LIBRARY: STRING
// String manipulation functions
// ============================================

// Get string length
fn strLen(s) {
    return len(s);
}

// Check if string is empty
fn isEmpty(s) {
    return len(s) == 0;
}

// Get character at index (returns single-char string)
fn charAt(s, idx) {
    if (idx < 0) {
        return "";
    }
    if (idx >= len(s)) {
        return "";
    }
    return s[idx];
}

// Get character code at index
fn codeAt(s, idx) {
    return charCodeAt(s, idx);
}

// Check if string starts with prefix
fn startsWith(s, prefix) {
    let prefix_len = len(prefix);
    if (prefix_len > len(s)) {
        return false;
    }
    let i = 0;
    while (i < prefix_len) {
        if (s[i] != prefix[i]) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Check if string ends with suffix
fn endsWith(s, suffix) {
    let s_len = len(s);
    let suffix_len = len(suffix);
    if (suffix_len > s_len) {
        return false;
    }
    let offset = s_len - suffix_len;
    let i = 0;
    while (i < suffix_len) {
        if (s[offset + i] != suffix[i]) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Check if string contains substring
fn contains(s, sub) {
    return indexOf(s, sub) >= 0;
}

// Find index of substring (returns -1 if not found)
fn indexOf(s, sub) {
    let s_len = len(s);
    let sub_len = len(sub);
    if (sub_len == 0) {
        return 0;
    }
    if (sub_len > s_len) {
        return 0 - 1;
    }
    
    let i = 0;
    while (i <= s_len - sub_len) {
        let is_match = true;
        let j = 0;
        while (j < sub_len) {
            if (s[i + j] != sub[j]) {
                is_match = false;
                j = sub_len; // break
            } else {
                j = j + 1;
            }
        }
        if (is_match) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}

// Find last index of substring
fn lastIndexOf(s, sub) {
    let s_len = len(s);
    let sub_len = len(sub);
    if (sub_len == 0) {
        return s_len;
    }
    if (sub_len > s_len) {
        return 0 - 1;
    }
    
    let i = s_len - sub_len;
    while (i >= 0) {
        let is_match = true;
        let j = 0;
        while (j < sub_len) {
            if (s[i + j] != sub[j]) {
                is_match = false;
                j = sub_len;
            } else {
                j = j + 1;
            }
        }
        if (is_match) {
            return i;
        }
        i = i - 1;
    }
    return 0 - 1;
}

// Extract substring
fn substring(s, start, end) {
    let s_len = len(s);
    if (start < 0) {
        start = 0;
    }
    if (end > s_len) {
        end = s_len;
    }
    if (start >= end) {
        return "";
    }
    
    let result = "";
    let i = start;
    while (i < end) {
        result = result + s[i];
        i = i + 1;
    }
    return result;
}

// Extract substring from start to end of string
fn substr(s, start) {
    return substring(s, start, len(s));
}

// Repeat string n times
fn repeat(s, n) {
    if (n <= 0) {
        return "";
    }
    let result = "";
    let i = 0;
    while (i < n) {
        result = result + s;
        i = i + 1;
    }
    return result;
}

// Reverse string
fn reverse(s) {
    let result = "";
    let i = len(s) - 1;
    while (i >= 0) {
        result = result + s[i];
        i = i - 1;
    }
    return result;
}

// Trim whitespace from both ends
fn trim(s) {
    return trimEnd(trimStart(s));
}

// Trim whitespace from start
fn trimStart(s) {
    let i = 0;
    let n = len(s);
    while (i < n) {
        let c = s[i];
        if (c != " ") {
            if (c != "\t") {
                if (c != "\n") {
                    if (c != "\r") {
                        // Found non-whitespace
                        return substring(s, i, n);
                    }
                }
            }
        }
        i = i + 1;
    }
    return "";
}

// Trim whitespace from end
fn trimEnd(s) {
    let n = len(s);
    let i = n - 1;
    while (i >= 0) {
        let c = s[i];
        if (c != " ") {
            if (c != "\t") {
                if (c != "\n") {
                    if (c != "\r") {
                        return substring(s, 0, i + 1);
                    }
                }
            }
        }
        i = i - 1;
    }
    return "";
}

// Pad string on left to reach length
fn padStart(s, target_len, pad_char) {
    let current_len = len(s);
    if (current_len >= target_len) {
        return s;
    }
    let pad_count = target_len - current_len;
    return repeat(pad_char, pad_count) + s;
}

// Pad string on right to reach length
fn padEnd(s, target_len, pad_char) {
    let current_len = len(s);
    if (current_len >= target_len) {
        return s;
    }
    let pad_count = target_len - current_len;
    return s + repeat(pad_char, pad_count);
}

// Split string by delimiter
fn split(s, delim) {
    let result = [];
    let s_len = len(s);
    let delim_len = len(delim);
    
    if (delim_len == 0) {
        // Split into characters
        let i = 0;
        while (i < s_len) {
            result = push(result, s[i]);
            i = i + 1;
        }
        return result;
    }
    
    let start = 0;
    let i = 0;
    while (i <= s_len - delim_len) {
        let is_match = true;
        let j = 0;
        while (j < delim_len) {
            if (s[i + j] != delim[j]) {
                is_match = false;
                j = delim_len;
            } else {
                j = j + 1;
            }
        }
        if (is_match) {
            result = push(result, substring(s, start, i));
            start = i + delim_len;
            i = start;
        } else {
            i = i + 1;
        }
    }
    // Add remaining
    result = push(result, substring(s, start, s_len));
    return result;
}

// Join array elements with separator
fn join(arr, sep) {
    let result = "";
    let i = 0;
    let n = len(arr);
    while (i < n) {
        if (i > 0) {
            result = result + sep;
        }
        result = result + arr[i];
        i = i + 1;
    }
    return result;
}

// Replace first occurrence of old with new
fn replace(s, old, new) {
    let idx = indexOf(s, old);
    if (idx < 0) {
        return s;
    }
    let before = substring(s, 0, idx);
    let after = substring(s, idx + len(old), len(s));
    return before + new + after;
}

// Replace all occurrences of old with new
fn replaceAll(s, old, new) {
    let old_len = len(old);
    if (old_len == 0) {
        return s;
    }
    
    let result = "";
    let s_len = len(s);
    let i = 0;
    
    while (i < s_len) {
        let is_match = true;
        if (i <= s_len - old_len) {
            let j = 0;
            while (j < old_len) {
                if (s[i + j] != old[j]) {
                    is_match = false;
                    j = old_len;
                } else {
                    j = j + 1;
                }
            }
        } else {
            is_match = false;
        }
        
        if (is_match) {
            result = result + new;
            i = i + old_len;
        } else {
            result = result + s[i];
            i = i + 1;
        }
    }
    return result;
}

// Convert to uppercase (ASCII only)
fn toUpper(s) {
    let result = "";
    let i = 0;
    let n = len(s);
    while (i < n) {
        let c = s[i];
        // Check if lowercase a-z and convert to uppercase
        if (c == "a") { result = result + "A"; }
        else if (c == "b") { result = result + "B"; }
        else if (c == "c") { result = result + "C"; }
        else if (c == "d") { result = result + "D"; }
        else if (c == "e") { result = result + "E"; }
        else if (c == "f") { result = result + "F"; }
        else if (c == "g") { result = result + "G"; }
        else if (c == "h") { result = result + "H"; }
        else if (c == "i") { result = result + "I"; }
        else if (c == "j") { result = result + "J"; }
        else if (c == "k") { result = result + "K"; }
        else if (c == "l") { result = result + "L"; }
        else if (c == "m") { result = result + "M"; }
        else if (c == "n") { result = result + "N"; }
        else if (c == "o") { result = result + "O"; }
        else if (c == "p") { result = result + "P"; }
        else if (c == "q") { result = result + "Q"; }
        else if (c == "r") { result = result + "R"; }
        else if (c == "s") { result = result + "S"; }
        else if (c == "t") { result = result + "T"; }
        else if (c == "u") { result = result + "U"; }
        else if (c == "v") { result = result + "V"; }
        else if (c == "w") { result = result + "W"; }
        else if (c == "x") { result = result + "X"; }
        else if (c == "y") { result = result + "Y"; }
        else if (c == "z") { result = result + "Z"; }
        else { result = result + c; }
        i = i + 1;
    }
    return result;
}

// Convert to lowercase (ASCII only)  
fn toLower(s) {
    let result = "";
    let i = 0;
    let n = len(s);
    while (i < n) {
        let c = s[i];
        // Check if uppercase A-Z and convert to lowercase
        if (c == "A") { result = result + "a"; }
        else if (c == "B") { result = result + "b"; }
        else if (c == "C") { result = result + "c"; }
        else if (c == "D") { result = result + "d"; }
        else if (c == "E") { result = result + "e"; }
        else if (c == "F") { result = result + "f"; }
        else if (c == "G") { result = result + "g"; }
        else if (c == "H") { result = result + "h"; }
        else if (c == "I") { result = result + "i"; }
        else if (c == "J") { result = result + "j"; }
        else if (c == "K") { result = result + "k"; }
        else if (c == "L") { result = result + "l"; }
        else if (c == "M") { result = result + "m"; }
        else if (c == "N") { result = result + "n"; }
        else if (c == "O") { result = result + "o"; }
        else if (c == "P") { result = result + "p"; }
        else if (c == "Q") { result = result + "q"; }
        else if (c == "R") { result = result + "r"; }
        else if (c == "S") { result = result + "s"; }
        else if (c == "T") { result = result + "t"; }
        else if (c == "U") { result = result + "u"; }
        else if (c == "V") { result = result + "v"; }
        else if (c == "W") { result = result + "w"; }
        else if (c == "X") { result = result + "x"; }
        else if (c == "Y") { result = result + "y"; }
        else if (c == "Z") { result = result + "z"; }
        else { result = result + c; }
        i = i + 1;
    }
    return result;
}

// Check if string is numeric
fn isNumeric(s) {
    let n = len(s);
    if (n == 0) {
        return false;
    }
    let i = 0;
    // Allow leading minus
    if (s[0] == "-") {
        if (n == 1) {
            return false;
        }
        i = 1;
    }
    while (i < n) {
        let code = charCodeAt(s, i);
        // 0-9: 48-57
        if (code < 48) {
            return false;
        }
        if (code > 57) {
            return false;
        }
        i = i + 1;
    }
    return true;
}
