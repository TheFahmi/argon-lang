// ============================================
// CRYO MONGODB CLIENT (Native Implementation)
// MongoDB Wire Protocol v3.6+
// ============================================

let MONGODB_VERSION = "1.0.0";

// ============================================
// STRUCTS
// ============================================

struct MongoConnection {
    socket: int,
    connected: bool,
    host: string,
    port: int,
    database: string,
    requestId: int
}

struct MongoResult {
    success: bool,
    documents: any,
    count: int,
    error: string
}

struct MongoDocument {
    _id: string,
    data: any
}

// ============================================
// BSON TYPES
// ============================================

let BSON_DOUBLE = 1;
let BSON_STRING = 2;
let BSON_DOCUMENT = 3;
let BSON_ARRAY = 4;
let BSON_BINARY = 5;
let BSON_OBJECTID = 7;
let BSON_BOOLEAN = 8;
let BSON_DATETIME = 9;
let BSON_NULL = 10;
let BSON_INT32 = 16;
let BSON_INT64 = 18;

// MongoDB Wire Protocol OP_MSG = 2013
let OP_MSG = 2013;
let OP_REPLY = 1;
let OP_QUERY = 2004;

// ============================================
// BYTE UTILITIES
// ============================================

fn int32ToLE(n) {
    let bytes = [];
    push(bytes, n % 256);
    push(bytes, (n / 256) % 256);
    push(bytes, (n / 65536) % 256);
    push(bytes, (n / 16777216) % 256);
    return bytes;
}

fn leToInt32(bytes, offset) {
    return bytes[offset] + 
           bytes[offset + 1] * 256 + 
           bytes[offset + 2] * 65536 + 
           bytes[offset + 3] * 16777216;
}

fn int64ToLE(n) {
    // For simplicity, we only handle 32-bit range
    let bytes = int32ToLE(n);
    push(bytes, 0);
    push(bytes, 0);
    push(bytes, 0);
    push(bytes, 0);
    return bytes;
}

fn appendBytes(dest, src) {
    let i = 0;
    while (i < len(src)) {
        push(dest, src[i]);
        i = i + 1;
    }
}

fn appendString(dest, s) {
    let bytes = @stringToBytes(s);
    appendBytes(dest, bytes);
}

// ============================================
// BSON ENCODING
// ============================================

fn bsonEncode(doc) {
    // Encode a Cryo object to BSON bytes
    let body = [];
    
    let keys = @objectKeys(doc);
    let i = 0;
    while (i < len(keys)) {
        let key = keys[i];
        let val = doc[key];
        
        if (typeof(val) == "string") {
            // String type
            push(body, BSON_STRING);
            appendString(body, key);
            push(body, 0);  // null terminator for key
            
            let strBytes = @stringToBytes(val);
            appendBytes(body, int32ToLE(len(strBytes) + 1));
            appendBytes(body, strBytes);
            push(body, 0);  // null terminator for value
            
        } else if (typeof(val) == "number") {
            // Check if integer or float
            if (floor(val) == val && val >= -2147483648 && val <= 2147483647) {
                // Int32
                push(body, BSON_INT32);
                appendString(body, key);
                push(body, 0);
                appendBytes(body, int32ToLE(val));
            } else {
                // Double
                push(body, BSON_DOUBLE);
                appendString(body, key);
                push(body, 0);
                appendBytes(body, doubleToBytes(val));
            }
            
        } else if (typeof(val) == "boolean") {
            push(body, BSON_BOOLEAN);
            appendString(body, key);
            push(body, 0);
            push(body, val ? 1 : 0);
            
        } else if (val == null) {
            push(body, BSON_NULL);
            appendString(body, key);
            push(body, 0);
            
        } else if (typeof(val) == "array") {
            // Array - encode as BSON array
            push(body, BSON_ARRAY);
            appendString(body, key);
            push(body, 0);
            
            let arrDoc = {};
            let j = 0;
            while (j < len(val)) {
                arrDoc[toString(j)] = val[j];
                j = j + 1;
            }
            let arrBytes = bsonEncode(arrDoc);
            appendBytes(body, arrBytes);
            
        } else if (typeof(val) == "object") {
            // Embedded document
            push(body, BSON_DOCUMENT);
            appendString(body, key);
            push(body, 0);
            let docBytes = bsonEncode(val);
            appendBytes(body, docBytes);
        }
        
        i = i + 1;
    }
    
    push(body, 0);  // null terminator
    
    // Prepend size (4 bytes for size + body length)
    let total = [];
    appendBytes(total, int32ToLE(len(body) + 4));
    appendBytes(total, body);
    
    return total;
}

fn doubleToBytes(val) {
    // Simplified - just return 8 bytes for double representation
    // In a real implementation, this would use IEEE 754
    let bytes = [];
    let i = 0;
    while (i < 8) {
        push(bytes, 0);
        i = i + 1;
    }
    // Store integer part in first 4 bytes
    let int_part = floor(val);
    let b = int32ToLE(int_part);
    bytes[0] = b[0];
    bytes[1] = b[1];
    bytes[2] = b[2];
    bytes[3] = b[3];
    return bytes;
}

// ============================================
// BSON DECODING
// ============================================

fn bsonDecode(bytes, offset) {
    if (offset >= len(bytes)) {
        return { doc: {}, end: offset };
    }
    
    let docSize = leToInt32(bytes, offset);
    let doc = {};
    let pos = offset + 4;
    
    while (pos < offset + docSize - 1) {
        let type = bytes[pos];
        pos = pos + 1;
        
        if (type == 0) {
            break;
        }
        
        // Read key (null-terminated)
        let key = "";
        while (pos < len(bytes) && bytes[pos] != 0) {
            key = key + @chr(bytes[pos]);
            pos = pos + 1;
        }
        pos = pos + 1;  // skip null
        
        // Read value based on type
        if (type == BSON_STRING) {
            let strLen = leToInt32(bytes, pos);
            pos = pos + 4;
            let val = "";
            let i = 0;
            while (i < strLen - 1 && pos + i < len(bytes)) {
                val = val + @chr(bytes[pos + i]);
                i = i + 1;
            }
            pos = pos + strLen;
            doc[key] = val;
            
        } else if (type == BSON_INT32) {
            doc[key] = leToInt32(bytes, pos);
            pos = pos + 4;
            
        } else if (type == BSON_INT64) {
            // Read lower 32 bits only for simplicity
            doc[key] = leToInt32(bytes, pos);
            pos = pos + 8;
            
        } else if (type == BSON_DOUBLE) {
            // Read as int32 for simplicity
            doc[key] = leToInt32(bytes, pos);
            pos = pos + 8;
            
        } else if (type == BSON_BOOLEAN) {
            doc[key] = bytes[pos] != 0;
            pos = pos + 1;
            
        } else if (type == BSON_NULL) {
            doc[key] = null;
            
        } else if (type == BSON_DOCUMENT) {
            let nested = bsonDecode(bytes, pos);
            doc[key] = nested.doc;
            pos = nested.end;
            
        } else if (type == BSON_ARRAY) {
            let nested = bsonDecode(bytes, pos);
            // Convert document with "0", "1", ... keys to array
            let arr = [];
            let arrKeys = @objectKeys(nested.doc);
            let i = 0;
            while (i < len(arrKeys)) {
                push(arr, nested.doc[arrKeys[i]]);
                i = i + 1;
            }
            doc[key] = arr;
            pos = nested.end;
            
        } else if (type == BSON_OBJECTID) {
            // 12 bytes ObjectId
            let oid = "";
            let i = 0;
            while (i < 12 && pos + i < len(bytes)) {
                let hex = toHex(bytes[pos + i]);
                oid = oid + hex;
                i = i + 1;
            }
            doc[key] = oid;
            pos = pos + 12;
            
        } else {
            // Unknown type - skip
            break;
        }
    }
    
    return { doc: doc, end: offset + docSize };
}

fn toHex(n) {
    let hex = "0123456789abcdef";
    return charAt(hex, (n / 16) % 16) + charAt(hex, n % 16);
}

// ============================================
// WIRE PROTOCOL
// ============================================

fn buildOpMsg(conn, document) {
    // Build OP_MSG message
    let section0 = bsonEncode(document);
    
    // Message header: length (4) + requestId (4) + responseTo (4) + opcode (4)
    // + flagBits (4) + section kind (1) + section body
    
    conn.requestId = conn.requestId + 1;
    
    let messageBody = [];
    
    // Flag bits (4 bytes) - 0 for normal request
    appendBytes(messageBody, int32ToLE(0));
    
    // Section kind 0 (body)
    push(messageBody, 0);
    
    // Section body (BSON document)
    appendBytes(messageBody, section0);
    
    // Build full message with header
    let totalLen = 16 + len(messageBody);  // 16 = header size
    
    let message = [];
    appendBytes(message, int32ToLE(totalLen));       // messageLength
    appendBytes(message, int32ToLE(conn.requestId)); // requestID
    appendBytes(message, int32ToLE(0));              // responseTo
    appendBytes(message, int32ToLE(OP_MSG));         // opCode
    appendBytes(message, messageBody);
    
    return message;
}

fn parseOpMsgResponse(bytes) {
    if (len(bytes) < 21) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Response too short" 
        };
    }
    
    // Parse header
    let messageLen = leToInt32(bytes, 0);
    let requestId = leToInt32(bytes, 4);
    let responseTo = leToInt32(bytes, 8);
    let opCode = leToInt32(bytes, 12);
    
    if (opCode != OP_MSG) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Unexpected opcode: " + opCode 
        };
    }
    
    // Flag bits (4 bytes)
    let pos = 16;
    let flags = leToInt32(bytes, pos);
    pos = pos + 4;
    
    // Section kind
    let sectionKind = bytes[pos];
    pos = pos + 1;
    
    // Parse BSON document
    let decoded = bsonDecode(bytes, pos);
    let doc = decoded.doc;
    
    // Check for errors
    if (doc["ok"] != null && doc["ok"] == 0) {
        let errMsg = doc["errmsg"];
        if (errMsg == null) { errMsg = "Unknown error"; }
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: errMsg 
        };
    }
    
    // Extract documents from cursor if present
    let documents = [];
    if (doc["cursor"] != null) {
        let cursor = doc["cursor"];
        if (cursor["firstBatch"] != null) {
            documents = cursor["firstBatch"];
        } else if (cursor["nextBatch"] != null) {
            documents = cursor["nextBatch"];
        }
    } else {
        push(documents, doc);
    }
    
    return MongoResult { 
        success: true, 
        documents: documents, 
        count: len(documents), 
        error: "" 
    };
}

// ============================================
// CONNECTION
// ============================================

fn mongoConnect(host, port, database) {
    print("[MongoDB] Connecting to " + host + ":" + port + "/" + database + "...");
    
    let socket = @tcpConnect(host, port);
    if (socket < 0) {
        print("[MongoDB] Failed to connect!");
        return null;
    }
    
    let conn = MongoConnection {
        socket: socket,
        connected: true,
        host: host,
        port: port,
        database: database,
        requestId: 0
    };
    
    // Send hello/ismaster command
    let helloCmd = {
        hello: 1,
        "$db": database
    };
    
    let message = buildOpMsg(conn, helloCmd);
    @tcpWriteRaw(conn.socket, message);
    
    // Read response
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        let result = parseOpMsgResponse(response);
        if (result.success) {
            print("[MongoDB] Connected successfully");
            return conn;
        } else {
            print("[MongoDB] Hello failed: " + result.error);
        }
    }
    
    print("[MongoDB] Connection established");
    return conn;
}

fn mongoClose(conn) {
    if (conn != null && conn.connected) {
        @cryoSocketClose(conn.socket);
        conn.connected = false;
        print("[MongoDB] Connection closed");
    }
}

// ============================================
// CRUD OPERATIONS
// ============================================

fn mongoInsertOne(conn, collection, document) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] insertOne into " + collection);
    
    let cmd = {
        insert: collection,
        documents: [document],
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        return parseOpMsgResponse(response);
    }
    
    return MongoResult { 
        success: false, 
        documents: [], 
        count: 0, 
        error: "No response" 
    };
}

fn mongoInsertMany(conn, collection, documents) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] insertMany into " + collection + " (" + len(documents) + " docs)");
    
    let cmd = {
        insert: collection,
        documents: documents,
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        return parseOpMsgResponse(response);
    }
    
    return MongoResult { 
        success: false, 
        documents: [], 
        count: 0, 
        error: "No response" 
    };
}

fn mongoFind(conn, collection, filter) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] find in " + collection);
    
    let cmd = {
        find: collection,
        filter: filter,
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        return parseOpMsgResponse(response);
    }
    
    return MongoResult { 
        success: false, 
        documents: [], 
        count: 0, 
        error: "No response" 
    };
}

fn mongoFindOne(conn, collection, filter) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] findOne in " + collection);
    
    let cmd = {
        find: collection,
        filter: filter,
        limit: 1,
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        let result = parseOpMsgResponse(response);
        if (result.success && len(result.documents) > 0) {
            return result.documents[0];
        }
    }
    
    return null;
}

fn mongoUpdateOne(conn, collection, filter, update) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] updateOne in " + collection);
    
    let cmd = {
        update: collection,
        updates: [{
            q: filter,
            u: { "$set": update },
            multi: false
        }],
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        return parseOpMsgResponse(response);
    }
    
    return MongoResult { 
        success: false, 
        documents: [], 
        count: 0, 
        error: "No response" 
    };
}

fn mongoUpdateMany(conn, collection, filter, update) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] updateMany in " + collection);
    
    let cmd = {
        update: collection,
        updates: [{
            q: filter,
            u: { "$set": update },
            multi: true
        }],
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        return parseOpMsgResponse(response);
    }
    
    return MongoResult { 
        success: false, 
        documents: [], 
        count: 0, 
        error: "No response" 
    };
}

fn mongoDeleteOne(conn, collection, filter) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] deleteOne from " + collection);
    
    let cmd = {
        delete: collection,
        deletes: [{
            q: filter,
            limit: 1
        }],
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        return parseOpMsgResponse(response);
    }
    
    return MongoResult { 
        success: false, 
        documents: [], 
        count: 0, 
        error: "No response" 
    };
}

fn mongoDeleteMany(conn, collection, filter) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] deleteMany from " + collection);
    
    let cmd = {
        delete: collection,
        deletes: [{
            q: filter,
            limit: 0  // 0 = unlimited
        }],
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        return parseOpMsgResponse(response);
    }
    
    return MongoResult { 
        success: false, 
        documents: [], 
        count: 0, 
        error: "No response" 
    };
}

fn mongoCountDocuments(conn, collection, filter) {
    if (!conn.connected) {
        return -1;
    }
    
    print("[MongoDB] count in " + collection);
    
    let cmd = {
        count: collection,
        query: filter,
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        let result = parseOpMsgResponse(response);
        if (result.success && len(result.documents) > 0) {
            let doc = result.documents[0];
            if (doc["n"] != null) {
                return doc["n"];
            }
        }
    }
    
    return -1;
}

// ============================================
// AGGREGATION
// ============================================

fn mongoAggregate(conn, collection, pipeline) {
    if (!conn.connected) {
        return MongoResult { 
            success: false, 
            documents: [], 
            count: 0, 
            error: "Not connected" 
        };
    }
    
    print("[MongoDB] aggregate on " + collection);
    
    let cmd = {
        aggregate: collection,
        pipeline: pipeline,
        cursor: {},
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        return parseOpMsgResponse(response);
    }
    
    return MongoResult { 
        success: false, 
        documents: [], 
        count: 0, 
        error: "No response" 
    };
}

// ============================================
// DATABASE COMMANDS
// ============================================

fn mongoCreateCollection(conn, collectionName) {
    if (!conn.connected) {
        return false;
    }
    
    print("[MongoDB] createCollection: " + collectionName);
    
    let cmd = {
        create: collectionName,
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        let result = parseOpMsgResponse(response);
        return result.success;
    }
    
    return false;
}

fn mongoDropCollection(conn, collectionName) {
    if (!conn.connected) {
        return false;
    }
    
    print("[MongoDB] dropCollection: " + collectionName);
    
    let cmd = {
        drop: collectionName,
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        let result = parseOpMsgResponse(response);
        return result.success;
    }
    
    return false;
}

fn mongoListCollections(conn) {
    if (!conn.connected) {
        return [];
    }
    
    print("[MongoDB] listCollections");
    
    let cmd = {
        listCollections: 1,
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        let result = parseOpMsgResponse(response);
        if (result.success) {
            let collections = [];
            let i = 0;
            while (i < len(result.documents)) {
                let doc = result.documents[i];
                if (doc["name"] != null) {
                    push(collections, doc["name"]);
                }
                i = i + 1;
            }
            return collections;
        }
    }
    
    return [];
}

// ============================================
// INDEX OPERATIONS
// ============================================

fn mongoCreateIndex(conn, collection, keys, options) {
    if (!conn.connected) {
        return false;
    }
    
    print("[MongoDB] createIndexes on " + collection);
    
    let indexSpec = {
        key: keys,
        name: generateIndexName(keys)
    };
    
    if (options != null) {
        if (options["unique"] != null) {
            indexSpec["unique"] = options["unique"];
        }
        if (options["name"] != null) {
            indexSpec["name"] = options["name"];
        }
    }
    
    let cmd = {
        createIndexes: collection,
        indexes: [indexSpec],
        "$db": conn.database
    };
    
    let message = buildOpMsg(conn, cmd);
    @tcpWriteRaw(conn.socket, message);
    
    let response = @tcpReadAvailable(conn.socket);
    if (len(response) > 0) {
        let result = parseOpMsgResponse(response);
        return result.success;
    }
    
    return false;
}

fn generateIndexName(keys) {
    let name = "";
    let keyNames = @objectKeys(keys);
    let i = 0;
    while (i < len(keyNames)) {
        if (i > 0) { name = name + "_"; }
        name = name + keyNames[i] + "_" + keys[keyNames[i]];
        i = i + 1;
    }
    return name;
}
