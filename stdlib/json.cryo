// ============================================
// CRYO STANDARD LIBRARY: JSON
// JSON parsing and serialization
// ============================================

// JSON value types
let JSON_NULL = 0;
let JSON_BOOL = 1;
let JSON_NUMBER = 2;
let JSON_STRING = 3;
let JSON_ARRAY = 4;
let JSON_OBJECT = 5;

// Create JSON null
fn jsonNull() {
    let res = [JSON_NULL, null];
    return res;
}

// Create JSON boolean
fn jsonBool(val) {
    let res = [JSON_BOOL, val];
    return res;
}

// Create JSON number
fn jsonNumber(val) {
    let res = [JSON_NUMBER, val];
    return res;
}

// Create JSON string
fn jsonString(val) {
    let res = [JSON_STRING, val];
    return res;
}

// Create JSON array
fn jsonArray(items) {
    let res = [JSON_ARRAY, items];
    return res;
}

// Create JSON object (from list of key-value pairs)
fn jsonObject(pairs) {
    let res = [JSON_OBJECT, pairs];
    return res;
}

// Get JSON value type
fn jsonType(val) {
    return val[0];
}

// Get JSON inner value
fn jsonValue(val) {
    return val[1];
}

// Check if JSON is null
fn jsonIsNull(val) {
    return val[0] == JSON_NULL;
}

// Check if JSON is number
fn jsonIsNumber(val) {
    return val[0] == JSON_NUMBER;
}

// Check if JSON is string
fn jsonIsString(val) {
    return val[0] == JSON_STRING;
}

// Check if JSON is array
fn jsonIsArray(val) {
    return val[0] == JSON_ARRAY;
}

// Check if JSON is object
fn jsonIsObject(val) {
    return val[0] == JSON_OBJECT;
}

// Get object property by key
fn jsonGet(obj, key) {
    if (obj[0] != JSON_OBJECT) {
        return jsonNull();
    }
    let pairs = obj[1];
    let i = 0;
    while (i < len(pairs)) {
        let pair = pairs[i];
        if (pair[0] == key) {
            return pair[1];
        }
        i = i + 1;
    }
    return jsonNull();
}

// Get array element by index
fn jsonGetAt(arr, idx) {
    if (arr[0] != JSON_ARRAY) {
        return jsonNull();
    }
    let items = arr[1];
    if (idx < 0) {
        return jsonNull();
    }
    if (idx >= len(items)) {
        return jsonNull();
    }
    return items[idx];
}

// Stringify JSON value (simple version)
fn jsonStringify(val) {
    let typ = val[0];
    let inner = val[1];
    
    if (typ == JSON_NULL) {
        return "null";
    }
    if (typ == JSON_BOOL) {
        if (inner) {
            return "true";
        }
        return "false";
    }
    if (typ == JSON_NUMBER) {
        return "" + inner;
    }
    if (typ == JSON_STRING) {
        return "\"" + jsonEscapeString(inner) + "\"";
    }
    if (typ == JSON_ARRAY) {
        let result = "[";
        let i = 0;
        while (i < len(inner)) {
            if (i > 0) {
                result = result + ",";
            }
            result = result + jsonStringify(inner[i]);
            i = i + 1;
        }
        return result + "]";
    }
    if (typ == JSON_OBJECT) {
        let result = "{";
        let i = 0;
        while (i < len(inner)) {
            if (i > 0) {
                result = result + ",";
            }
            let pair = inner[i];
            result = result + "\"" + jsonEscapeString(pair[0]) + "\":";
            result = result + jsonStringify(pair[1]);
            i = i + 1;
        }
        return result + "}";
    }
    return "null";
}

// Escape string for JSON
fn jsonEscapeString(s) {
    let result = "";
    let i = 0;
    while (i < len(s)) {
        let c = s[i];
        if (c == "\"") {
            result = result + "\\\"";
        } else if (c == "\\") {
            result = result + "\\\\";
        } else if (c == "\n") {
            result = result + "\\n";
        } else if (c == "\r") {
            result = result + "\\r";
        } else if (c == "\t") {
            result = result + "\\t";
        } else {
            result = result + c;
        }
        i = i + 1;
    }
    return result;
}

// Pretty print JSON with indentation
fn jsonPretty(val, indent) {
    return jsonPrettyInner(val, indent, 0);
}

fn jsonPrettyInner(val, indent, level) {
    let typ = val[0];
    let inner = val[1];
    let prefix = "";
    let i = 0;
    while (i < level) {
        prefix = prefix + indent;
        i = i + 1;
    }
    let child_prefix = prefix + indent;
    
    if (typ == JSON_NULL) {
        return "null";
    }
    if (typ == JSON_BOOL) {
        if (inner) {
            return "true";
        }
        return "false";
    }
    if (typ == JSON_NUMBER) {
        return "" + inner;
    }
    if (typ == JSON_STRING) {
        return "\"" + jsonEscapeString(inner) + "\"";
    }
    if (typ == JSON_ARRAY) {
        if (len(inner) == 0) {
            return "[]";
        }
        let result = "[\n";
        i = 0;
        while (i < len(inner)) {
            if (i > 0) {
                result = result + ",\n";
            }
            result = result + child_prefix + jsonPrettyInner(inner[i], indent, level + 1);
            i = i + 1;
        }
        return result + "\n" + prefix + "]";
    }
    if (typ == JSON_OBJECT) {
        if (len(inner) == 0) {
            return "{}";
        }
        let result = "{\n";
        i = 0;
        while (i < len(inner)) {
            if (i > 0) {
                result = result + ",\n";
            }
            let pair = inner[i];
            result = result + child_prefix + "\"" + jsonEscapeString(pair[0]) + "\": ";
            result = result + jsonPrettyInner(pair[1], indent, level + 1);
            i = i + 1;
        }
        return result + "\n" + prefix + "}";
    }
    return "null";
}

// Parse JSON string (simplified parser)
// Returns [success, value, error_msg]
fn jsonParse(s) {
    let result = jsonParseValue(s, 0);
    return result;
}

fn jsonSkipWhitespace(s, pos) {
    let n = len(s);
    while (pos < n) {
        let c = s[pos];
        if (c == " ") {
            pos = pos + 1;
        } else if (c == "\n") {
            pos = pos + 1;
        } else if (c == "\r") {
            pos = pos + 1;
        } else if (c == "\t") {
            pos = pos + 1;
        } else {
            return pos;
        }
    }
    return pos;
}

fn jsonParseValue(s, pos) {
    pos = jsonSkipWhitespace(s, pos);
    let n = len(s);
    
    if (pos >= n) {
        return [false, null, pos, "Unexpected end of input"];
    }
    
    let c = s[pos];
    
    // null
    if (c == "n") {
        if (pos + 4 <= n) {
            if (s[pos + 1] == "u") {
                if (s[pos + 2] == "l") {
                    if (s[pos + 3] == "l") {
                        return [true, jsonNull(), pos + 4, ""];
                    }
                }
            }
        }
        return [false, null, pos, "Invalid null"];
    }
    
    // true
    if (c == "t") {
        if (pos + 4 <= n) {
            if (s[pos + 1] == "r") {
                if (s[pos + 2] == "u") {
                    if (s[pos + 3] == "e") {
                        return [true, jsonBool(true), pos + 4, ""];
                    }
                }
            }
        }
        return [false, null, pos, "Invalid true"];
    }
    
    // false
    if (c == "f") {
        if (pos + 5 <= n) {
            if (s[pos + 1] == "a") {
                if (s[pos + 2] == "l") {
                    if (s[pos + 3] == "s") {
                        if (s[pos + 4] == "e") {
                            return [true, jsonBool(false), pos + 5, ""];
                        }
                    }
                }
            }
        }
        return [false, null, pos, "Invalid false"];
    }
    
    // string
    if (c == "\"") {
        return jsonParseString(s, pos);
    }
    
    // array
    if (c == "[") {
        return jsonParseArray(s, pos);
    }
    
    // object
    if (c == "{") {
        return jsonParseObject(s, pos);
    }
    
    // number
    let code = charCodeAt(s, pos);
    if ((code >= 48) == (code <= 57)) {  // 0-9
        return jsonParseNumber(s, pos);
    }
    if (c == "-") {
        return jsonParseNumber(s, pos);
    }
    
    return [false, null, pos, "Unexpected character: " + c];
}

fn jsonParseString(s, pos) {
    let n = len(s);
    if (s[pos] != "\"") {
        return [false, null, pos, "Expected quote"];
    }
    pos = pos + 1;
    
    let result = "";
    while (pos < n) {
        let c = s[pos];
        if (c == "\"") {
            return [true, jsonString(result), pos + 1, ""];
        }
        if (c == "\\") {
            pos = pos + 1;
            if (pos >= n) {
                return [false, null, pos, "Unexpected end in escape"];
            }
            let esc = s[pos];
            if (esc == "n") {
                result = result + "\n";
            } else if (esc == "r") {
                result = result + "\r";
            } else if (esc == "t") {
                result = result + "\t";
            } else if (esc == "\"") {
                result = result + "\"";
            } else if (esc == "\\") {
                result = result + "\\";
            } else {
                result = result + esc;
            }
        } else {
            result = result + c;
        }
        pos = pos + 1;
    }
    return [false, null, pos, "Unterminated string"];
}

fn jsonParseNumber(s, pos) {
    let n = len(s);
    let start = pos;
    
    // Optional minus
    if (s[pos] == "-") {
        pos = pos + 1;
    }
    
    // Digits
    while (pos < n) {
        let code = charCodeAt(s, pos);
        if ((code >= 48) == (code <= 57)) {  // 0-9
            pos = pos + 1;
        } else {
            // Done with number
            let num_str = "";
            let i = start;
            while (i < pos) {
                num_str = num_str + s[i];
                i = i + 1;
            }
            let num = parseInt(num_str);
            return [true, jsonNumber(num), pos, ""];
        }
    }
    
    // Reached end
    let num_str = "";
    let i = start;
    while (i < pos) {
        num_str = num_str + s[i];
        i = i + 1;
    }
    let num = parseInt(num_str);
    return [true, jsonNumber(num), pos, ""];
}

fn jsonParseArray(s, pos) {
    let n = len(s);
    if (s[pos] != "[") {
        return [false, null, pos, "Expected ["];
    }
    pos = pos + 1;
    
    let items = [];
    pos = jsonSkipWhitespace(s, pos);
    
    // Empty array
    if (pos < n) {
        if (s[pos] == "]") {
            return [true, jsonArray(items), pos + 1, ""];
        }
    }
    
    // Parse items
    while (pos < n) {
        let result = jsonParseValue(s, pos);
        if (result[0] == false) {
            return result;
        }
        items = push(items, result[1]);
        pos = result[2];
        
        pos = jsonSkipWhitespace(s, pos);
        if (pos >= n) {
            return [false, null, pos, "Unexpected end of array"];
        }
        
        if (s[pos] == "]") {
            return [true, jsonArray(items), pos + 1, ""];
        }
        if (s[pos] == ",") {
            pos = pos + 1;
        } else {
            return [false, null, pos, "Expected , or ]"];
        }
    }
    return [false, null, pos, "Unterminated array"];
}

fn jsonParseObject(s, pos) {
    let n = len(s);
    if (s[pos] != "{") {
        return [false, null, pos, "Expected {"];
    }
    pos = pos + 1;
    
    let pairs = [];
    pos = jsonSkipWhitespace(s, pos);
    
    // Empty object
    if (pos < n) {
        if (s[pos] == "}") {
            return [true, jsonObject(pairs), pos + 1, ""];
        }
    }
    
    // Parse pairs
    while (pos < n) {
        // Parse key
        pos = jsonSkipWhitespace(s, pos);
        if (s[pos] != "\"") {
            return [false, null, pos, "Expected string key"];
        }
        let key_result = jsonParseString(s, pos);
        if (key_result[0] == false) {
            return key_result;
        }
        let key = key_result[1][1];  // Get string value
        pos = key_result[2];
        
        // Expect colon
        pos = jsonSkipWhitespace(s, pos);
        if (pos >= n) {
            return [false, null, pos, "Expected :"];
        }
        if (s[pos] != ":") {
            return [false, null, pos, "Expected :"];
        }
        pos = pos + 1;
        
        // Parse value
        let val_result = jsonParseValue(s, pos);
        if (val_result[0] == false) {
            return val_result;
        }
        let pair = [key, val_result[1]];
        pairs = push(pairs, pair);
        pos = val_result[2];
        
        pos = jsonSkipWhitespace(s, pos);
        if (pos >= n) {
            return [false, null, pos, "Unexpected end of object"];
        }
        
        if (s[pos] == "}") {
            return [true, jsonObject(pairs), pos + 1, ""];
        }
        if (s[pos] == ",") {
            pos = pos + 1;
        } else {
            return [false, null, pos, "Expected , or }"];
        }
    }
    return [false, null, pos, "Unterminated object"];
}
