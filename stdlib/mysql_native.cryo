// ============================================
// CRYO MYSQL CLIENT (Native Implementation)
// MySQL Wire Protocol with mysql_native_password
// ============================================

let MYSQL_VERSION = "1.1.0";

// Connection struct
struct MySqlConnection {
    socket: int,
    connected: bool,
    host: string,
    port: int,
    user: string,
    database: string,
    server_version: string,
    scramble: any  // Auth data from server
}

// Query result
struct MySqlResult {
    success: bool,
    rows: any,
    columns: any,
    affected: int,
    error: string
}

// ============================================
// BYTE UTILITIES
// ============================================

fn int32_to_bytes_le(n) {
    let bytes = [];
    push(bytes, n % 256);
    push(bytes, (n / 256) % 256);
    push(bytes, (n / 65536) % 256);
    push(bytes, (n / 16777216) % 256);
    return bytes;
}

fn int24_to_bytes_le(n) {
    let bytes = [];
    push(bytes, n % 256);
    push(bytes, (n / 256) % 256);
    push(bytes, (n / 65536) % 256);
    return bytes;
}

fn bytesToInt24Le(bytes, offset) {
    return bytes[offset] + bytes[offset + 1] * 256 + bytes[offset + 2] * 65536;
}

fn appendBytes(dest, src) {
    let i = 0;
    while (i < len(src)) {
        push(dest, src[i]);
        i = i + 1;
    }
}

fn appendString(dest, s) {
    let bytes = @stringToBytes(s);
    appendBytes(dest, bytes);
}

fn appendNullString(dest, s) {
    appendString(dest, s);
    push(dest, 0);
}

fn readNullString(bytes, offset) {
    let result = [];
    let i = offset;
    while (i < len(bytes) && bytes[i] != 0) {
        push(result, bytes[i]);
        i = i + 1;
    }
    return @bytesToString(result);
}

fn findNull(bytes, offset) {
    let i = offset;
    while (i < len(bytes) && bytes[i] != 0) {
        i = i + 1;
    }
    return i;
}

// ============================================
// mysql_native_password AUTH
// ============================================

fn computeAuthResponse(password, scramble) {
    // mysql_native_password algorithm:
    // SHA1(password) XOR SHA1(scramble + SHA1(SHA1(password)))
    
    if (password == "" || len(scramble) == 0) {
        return [];  // Empty password = empty auth response
    }
    
    // Step 1: SHA1(password)
    let pass_hash1 = @sha1_bytes(password);
    
    // Step 2: SHA1(SHA1(password))
    let pass_hash2 = @sha1_bytes(pass_hash1);
    
    // Step 3: Concatenate scramble + SHA1(SHA1(password))
    let combined = @concatBytes(scramble, pass_hash2);
    
    // Step 4: SHA1(scramble + SHA1(SHA1(password)))
    let scramble_hash = @sha1_bytes(combined);
    
    // Step 5: XOR SHA1(password) with step 4
    let auth_response = @xorBytes(pass_hash1, scramble_hash);
    
    return auth_response;
}

// ============================================
// CONNECTION
// ============================================

fn mysqlConnect(host, port, user, password, database) {
    print("[MySQL] Connecting to " + host + ":" + port + "...");
    
    let socket = @tcpConnect(host, port);
    if (socket < 0) {
        print("[MySQL] Failed to connect!");
        return null;
    }
    
    print("[MySQL] TCP connected, reading handshake...");
    
    let conn = MySqlConnection {
        socket: socket,
        connected: false,
        host: host,
        port: port,
        user: user,
        database: database,
        server_version: "",
        scramble: []
    };
    
    // Read initial handshake packet
    if (!readHandshake(conn)) {
        print("[MySQL] Failed to read handshake");
        @cryoSocketClose(socket);
        return null;
    }
    
    // Send authentication response
    if (!sendAuthResponse(conn, user, password, database)) {
        print("[MySQL] Authentication failed");
        @cryoSocketClose(socket);
        return null;
    }
    
    conn.connected = true;
    print("[MySQL] Connected successfully to " + conn.server_version);
    
    return conn;
}

fn readHandshake(conn) {
    // Read packet header: 3 bytes length + 1 byte sequence
    let header = @tcpReadRaw(conn.socket, 4);
    if (len(header) < 4) {
        print("[MySQL] Failed to read packet header");
        return false;
    }
    
    let packet_len = bytesToInt24Le(header, 0);
    
    // Read packet body
    let body = @tcpReadRaw(conn.socket, packet_len);
    if (len(body) < packet_len) {
        print("[MySQL] Failed to read handshake packet");
        return false;
    }
    
    // Parse handshake v10
    let protocol_version = body[0];
    if (protocol_version != 10) {
        print("[MySQL] Unsupported protocol version: " + protocol_version);
        return false;
    }
    
    // Find end of server version string
    let ver_end = findNull(body, 1);
    conn.server_version = readNullString(body, 1);
    print("[MySQL] Server version: " + conn.server_version);
    
    // Parse rest of handshake
    // After null-terminated version: 4 bytes conn_id + 8 bytes scramble1 + 1 filler
    let pos = ver_end + 1;
    // Skip connection id (4 bytes)
    pos = pos + 4;
    
    // Read first 8 bytes of scramble
    let scramble1 = [];
    let i = 0;
    while (i < 8 && pos + i < len(body)) {
        push(scramble1, body[pos + i]);
        i = i + 1;
    }
    pos = pos + 8;
    
    // Skip filler (1 byte)
    pos = pos + 1;
    
    // Skip capability flags lower (2 bytes)
    pos = pos + 2;
    
    // Skip character set (1 byte)
    pos = pos + 1;
    
    // Skip status flags (2 bytes)
    pos = pos + 2;
    
    // Skip capability flags upper (2 bytes)
    pos = pos + 2;
    
    // Skip authPluginDataLen(1 byte)
    let auth_len = body[pos];
    pos = pos + 1;
    
    // Skip reserved (10 bytes)
    pos = pos + 10;
    
    // Read rest of scramble (12 bytes for mysql_native_password)
    let scramble2 = [];
    i = 0;
    while (i < 12 && pos + i < len(body)) {
        push(scramble2, body[pos + i]);
        i = i + 1;
    }
    
    // Combine scramble1 + scramble2 (20 bytes total)
    conn.scramble = [];
    appendBytes(conn.scramble, scramble1);
    appendBytes(conn.scramble, scramble2);
    
    print("[MySQL] Scramble length: " + len(conn.scramble));
    
    return true;
}

fn sendAuthResponse(conn, user, password, database) {
    // Compute authentication hash
    let auth_data = computeAuthResponse(password, conn.scramble);
    print("[MySQL] Auth data length: " + len(auth_data));
    
    let packet = [];
    
    // Client capabilities (decimal = 0x000A0285)
    // CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION | CLIENT_CONNECT_WITH_DB | CLIENT_PLUGIN_AUTH
    let caps = 656005;  // 0x000A0285 in decimal
    appendBytes(packet, int32_to_bytes_le(caps));
    
    // Max packet size
    appendBytes(packet, int32_to_bytes_le(16777215));
    
    // Character set (utf8mb4 = 45)
    push(packet, 45);
    
    // Reserved 23 bytes
    let i = 0;
    while (i < 23) {
        push(packet, 0);
        i = i + 1;
    }
    
    // Username (null-terminated)
    appendNullString(packet, user);
    
    // Auth response (length-encoded)
    push(packet, len(auth_data));
    appendBytes(packet, auth_data);
    
    // Database (null-terminated)
    appendNullString(packet, database);
    
    // Auth plugin name (null-terminated)
    appendNullString(packet, "mysql_native_password");
    
    // Build final packet with header
    let final_packet = [];
    appendBytes(final_packet, int24_to_bytes_le(len(packet)));
    push(final_packet, 1);  // Sequence number
    appendBytes(final_packet, packet);
    
    // Send packet
    @tcpWriteRaw(conn.socket, final_packet);
    
    // Read response
    let resp_header = @tcpReadRaw(conn.socket, 4);
    if (len(resp_header) < 4) {
        print("[MySQL] No auth response");
        return false;
    }
    
    let resp_len = bytesToInt24Le(resp_header, 0);
    let resp_body = @tcpReadRaw(conn.socket, resp_len);
    
    if (len(resp_body) > 0) {
        let status = resp_body[0];
        if (status == 0) {
            print("[MySQL] Authentication OK");
            return true;
        } else if (status == 255) {
            // Error packet - try to read error message
            let err_msg = "";
            if (len(resp_body) > 9) {
                err_msg = readNullString(resp_body, 9);
            }
            print("[MySQL] Auth error: " + err_msg);
            return false;
        } else if (status == 254) {
            print("[MySQL] Auth switch requested");
            // Handle auth switch - resend with new plugin
            return handleAuthSwitch(conn, password, resp_body);
        }
    }
    
    return false;
}

fn handleAuthSwitch(conn, password, switch_packet) {
    // Auth switch packet format: 0xFE + pluginName(null) + scramble
    let pos = 1;
    let plugin_end = findNull(switch_packet, pos);
    let plugin_name = readNullString(switch_packet, pos);
    print("[MySQL] Switching to plugin: " + plugin_name);
    
    pos = plugin_end + 1;
    
    // Read new scramble
    let new_scramble = [];
    while (pos < len(switch_packet) && switch_packet[pos] != 0) {
        push(new_scramble, switch_packet[pos]);
        pos = pos + 1;
    }
    
    print("[MySQL] New scramble length: " + len(new_scramble));
    
    // Compute auth with new scramble
    let auth_data = computeAuthResponse(password, new_scramble);
    
    // Send auth response
    let packet = [];
    appendBytes(packet, auth_data);
    
    let final_packet = [];
    appendBytes(final_packet, int24_to_bytes_le(len(packet)));
    push(final_packet, 3);  // Sequence 3
    appendBytes(final_packet, packet);
    
    @tcpWriteRaw(conn.socket, final_packet);
    
    // Read final response
    let resp_header = @tcpReadRaw(conn.socket, 4);
    if (len(resp_header) < 4) {
        return false;
    }
    
    let resp_len = bytesToInt24Le(resp_header, 0);
    let resp_body = @tcpReadRaw(conn.socket, resp_len);
    
    if (len(resp_body) > 0 && resp_body[0] == 0) {
        print("[MySQL] Authentication OK (after switch)");
        return true;
    }
    
    if (len(resp_body) > 9) {
        print("[MySQL] Final auth error: " + readNullString(resp_body, 9));
    }
    
    return false;
}

// ============================================
// QUERY EXECUTION
// ============================================

fn mysqlQuery(conn, sql) {
    if (!conn.connected) {
        return MySqlResult { success: false, rows: [], columns: [], affected: 0, error: "Not connected" };
    }
    
    print("[MySQL] Executing: " + sql);
    
    // Build COM_QUERY packet
    let packet = [];
    push(packet, 3);  // COM_QUERY command
    appendString(packet, sql);
    
    // Add header
    let final_packet = [];
    appendBytes(final_packet, int24_to_bytes_le(len(packet)));
    push(final_packet, 0);  // Sequence 0
    appendBytes(final_packet, packet);
    
    // Send
    @tcpWriteRaw(conn.socket, final_packet);
    
    // Read response
    let result = MySqlResult {
        success: false,
        rows: [],
        columns: [],
        affected: 0,
        error: ""
    };
    
    let resp_header = @tcpReadRaw(conn.socket, 4);
    if (len(resp_header) < 4) {
        result.error = "No response";
        return result;
    }
    
    let resp_len = bytesToInt24Le(resp_header, 0);
    let resp_body = @tcpReadRaw(conn.socket, resp_len);
    
    if (len(resp_body) > 0) {
        let status = resp_body[0];
        if (status == 0) {
            // OK packet
            result.success = true;
            if (len(resp_body) > 1) {
                result.affected = resp_body[1];
            }
            print("[MySQL] OK: " + result.affected + " rows affected");
        } else if (status == 255) {
            // Error packet
            result.error = "Query error";
            if (len(resp_body) > 9) {
                result.error = readNullString(resp_body, 9);
            }
            print("[MySQL] Error: " + result.error);
        } else {
            // Result set
            let num_cols = status;
            result.columns = num_cols;
            print("[MySQL] Result set with " + num_cols + " columns");
            result.success = true;
        }
    }
    
    return result;
}

// ============================================
// DISCONNECT
// ============================================

fn mysqlClose(conn) {
    if (conn.connected) {
        // Send COM_QUIT
        let packet = [];
        push(packet, 1);  // COM_QUIT
        
        let final_packet = [];
        appendBytes(final_packet, int24_to_bytes_le(1));
        push(final_packet, 0);
        appendBytes(final_packet, packet);
        
        @tcpWriteRaw(conn.socket, final_packet);
        @cryoSocketClose(conn.socket);
        conn.connected = false;
        print("[MySQL] Connection closed");
    }
}

fn mysqlExec(conn, sql) {
    let result = mysqlQuery(conn, sql);
    return result.success;
}
