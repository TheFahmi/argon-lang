// ============================================
// ARGON STANDARD LIBRARY: WEBSOCKET (v3.1.0)
// WebSocket Server & Client Implementation
// ============================================

let WS_VERSION = "3.1.0";

// ============================================
// WebSocket Constants
// ============================================

// Opcodes
let WS_OPCODE_CONTINUATION = 0;
let WS_OPCODE_TEXT = 1;
let WS_OPCODE_BINARY = 2;
let WS_OPCODE_CLOSE = 8;
let WS_OPCODE_PING = 9;
let WS_OPCODE_PONG = 10;

// Close codes
let WS_CLOSE_NORMAL = 1000;
let WS_CLOSE_GOING_AWAY = 1001;
let WS_CLOSE_PROTOCOL_ERROR = 1002;
let WS_CLOSE_UNSUPPORTED = 1003;
let WS_CLOSE_ABNORMAL = 1006;
let WS_CLOSE_INVALID_DATA = 1007;
let WS_CLOSE_POLICY_VIOLATION = 1008;
let WS_CLOSE_MESSAGE_TOO_BIG = 1009;
let WS_CLOSE_EXTENSION_REQUIRED = 1010;
let WS_CLOSE_INTERNAL_ERROR = 1011;

// Ready states
let WS_CONNECTING = 0;
let WS_OPEN = 1;
let WS_CLOSING = 2;
let WS_CLOSED = 3;

// ============================================
// WebSocket Message Struct
// ============================================

struct WebSocketMessage {
    opcode: int,
    data: string,
    isBinary: bool,
    isFinal: bool
}

fn createTextMessage(data: string) -> WebSocketMessage {
    return WebSocketMessage {
        opcode: WS_OPCODE_TEXT,
        data: data,
        isBinary: false,
        isFinal: true
    };
}

fn createBinaryMessage(data: string) -> WebSocketMessage {
    return WebSocketMessage {
        opcode: WS_OPCODE_BINARY,
        data: data,
        isBinary: true,
        isFinal: true
    };
}

fn createCloseMessage(code: int, reason: string) -> WebSocketMessage {
    return WebSocketMessage {
        opcode: WS_OPCODE_CLOSE,
        data: reason,
        isBinary: false,
        isFinal: true
    };
}

fn createPingMessage() -> WebSocketMessage {
    return WebSocketMessage {
        opcode: WS_OPCODE_PING,
        data: "",
        isBinary: false,
        isFinal: true
    };
}

fn createPongMessage() -> WebSocketMessage {
    return WebSocketMessage {
        opcode: WS_OPCODE_PONG,
        data: "",
        isBinary: false,
        isFinal: true
    };
}

// ============================================
// WebSocket Connection Struct
// ============================================

struct WebSocketConnection {
    id: int,
    socketId: int,
    readyState: int,
    protocol: string,
    extensions: string,
    onMessage: any,
    onClose: any,
    onError: any
}

fn createConnection(socketId: int) -> WebSocketConnection {
    return WebSocketConnection {
        id: socketId,
        socketId: socketId,
        readyState: WS_OPEN,
        protocol: "",
        extensions: "",
        onMessage: null,
        onClose: null,
        onError: null
    };
}

impl WebSocketConnection {
    fn send(self, message: string) -> bool {
        if (self.readyState != WS_OPEN) {
            return false;
        }
        let frame = encodeFrame(createTextMessage(message));
        argonSocketWrite(self.socketId, frame);
        return true;
    }
    
    fn sendBinary(self, data: string) -> bool {
        if (self.readyState != WS_OPEN) {
            return false;
        }
        let frame = encodeFrame(createBinaryMessage(data));
        argonSocketWrite(self.socketId, frame);
        return true;
    }
    
    fn ping(self) {
        if (self.readyState == WS_OPEN) {
            let frame = encodeFrame(createPingMessage());
            argonSocketWrite(self.socketId, frame);
        }
    }
    
    fn close(self, code: int, reason: string) {
        if (self.readyState == WS_OPEN) {
            self.readyState = WS_CLOSING;
            let frame = encodeFrame(createCloseMessage(code, reason));
            argonSocketWrite(self.socketId, frame);
            self.readyState = WS_CLOSED;
        }
    }
    
    fn isOpen(self) -> bool {
        return self.readyState == WS_OPEN;
    }
}

// ============================================
// WebSocket Server
// ============================================

struct WebSocketServer {
    port: int,
    connections: [WebSocketConnection],
    nextConnId: int,
    onConnection: any,
    onMessage: any,
    onClose: any,
    onError: any
}

impl WebSocketServer {
    fn new(port: int) -> WebSocketServer {
        return WebSocketServer {
            port: port,
            connections: [],
            nextConnId: 1,
            onConnection: null,
            onMessage: null,
            onClose: null,
            onError: null
        };
    }
    
    fn broadcast(self, message: string) {
        let i = 0;
        while (i < len(self.connections)) {
            let conn = self.connections[i];
            if (conn.isOpen()) {
                conn.send(message);
            }
            i = i + 1;
        }
    }
    
    fn broadcastExcept(self, message: string, excludeId: int) {
        let i = 0;
        while (i < len(self.connections)) {
            let conn = self.connections[i];
            if (conn.isOpen() && conn.id != excludeId) {
                conn.send(message);
            }
            i = i + 1;
        }
    }
    
    fn getConnection(self, id: int) -> WebSocketConnection {
        let i = 0;
        while (i < len(self.connections)) {
            if (self.connections[i].id == id) {
                return self.connections[i];
            }
            i = i + 1;
        }
        return null;
    }
    
    fn connectionCount(self) -> int {
        let count = 0;
        let i = 0;
        while (i < len(self.connections)) {
            if (self.connections[i].isOpen()) {
                count = count + 1;
            }
            i = i + 1;
        }
        return count;
    }
    
    fn start(self) {
        print("");
        print("  WebSocket Server v" + WS_VERSION);
        print("  Listening on ws://localhost:" + self.port);
        print("");
        
        let listener = argonListen(self.port);
        
        if (listener < 0) {
            print("FATAL: Failed to bind to port " + self.port);
            return;
        }
        
        while (true) {
            let client = argonAccept(listener);
            
            if (client >= 0) {
                let reqStr = argonSocketRead(client);
                
                if (len(reqStr) > 0) {
                    // Check if WebSocket upgrade request
                    if (isUpgradeRequest(reqStr)) {
                        // Perform handshake
                        let response = performHandshake(reqStr);
                        argonSocketWrite(client, response);
                        
                        // Create connection
                        let conn = createConnection(client);
                        conn.id = self.nextConnId;
                        self.nextConnId = self.nextConnId + 1;
                        push(self.connections, conn);
                        
                        print("[WS] Client connected: " + conn.id);
                        
                        // Callback
                        if (self.onConnection != null) {
                            self.onConnection(conn);
                        }
                        
                        // Handle messages in loop
                        self.handleConnection(conn);
                    } else {
                        // Regular HTTP request - send upgrade required
                        let httpResp = "HTTP/1.1 426 Upgrade Required\r\n";
                        httpResp = httpResp + "Upgrade: websocket\r\n";
                        httpResp = httpResp + "Connection: Upgrade\r\n\r\n";
                        argonSocketWrite(client, httpResp);
                        argonSocketClose(client);
                    }
                }
            }
        }
    }
    
    fn handleConnection(self, conn: WebSocketConnection) {
        while (conn.isOpen()) {
            let data = argonSocketRead(conn.socketId);
            
            if (len(data) == 0) {
                // Connection closed
                conn.readyState = WS_CLOSED;
                print("[WS] Client disconnected: " + conn.id);
                
                if (self.onClose != null) {
                    self.onClose(conn);
                }
                break;
            }
            
            // Decode frame
            let msg = decodeFrame(data);
            
            if (msg.opcode == WS_OPCODE_TEXT || msg.opcode == WS_OPCODE_BINARY) {
                if (self.onMessage != null) {
                    self.onMessage(conn, msg.data);
                }
            } else if (msg.opcode == WS_OPCODE_PING) {
                // Respond with pong
                conn.send(msg.data);  // Echo data back
            } else if (msg.opcode == WS_OPCODE_CLOSE) {
                // Close connection
                conn.close(WS_CLOSE_NORMAL, "");
                print("[WS] Client closed: " + conn.id);
                
                if (self.onClose != null) {
                    self.onClose(conn);
                }
            }
        }
    }
}

// ============================================
// WebSocket Handshake
// ============================================

let WS_MAGIC_STRING = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

fn isUpgradeRequest(request: string) -> bool {
    return contains(request, "Upgrade: websocket") || 
           contains(request, "upgrade: websocket");
}

fn extractWebSocketKey(request: string) -> string {
    // Find Sec-WebSocket-Key header
    let lines = split(request, "\r\n");
    let i = 0;
    while (i < len(lines)) {
        let line = lines[i];
        if (startsWith(line, "Sec-WebSocket-Key:")) {
            return trim(substr(line, 18, len(line) - 18));
        }
        if (startsWith(line, "sec-websocket-key:")) {
            return trim(substr(line, 18, len(line) - 18));
        }
        i = i + 1;
    }
    return "";
}

fn performHandshake(request: string) -> string {
    let key = extractWebSocketKey(request);
    
    // Generate accept key: base64(SHA1(key + magic))
    // Simplified: use built-in sha1 + base64
    let acceptKey = generateAcceptKey(key);
    
    let response = "HTTP/1.1 101 Switching Protocols\r\n";
    response = response + "Upgrade: websocket\r\n";
    response = response + "Connection: Upgrade\r\n";
    response = response + "Sec-WebSocket-Accept: " + acceptKey + "\r\n";
    response = response + "\r\n";
    
    return response;
}

fn generateAcceptKey(key: string) -> string {
    // Concatenate key with magic string
    let combined = key + WS_MAGIC_STRING;
    
    // SHA1 hash (simplified - using built-in if available)
    let hash = sha1Hash(combined);
    
    // Base64 encode
    return base64Encode(hash);
}

// Simple SHA1 implementation for WebSocket
fn sha1Hash(input: string) -> string {
    // Use built-in sha1 if available, otherwise return placeholder
    // This is simplified - real implementation needs crypto
    let h = 0;
    let i = 0;
    while (i < len(input)) {
        h = (h * 31 + charCodeAt(input, i)) % 2147483647;
        i = i + 1;
    }
    return toString(h);
}

fn base64Encode(input: string) -> string {
    let chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let result = "";
    let i = 0;
    while (i < len(input)) {
        let a = charCodeAt(input, i);
        let b = 0;
        let c = 0;
        if (i + 1 < len(input)) { b = charCodeAt(input, i + 1); }
        if (i + 2 < len(input)) { c = charCodeAt(input, i + 2); }
        
        result = result + charAt(chars, (a >> 2) % 64);
        result = result + charAt(chars, ((a & 3) << 4 | b >> 4) % 64);
        if (i + 1 < len(input)) {
            result = result + charAt(chars, ((b & 15) << 2 | c >> 6) % 64);
        } else {
            result = result + "=";
        }
        if (i + 2 < len(input)) {
            result = result + charAt(chars, c & 63);
        } else {
            result = result + "=";
        }
        i = i + 3;
    }
    return result;
}

fn charCodeAt(s: string, i: int) -> int {
    let c = charAt(s, i);
    // Return ASCII code
    return ord(c);
}

fn ord(c: string) -> int {
    // Simplified ord - return first char code
    if (len(c) == 0) { return 0; }
    // Built-in would be better
    return 0;
}

// ============================================
// Frame Encoding/Decoding
// ============================================

fn encodeFrame(msg: WebSocketMessage) -> string {
    let data = msg.data;
    let len_data = len(data);
    
    // Build frame
    let frame = "";
    
    // First byte: FIN + opcode
    let firstByte = 128 + msg.opcode;  // FIN = 1
    frame = frame + chr(firstByte);
    
    // Second byte: MASK (0 for server) + length
    if (len_data < 126) {
        frame = frame + chr(len_data);
    } else if (len_data < 65536) {
        frame = frame + chr(126);
        frame = frame + chr((len_data >> 8) % 256);
        frame = frame + chr(len_data % 256);
    } else {
        frame = frame + chr(127);
        // 64-bit length (simplified)
        let i = 0;
        while (i < 8) {
            frame = frame + chr(0);
            i = i + 1;
        }
    }
    
    // Payload (no mask for server -> client)
    frame = frame + data;
    
    return frame;
}

fn decodeFrame(data: string) -> WebSocketMessage {
    if (len(data) < 2) {
        return createTextMessage("");
    }
    
    // First byte
    let firstByte = charCodeAt(data, 0);
    let fin = (firstByte >> 7) & 1;
    let opcode = firstByte & 15;
    
    // Second byte
    let secondByte = charCodeAt(data, 1);
    let masked = (secondByte >> 7) & 1;
    let payloadLen = secondByte & 127;
    
    let offset = 2;
    
    // Extended length
    if (payloadLen == 126) {
        payloadLen = charCodeAt(data, 2) * 256 + charCodeAt(data, 3);
        offset = 4;
    } else if (payloadLen == 127) {
        // 64-bit length (simplified - read lower 32 bits)
        payloadLen = 0;
        offset = 10;
    }
    
    // Masking key (if masked)
    let maskKey = [];
    if (masked == 1) {
        push(maskKey, charCodeAt(data, offset));
        push(maskKey, charCodeAt(data, offset + 1));
        push(maskKey, charCodeAt(data, offset + 2));
        push(maskKey, charCodeAt(data, offset + 3));
        offset = offset + 4;
    }
    
    // Extract payload
    let payload = "";
    let i = 0;
    while (i < payloadLen && (offset + i) < len(data)) {
        let byte = charCodeAt(data, offset + i);
        if (masked == 1) {
            byte = byte ^ maskKey[i % 4];
        }
        payload = payload + chr(byte);
        i = i + 1;
    }
    
    return WebSocketMessage {
        opcode: opcode,
        data: payload,
        isBinary: opcode == WS_OPCODE_BINARY,
        isFinal: fin == 1
    };
}

fn chr(code: int) -> string {
    // Convert ASCII code to character
    // Built-in would be better
    let chars = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    if (code >= 32 && code <= 126) {
        return charAt(chars, code - 32);
    }
    return "?";
}

// ============================================
// WebSocket Client (for connecting to servers)
// ============================================

struct WebSocketClient {
    url: string,
    socketId: int,
    readyState: int,
    onOpen: any,
    onMessage: any,
    onClose: any,
    onError: any
}

impl WebSocketClient {
    fn new(url: string) -> WebSocketClient {
        return WebSocketClient {
            url: url,
            socketId: -1,
            readyState: WS_CONNECTING,
            onOpen: null,
            onMessage: null,
            onClose: null,
            onError: null
        };
    }
    
    fn connect(self) -> bool {
        // Parse URL (ws://host:port/path)
        // Simplified - would need proper URL parsing
        self.readyState = WS_CONNECTING;
        
        // TODO: Implement TCP client connection
        // For now, WebSocket client requires native support
        
        return false;
    }
    
    fn send(self, message: string) -> bool {
        if (self.readyState != WS_OPEN) {
            return false;
        }
        let frame = encodeFrame(createTextMessage(message));
        // Add mask for client -> server
        argonSocketWrite(self.socketId, frame);
        return true;
    }
    
    fn close(self) {
        if (self.readyState == WS_OPEN) {
            self.readyState = WS_CLOSING;
            let frame = encodeFrame(createCloseMessage(WS_CLOSE_NORMAL, ""));
            argonSocketWrite(self.socketId, frame);
            self.readyState = WS_CLOSED;
        }
    }
}

// ============================================
// Helper Functions
// ============================================

fn wsLog(message: string) {
    print("[WS] " + message);
}

fn toString(n: int) -> string {
    return "" + n;
}
