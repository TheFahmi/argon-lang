// ============================================
// ARGON STANDARD LIBRARY: TEMPLATE (v3.1.0)
// Template Engine (EJS/Handlebars-style)
// ============================================
//
// Features:
// - Variable interpolation: {{ name }}
// - Conditionals: {% if condition %} ... {% endif %}
// - Loops: {% for item in items %} ... {% endfor %}
// - Includes: {% include "partial" %}
// - Filters: {{ name | upper }}
// - Comments: {# This is a comment #}
// - Raw blocks: {% raw %} ... {% endraw %}
// - Layouts: {% extends "base" %} {% block content %}
//
// ============================================

let TEMPLATE_VERSION = "3.1.0";

// ============================================
// Template Context
// ============================================

struct TemplateContext {
    data: any,
    partials: any,
    filters: any,
    layouts: any
}

fn createContext() -> TemplateContext {
    return TemplateContext {
        data: {},
        partials: {},
        filters: {},
        layouts: {}
    };
}

fn createContextWithData(data: any) -> TemplateContext {
    return TemplateContext {
        data: data,
        partials: {},
        filters: {},
        layouts: {}
    };
}

impl TemplateContext {
    fn set(self, key: string, value: any) {
        self.data[key] = value;
    }
    
    fn get(self, key: string) -> any {
        return self.data[key];
    }
    
    fn registerPartial(self, name: string, template: string) {
        self.partials[name] = template;
    }
    
    fn registerFilter(self, name: string, fn: any) {
        self.filters[name] = fn;
    }
    
    fn registerLayout(self, name: string, template: string) {
        self.layouts[name] = template;
    }
}

// ============================================
// Template Engine
// ============================================

struct TemplateEngine {
    templateDir: string,
    cache: any,
    cacheEnabled: bool,
    defaultExtension: string
}

fn createEngine() -> TemplateEngine {
    return TemplateEngine {
        templateDir: "templates",
        cache: {},
        cacheEnabled: true,
        defaultExtension: ".html"
    };
}

fn createEngineWithDir(dir: string) -> TemplateEngine {
    return TemplateEngine {
        templateDir: dir,
        cache: {},
        cacheEnabled: true,
        defaultExtension: ".html"
    };
}

impl TemplateEngine {
    fn setTemplateDir(self, dir: string) {
        self.templateDir = dir;
    }
    
    fn enableCache(self, enabled: bool) {
        self.cacheEnabled = enabled;
    }
    
    fn render(self, templateName: string, ctx: TemplateContext) -> string {
        let template = self.loadTemplate(templateName);
        return renderTemplate(template, ctx);
    }
    
    fn renderString(self, template: string, ctx: TemplateContext) -> string {
        return renderTemplate(template, ctx);
    }
    
    fn loadTemplate(self, name: string) -> string {
        // Check cache
        if (self.cacheEnabled && self.cache[name] != null) {
            return self.cache[name];
        }
        
        // Load from file
        let path = self.templateDir + "/" + name + self.defaultExtension;
        let content = readFile(path);
        
        if (content == null || len(content) == 0) {
            // Try without extension
            path = self.templateDir + "/" + name;
            content = readFile(path);
        }
        
        if (self.cacheEnabled) {
            self.cache[name] = content;
        }
        
        return content;
    }
    
    fn clearCache(self) {
        self.cache = {};
    }
}

// ============================================
// Main Render Function
// ============================================

fn renderTemplate(template: string, ctx: TemplateContext) -> string {
    if (template == null || len(template) == 0) {
        return "";
    }
    
    let result = template;
    
    // 1. Strip comments {# ... #}
    result = stripComments(result);
    
    // 2. Process extends/layouts
    result = processExtends(result, ctx);
    
    // 3. Process includes
    result = processIncludes(result, ctx);
    
    // 4. Process for loops
    result = processForLoops(result, ctx);
    
    // 5. Process conditionals
    result = processConditionals(result, ctx);
    
    // 6. Process variables with filters
    result = processVariables(result, ctx);
    
    return result;
}

// ============================================
// Comment Processing
// ============================================

fn stripComments(template: string) -> string {
    let result = "";
    let i = 0;
    let len_t = len(template);
    
    while (i < len_t) {
        // Check for comment start {#
        if (i + 1 < len_t && charAt(template, i) == "{" && charAt(template, i + 1) == "#") {
            // Find comment end #}
            let j = i + 2;
            while (j + 1 < len_t) {
                if (charAt(template, j) == "#" && charAt(template, j + 1) == "}") {
                    i = j + 2;
                    break;
                }
                j = j + 1;
            }
            if (j + 1 >= len_t) {
                i = len_t;
            }
        } else {
            result = result + charAt(template, i);
            i = i + 1;
        }
    }
    
    return result;
}

// ============================================
// Variable Processing
// ============================================

fn processVariables(template: string, ctx: TemplateContext) -> string {
    let result = "";
    let i = 0;
    let len_t = len(template);
    
    while (i < len_t) {
        // Check for {{ 
        if (i + 1 < len_t && charAt(template, i) == "{" && charAt(template, i + 1) == "{") {
            // Find }}
            let j = i + 2;
            while (j + 1 < len_t) {
                if (charAt(template, j) == "}" && charAt(template, j + 1) == "}") {
                    break;
                }
                j = j + 1;
            }
            
            // Extract expression
            let expr = trim(substr(template, i + 2, j - i - 2));
            
            // Evaluate expression
            let value = evaluateExpression(expr, ctx);
            result = result + value;
            
            i = j + 2;
        } else {
            result = result + charAt(template, i);
            i = i + 1;
        }
    }
    
    return result;
}

fn evaluateExpression(expr: string, ctx: TemplateContext) -> string {
    // Check for filter: name | filter
    let filterIdx = indexOf(expr, "|");
    if (filterIdx > 0) {
        let varPart = trim(substr(expr, 0, filterIdx));
        let filterPart = trim(substr(expr, filterIdx + 1, len(expr) - filterIdx - 1));
        
        let value = getVariable(varPart, ctx);
        return applyFilter(value, filterPart, ctx);
    }
    
    return getVariable(expr, ctx);
}

fn getVariable(name: string, ctx: TemplateContext) -> string {
    // Handle dot notation: user.name
    let parts = split(name, ".");
    let value = ctx.data;
    
    let i = 0;
    while (i < len(parts)) {
        let part = trim(parts[i]);
        if (value == null) {
            return "";
        }
        value = value[part];
        i = i + 1;
    }
    
    if (value == null) {
        return "";
    }
    
    return "" + value;
}

fn applyFilter(value: string, filterName: string, ctx: TemplateContext) -> string {
    // Check for filter arguments: filter(arg)
    let argIdx = indexOf(filterName, "(");
    let args = "";
    if (argIdx > 0) {
        args = substr(filterName, argIdx + 1, len(filterName) - argIdx - 2);
        filterName = substr(filterName, 0, argIdx);
    }
    
    // Built-in filters
    if (filterName == "upper" || filterName == "uppercase") {
        return toUpperCase(value);
    }
    if (filterName == "lower" || filterName == "lowercase") {
        return toLowerCase(value);
    }
    if (filterName == "capitalize") {
        return capitalize(value);
    }
    if (filterName == "trim") {
        return trim(value);
    }
    if (filterName == "length" || filterName == "len") {
        return "" + len(value);
    }
    if (filterName == "reverse") {
        return reverseString(value);
    }
    if (filterName == "default") {
        if (len(value) == 0) {
            return args;
        }
        return value;
    }
    if (filterName == "truncate") {
        let maxLen = parseInt(args);
        if (len(value) > maxLen) {
            return substr(value, 0, maxLen) + "...";
        }
        return value;
    }
    if (filterName == "escape" || filterName == "e") {
        return escapeHtml(value);
    }
    if (filterName == "json") {
        return value;  // Already string
    }
    if (filterName == "nl2br") {
        return replace(value, "\n", "<br>");
    }
    if (filterName == "urlencode") {
        return urlEncode(value);
    }
    
    // Custom filter
    let customFilter = ctx.filters[filterName];
    if (customFilter != null) {
        return customFilter(value, args);
    }
    
    return value;
}

// ============================================
// Conditional Processing
// ============================================

fn processConditionals(template: string, ctx: TemplateContext) -> string {
    let result = template;
    
    // Process {% if ... %} ... {% endif %}
    let maxIterations = 100;
    let iterations = 0;
    
    while (contains(result, "{% if") && iterations < maxIterations) {
        let ifStart = indexOf(result, "{% if");
        if (ifStart < 0) { break; }
        
        // Find the condition end %}
        let condEnd = indexOf(substr(result, ifStart, len(result) - ifStart), "%}");
        if (condEnd < 0) { break; }
        condEnd = ifStart + condEnd;
        
        // Extract condition
        let condExpr = trim(substr(result, ifStart + 5, condEnd - ifStart - 5));
        
        // Find {% endif %}
        let endifPos = findMatchingEndif(result, condEnd + 2);
        if (endifPos < 0) { break; }
        
        // Find optional {% else %}
        let elsePos = findElseInRange(result, condEnd + 2, endifPos);
        
        // Evaluate condition
        let condResult = evaluateCondition(condExpr, ctx);
        
        let beforeIf = substr(result, 0, ifStart);
        let afterEndif = substr(result, endifPos + 10, len(result) - endifPos - 10);
        
        if (condResult) {
            // Use if block
            let ifContent = "";
            if (elsePos > 0) {
                ifContent = substr(result, condEnd + 2, elsePos - condEnd - 2);
            } else {
                ifContent = substr(result, condEnd + 2, endifPos - condEnd - 2);
            }
            result = beforeIf + ifContent + afterEndif;
        } else {
            // Use else block (if exists)
            if (elsePos > 0) {
                let elseContent = substr(result, elsePos + 9, endifPos - elsePos - 9);
                result = beforeIf + elseContent + afterEndif;
            } else {
                result = beforeIf + afterEndif;
            }
        }
        
        iterations = iterations + 1;
    }
    
    return result;
}

fn findMatchingEndif(template: string, startPos: int) -> int {
    let depth = 1;
    let i = startPos;
    
    while (i < len(template) && depth > 0) {
        let rest = substr(template, i, len(template) - i);
        
        if (startsWith(rest, "{% if")) {
            depth = depth + 1;
            i = i + 5;
        } else if (startsWith(rest, "{% endif")) {
            depth = depth - 1;
            if (depth == 0) {
                return i;
            }
            i = i + 8;
        } else {
            i = i + 1;
        }
    }
    
    return -1;
}

fn findElseInRange(template: string, startPos: int, endPos: int) -> int {
    let depth = 0;
    let i = startPos;
    
    while (i < endPos) {
        let rest = substr(template, i, len(template) - i);
        
        if (startsWith(rest, "{% if")) {
            depth = depth + 1;
            i = i + 5;
        } else if (startsWith(rest, "{% endif")) {
            depth = depth - 1;
            i = i + 8;
        } else if (startsWith(rest, "{% else") && depth == 0) {
            return i;
        } else {
            i = i + 1;
        }
    }
    
    return -1;
}

fn evaluateCondition(expr: string, ctx: TemplateContext) -> bool {
    // Handle comparison operators
    if (contains(expr, "==")) {
        let parts = split(expr, "==");
        let left = trim(parts[0]);
        let right = trim(parts[1]);
        return getVariable(left, ctx) == trimQuotes(right);
    }
    if (contains(expr, "!=")) {
        let parts = split(expr, "!=");
        let left = trim(parts[0]);
        let right = trim(parts[1]);
        return getVariable(left, ctx) != trimQuotes(right);
    }
    if (contains(expr, ">=")) {
        let parts = split(expr, ">=");
        let left = parseInt(getVariable(trim(parts[0]), ctx));
        let right = parseInt(trimQuotes(trim(parts[1])));
        return left >= right;
    }
    if (contains(expr, "<=")) {
        let parts = split(expr, "<=");
        let left = parseInt(getVariable(trim(parts[0]), ctx));
        let right = parseInt(trimQuotes(trim(parts[1])));
        return left <= right;
    }
    if (contains(expr, ">")) {
        let parts = split(expr, ">");
        let left = parseInt(getVariable(trim(parts[0]), ctx));
        let right = parseInt(trimQuotes(trim(parts[1])));
        return left > right;
    }
    if (contains(expr, "<")) {
        let parts = split(expr, "<");
        let left = parseInt(getVariable(trim(parts[0]), ctx));
        let right = parseInt(trimQuotes(trim(parts[1])));
        return left < right;
    }
    
    // Handle not
    if (startsWith(expr, "not ") || startsWith(expr, "!")) {
        let varName = "";
        if (startsWith(expr, "not ")) {
            varName = trim(substr(expr, 4, len(expr) - 4));
        } else {
            varName = trim(substr(expr, 1, len(expr) - 1));
        }
        let value = getVariable(varName, ctx);
        return len(value) == 0 || value == "false" || value == "0";
    }
    
    // Simple truthiness check
    let value = getVariable(expr, ctx);
    return len(value) > 0 && value != "false" && value != "0" && value != "null";
}

fn trimQuotes(s: string) -> string {
    if (len(s) >= 2) {
        let first = charAt(s, 0);
        let last = charAt(s, len(s) - 1);
        if ((first == "\"" && last == "\"") || (first == "'" && last == "'")) {
            return substr(s, 1, len(s) - 2);
        }
    }
    return s;
}

// ============================================
// Loop Processing
// ============================================

fn processForLoops(template: string, ctx: TemplateContext) -> string {
    let result = template;
    let maxIterations = 50;
    let iterations = 0;
    
    while (contains(result, "{% for") && iterations < maxIterations) {
        let forStart = indexOf(result, "{% for");
        if (forStart < 0) { break; }
        
        // Find %}
        let forEnd = indexOf(substr(result, forStart, len(result) - forStart), "%}");
        if (forEnd < 0) { break; }
        forEnd = forStart + forEnd;
        
        // Extract loop declaration: item in items
        let loopDecl = trim(substr(result, forStart + 6, forEnd - forStart - 6));
        
        // Parse: item in items
        let inIdx = indexOf(loopDecl, " in ");
        if (inIdx < 0) { break; }
        
        let itemVar = trim(substr(loopDecl, 0, inIdx));
        let listVar = trim(substr(loopDecl, inIdx + 4, len(loopDecl) - inIdx - 4));
        
        // Find {% endfor %}
        let endforPos = findMatchingEndfor(result, forEnd + 2);
        if (endforPos < 0) { break; }
        
        // Extract loop body
        let loopBody = substr(result, forEnd + 2, endforPos - forEnd - 2);
        
        // Get list from context
        let list = ctx.data[listVar];
        
        // Generate output
        let output = "";
        if (list != null) {
            let i = 0;
            while (i < len(list)) {
                let item = list[i];
                
                // Create loop context
                let loopCtx = createContextWithData(ctx.data);
                loopCtx.data[itemVar] = item;
                loopCtx.data["loop"] = {
                    index: i,
                    index1: i + 1,
                    first: i == 0,
                    last: i == len(list) - 1,
                    length: len(list)
                };
                loopCtx.filters = ctx.filters;
                loopCtx.partials = ctx.partials;
                
                // Render body with loop context
                let rendered = processVariables(loopBody, loopCtx);
                rendered = processConditionals(rendered, loopCtx);
                output = output + rendered;
                
                i = i + 1;
            }
        }
        
        // Replace loop with output
        let beforeFor = substr(result, 0, forStart);
        let afterEndfor = substr(result, endforPos + 11, len(result) - endforPos - 11);
        result = beforeFor + output + afterEndfor;
        
        iterations = iterations + 1;
    }
    
    return result;
}

fn findMatchingEndfor(template: string, startPos: int) -> int {
    let depth = 1;
    let i = startPos;
    
    while (i < len(template) && depth > 0) {
        let rest = substr(template, i, len(template) - i);
        
        if (startsWith(rest, "{% for")) {
            depth = depth + 1;
            i = i + 6;
        } else if (startsWith(rest, "{% endfor")) {
            depth = depth - 1;
            if (depth == 0) {
                return i;
            }
            i = i + 9;
        } else {
            i = i + 1;
        }
    }
    
    return -1;
}

// ============================================
// Include Processing
// ============================================

fn processIncludes(template: string, ctx: TemplateContext) -> string {
    let result = template;
    let maxIterations = 20;
    let iterations = 0;
    
    while (contains(result, "{% include") && iterations < maxIterations) {
        let inclStart = indexOf(result, "{% include");
        if (inclStart < 0) { break; }
        
        let inclEnd = indexOf(substr(result, inclStart, len(result) - inclStart), "%}");
        if (inclEnd < 0) { break; }
        inclEnd = inclStart + inclEnd;
        
        // Extract partial name
        let partialExpr = trim(substr(result, inclStart + 10, inclEnd - inclStart - 10));
        let partialName = trimQuotes(partialExpr);
        
        // Get partial content
        let partialContent = ctx.partials[partialName];
        if (partialContent == null) {
            partialContent = "";
        }
        
        // Render partial
        let rendered = renderTemplate(partialContent, ctx);
        
        // Replace include with content
        let before = substr(result, 0, inclStart);
        let after = substr(result, inclEnd + 2, len(result) - inclEnd - 2);
        result = before + rendered + after;
        
        iterations = iterations + 1;
    }
    
    return result;
}

// ============================================
// Layout/Extends Processing
// ============================================

fn processExtends(template: string, ctx: TemplateContext) -> string {
    // Check for {% extends "layout" %}
    if (!contains(template, "{% extends")) {
        return template;
    }
    
    let extStart = indexOf(template, "{% extends");
    let extEnd = indexOf(template, "%}");
    if (extStart < 0 || extEnd < 0) {
        return template;
    }
    
    // Extract layout name
    let layoutExpr = trim(substr(template, extStart + 10, extEnd - extStart - 10));
    let layoutName = trimQuotes(layoutExpr);
    
    // Get layout template
    let layoutTemplate = ctx.layouts[layoutName];
    if (layoutTemplate == null) {
        return template;
    }
    
    // Extract blocks from child template
    let childContent = substr(template, extEnd + 2, len(template) - extEnd - 2);
    let blocks = extractBlocks(childContent);
    
    // Replace blocks in layout
    let result = layoutTemplate;
    let blockNames = ["content", "title", "head", "scripts", "styles", "header", "footer", "sidebar"];
    let i = 0;
    while (i < len(blockNames)) {
        let blockName = blockNames[i];
        let blockContent = blocks[blockName];
        if (blockContent != null) {
            let placeholder = "{% block " + blockName + " %}";
            let endBlock = "{% endblock %}";
            
            let blockStart = indexOf(result, placeholder);
            if (blockStart >= 0) {
                let blockEnd = indexOf(substr(result, blockStart, len(result) - blockStart), endBlock);
                if (blockEnd >= 0) {
                    blockEnd = blockStart + blockEnd;
                    let before = substr(result, 0, blockStart);
                    let after = substr(result, blockEnd + 14, len(result) - blockEnd - 14);
                    result = before + blockContent + after;
                }
            }
        }
        i = i + 1;
    }
    
    return result;
}

fn extractBlocks(template: string) -> any {
    let blocks = {};
    let blockNames = ["content", "title", "head", "scripts", "styles", "header", "footer", "sidebar"];
    
    let i = 0;
    while (i < len(blockNames)) {
        let blockName = blockNames[i];
        let startTag = "{% block " + blockName + " %}";
        let endTag = "{% endblock %}";
        
        let startPos = indexOf(template, startTag);
        if (startPos >= 0) {
            let contentStart = startPos + len(startTag);
            let rest = substr(template, contentStart, len(template) - contentStart);
            let endPos = indexOf(rest, endTag);
            if (endPos >= 0) {
                blocks[blockName] = substr(template, contentStart, endPos);
            }
        }
        i = i + 1;
    }
    
    return blocks;
}

// ============================================
// Helper Functions
// ============================================

fn capitalize(s: string) -> string {
    if (len(s) == 0) { return s; }
    return toUpperCase(charAt(s, 0)) + toLowerCase(substr(s, 1, len(s) - 1));
}

fn reverseString(s: string) -> string {
    let result = "";
    let i = len(s) - 1;
    while (i >= 0) {
        result = result + charAt(s, i);
        i = i - 1;
    }
    return result;
}

fn escapeHtml(s: string) -> string {
    let result = s;
    result = replace(result, "&", "&amp;");
    result = replace(result, "<", "&lt;");
    result = replace(result, ">", "&gt;");
    result = replace(result, "\"", "&quot;");
    result = replace(result, "'", "&#39;");
    return result;
}

fn urlEncode(s: string) -> string {
    let result = "";
    let i = 0;
    while (i < len(s)) {
        let c = charAt(s, i);
        if (isAlphanumeric(c) || c == "-" || c == "_" || c == "." || c == "~") {
            result = result + c;
        } else if (c == " ") {
            result = result + "+";
        } else {
            result = result + "%" + toHex(ord(c));
        }
        i = i + 1;
    }
    return result;
}

fn isAlphanumeric(c: string) -> bool {
    return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z") || (c >= "0" && c <= "9");
}

fn toHex(n: int) -> string {
    let hex = "0123456789ABCDEF";
    return charAt(hex, (n / 16) % 16) + charAt(hex, n % 16);
}

fn ord(c: string) -> int {
    // ASCII ordinal (simplified)
    return 0;
}

// ============================================
// Quick Render Functions
// ============================================

fn render(template: string, data: any) -> string {
    let ctx = createContextWithData(data);
    return renderTemplate(template, ctx);
}

fn renderFile(path: string, data: any) -> string {
    let template = readFile(path);
    return render(template, data);
}
