// ============================================
// CRYO STANDARD LIBRARY: RESULT (v2.19.0)
// Result/Option types for error handling
// ============================================

// Result type constants
let RESULT_OK = 1;
let RESULT_ERR = 0;

// Option type constants
let OPTION_SOME = 1;
let OPTION_NONE = 0;

// ============================================
// RESULT TYPE
// Result = [type, value] where type is RESULT_OK or RESULT_ERR
// ============================================

// Create Ok result
fn Ok(value) {
    let res = [RESULT_OK, value];
    return res;
}

// Create Err result
fn Err(error) {
    let res = [RESULT_ERR, error];
    return res;
}

// Check if result is Ok
fn isOk(result) {
    return result[0] == RESULT_OK;
}

// Check if result is Err
fn isErr(result) {
    return result[0] == RESULT_ERR;
}

// Unwrap result value (panics if Err)
fn unwrap(result) {
    if (result[0] == RESULT_ERR) {
        print("Error: unwrap called on Err: " + result[1]);
        return null;
    }
    return result[1];
}

// Unwrap with default value
fn unwrapOr(result, default_val) {
    if (result[0] == RESULT_ERR) {
        return default_val;
    }
    return result[1];
}

// Get error value
fn unwrapErr(result) {
    if (result[0] == RESULT_OK) {
        print("Error: unwrap_err called on Ok");
        return null;
    }
    return result[1];
}

// Map Ok value, keep Err unchanged
fn resultMap(result, value) {
    if (result[0] == RESULT_OK) {
        return Ok(value);
    }
    return result;
}

// Map Err value, keep Ok unchanged
fn resultMapErr(result, error) {
    if (result[0] == RESULT_ERR) {
        return Err(error);
    }
    return result;
}

// Convert Result to Option (Err becomes None)
fn resultOk(result) {
    if (result[0] == RESULT_OK) {
        return Some(result[1]);
    }
    return None();
}

// ============================================
// OPTION TYPE
// Option = [type, value] where type is OPTION_SOME or OPTION_NONE
// ============================================

// Create Some option
fn Some(value) {
    let opt = [OPTION_SOME, value];
    return opt;
}

// Create None option
fn None() {
    let opt = [OPTION_NONE, null];
    return opt;
}

// Check if option is Some
fn isSome(option) {
    return option[0] == OPTION_SOME;
}

// Check if option is None
fn isNone(option) {
    return option[0] == OPTION_NONE;
}

// Unwrap option value (panics if None)
fn optionUnwrap(option) {
    if (option[0] == OPTION_NONE) {
        print("Error: unwrap called on None");
        return null;
    }
    return option[1];
}

// Unwrap with default value
fn optionUnwrapOr(option, default_val) {
    if (option[0] == OPTION_NONE) {
        return default_val;
    }
    return option[1];
}

// Map Some value, keep None unchanged
fn optionMap(option, value) {
    if (option[0] == OPTION_SOME) {
        return Some(value);
    }
    return option;
}

// Convert Option to Result
fn optionOkOr(option, error) {
    if (option[0] == OPTION_SOME) {
        return Ok(option[1]);
    }
    return Err(error);
}

// Flatten nested Option
fn optionFlatten(option) {
    if (option[0] == OPTION_NONE) {
        return None();
    }
    let inner = option[1];
    if (inner[0] == OPTION_SOME) {
        return inner;
    }
    if (inner[0] == OPTION_NONE) {
        return inner;
    }
    return Some(inner);
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

// Try: wrap potentially failing operation
// Returns Ok(value) or Err(error_msg)
fn tryParseInt(s) {
    let n = len(s);
    if (n == 0) {
        return Err("empty string");
    }
    
    let i = 0;
    let negative = false;
    if (s[0] == "-") {
        negative = true;
        i = 1;
    }
    
    let result = 0;
    while (i < n) {
        let code = charCodeAt(s, i);
        if (code < 48) {
            return Err("invalid character: " + s[i]);
        }
        if (code > 57) {
            return Err("invalid character: " + s[i]);
        }
        result = result * 10 + (code - 48);
        i = i + 1;
    }
    
    if (negative) {
        result = 0 - result;
    }
    return Ok(result);
}

// Assert with result
fn assertOk(result, msg) {
    if (isErr(result)) {
        print("Assertion failed: " + msg + " - " + unwrapErr(result));
        return false;
    }
    return true;
}
