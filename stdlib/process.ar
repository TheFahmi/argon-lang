// ============================================
// ARGON STANDARD LIBRARY: PROCESS (v2.19.0)
// Process and command execution utilities
// ============================================

// ============================================
// COMMAND EXECUTION RESULT
// ============================================

struct ProcessResult {
    exit_code: int,
    stdout: string,
    stderr: string,
    success: bool
}

// Create a successful result
fn processOk(code, out, err) {
    return ProcessResult {
        exit_code: code,
        stdout: out,
        stderr: err,
        success: code == 0
    };
}

// Create a failed result
fn processError(code, err_msg) {
    return ProcessResult {
        exit_code: code,
        stdout: "",
        stderr: err_msg,
        success: false
    };
}

// ============================================
// COMMAND BUILDER
// ============================================

struct Command {
    program: string,
    args_str: string,
    env_str: string,
    work_dir: string,
    timeout_ms: int,
    arg_count: int
}

// Helper: create empty args representation
fn _empty_args() {
    return "";
}

// Create a new command
fn commandNew(program) {
    return Command {
        program: program,
        args_str: "",
        env_str: "",
        work_dir: "",
        timeout_ms: 0,
        arg_count: 0
    };
}

// Add argument to command (stores as delimited string)
fn commandArg(cmd, arg) {
    let new_args = cmd.args_str;
    if (cmd.arg_count > 0) {
        new_args = new_args + "\x00" + arg;
    } else {
        new_args = arg;
    }
    return Command {
        program: cmd.program,
        args_str: new_args,
        env_str: cmd.env_str,
        work_dir: cmd.work_dir,
        timeout_ms: cmd.timeout_ms,
        arg_count: cmd.arg_count + 1
    };
}

// Set working directory
fn commandCwd(cmd, dir) {
    return Command {
        program: cmd.program,
        args_str: cmd.args_str,
        env_str: cmd.env_str,
        work_dir: dir,
        timeout_ms: cmd.timeout_ms,
        arg_count: cmd.arg_count
    };
}

// Set environment variable
fn commandEnv(cmd, key, value) {
    let env_pair = key + "=" + value;
    let new_envs = cmd.env_str;
    if (len(cmd.env_str) > 0) {
        new_envs = new_envs + "\x00" + env_pair;
    } else {
        new_envs = env_pair;
    }
    return Command {
        program: cmd.program,
        args_str: cmd.args_str,
        env_str: new_envs,
        work_dir: cmd.work_dir,
        timeout_ms: cmd.timeout_ms,
        arg_count: cmd.arg_count
    };
}

// Set timeout in milliseconds
fn commandTimeout(cmd, ms) {
    return Command {
        program: cmd.program,
        args_str: cmd.args_str,
        env_str: cmd.env_str,
        work_dir: cmd.work_dir,
        timeout_ms: ms,
        arg_count: cmd.arg_count
    };
}

// Build command string for display
fn commandToString(cmd) {
    let result = cmd.program;
    if (cmd.arg_count > 0) {
        // Replace null separators with spaces for display
        let i = 0;
        let args = cmd.args_str;
        while (i < len(args)) {
            let c = args[i];
            if (c == "\x00") {
                result = result + " ";
            } else {
                result = result + c;
            }
            i = i + 1;
        }
        if (len(cmd.args_str) > 0) {
            result = result + " " + cmd.args_str;
        }
    }
    return result;
}

// Execute command (placeholder - needs runtime support)
fn commandRun(cmd) {
    // This would need runtime intrinsics like:
    // argonExec(program, args_str, cwd, env_str, timeout)
    // For now, return a placeholder
    let cmd_str = commandToString(cmd);
    
    // Placeholder until runtime support is added
    return processError(0 - 1, "Process execution requires runtime support");
}

// ============================================
// CONVENIENCE FUNCTIONS
// ============================================

// Run a shell command (simple version)
fn shell(command_str) {
    // Would use system shell
    // Unix: sh -c "command"
    let cmd = commandNew("sh");
    cmd = commandArg(cmd, "-c");
    cmd = commandArg(cmd, command_str);
    return commandRun(cmd);
}

// ============================================
// ENVIRONMENT
// ============================================

// Get all environment as string (placeholder)
fn processEnvDump() {
    // Would iterate through all env vars
    return "ENV_DUMP_NOT_IMPLEMENTED";
}

// ============================================
// PROCESS INFO
// ============================================

struct ProcessInfo {
    pid: int,
    parent_pid: int,
    name: string
}

// Get current process info (placeholder)
fn processCurrent() {
    // Would need: argonGetpid(), argonGetppid()
    return ProcessInfo {
        pid: 0,
        parent_pid: 0,
        name: "argon"
    };
}

// ============================================
// EXIT
// ============================================

// Exit with code (placeholder - needs runtime)
fn processExit(code) {
    // Would call: argonExit(code)
    print("EXIT: " + code);
}

// Exit successfully
fn exitOk() {
    processExit(0);
}

// Exit with error
fn exitError() {
    processExit(1);
}

// ============================================
// SIGNAL HANDLING (placeholder)
// ============================================

// Signal constants
let SIGINT = 2;
let SIGTERM = 15;
let SIGKILL = 9;

// Register signal handler (placeholder)
fn onSignal(signal, handler_fn) {
    // Would need runtime support for signal handling
    print("Signal handling not yet implemented");
}

// Send signal to process (placeholder)
fn processKill(pid, signal) {
    // Would call: argonKill(pid, signal)
    return false;
}
