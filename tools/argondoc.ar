// ============================================
// ARGONDOC - Documentation Generator
// Argon Documentation Tool v1.0
// ============================================

import "stdlib/string.ar";
import "stdlib/fs.ar";

// ============================================
// CONSTANTS
// ============================================

let VERSION = "1.0.0";
let OUTPUT_DIR = "docs/api";

// ============================================
// DOC COMMENT PARSING
// ============================================

// Documentation entry
struct DocEntry {
    name: string,
    kind: string,       // "function", "struct", "enum", "const"
    signature: string,
    description: string,
    params: [any],
    returns: string,
    examples: [string],
    deprecated: bool,
    since: string
}

// Module documentation
struct ModuleDoc {
    name: string,
    path: string,
    description: string,
    entries: [DocEntry],
    imports: [string]
}

// ============================================
// PARSER FUNCTIONS
// ============================================

// Parse a single doc comment block
fn parseDocComment(comment: string) -> any {
    let doc = {
        description: "",
        params: [],
        returns: "",
        examples: [],
        deprecated: false,
        since: ""
    };
    
    let lines = split(comment, "\n");
    let i = 0;
    let inExample = false;
    let currentExample = "";
    
    while (i < len(lines)) {
        let line = trim(lines[i]);
        
        // Skip comment markers
        if (startsWith(line, "//")) {
            line = trim(substr(line, 2, len(line) - 2));
        }
        if (startsWith(line, "///")) {
            line = trim(substr(line, 3, len(line) - 3));
        }
        
        // Parse special tags
        if (startsWith(line, "@param")) {
            let param = parseParam(substr(line, 6, len(line) - 6));
            push(doc.params, param);
        } else if (startsWith(line, "@returns") || startsWith(line, "@return")) {
            let offset = 8;
            if (startsWith(line, "@return ")) { offset = 8; }
            doc.returns = trim(substr(line, offset, len(line) - offset));
        } else if (startsWith(line, "@example")) {
            inExample = true;
            currentExample = "";
        } else if (startsWith(line, "@endexample")) {
            inExample = false;
            push(doc.examples, currentExample);
            currentExample = "";
        } else if (startsWith(line, "@deprecated")) {
            doc.deprecated = true;
        } else if (startsWith(line, "@since")) {
            doc.since = trim(substr(line, 6, len(line) - 6));
        } else if (inExample) {
            currentExample = currentExample + line + "\n";
        } else if (len(line) > 0) {
            // Regular description line
            if (len(doc.description) > 0) {
                doc.description = doc.description + " ";
            }
            doc.description = doc.description + line;
        }
        
        i = i + 1;
    }
    
    return doc;
}

// Parse @param tag
fn parseParam(paramStr: string) -> any {
    let trimmed = trim(paramStr);
    let spaceIdx = indexOf(trimmed, " ");
    
    if (spaceIdx > 0) {
        return {
            name: substr(trimmed, 0, spaceIdx),
            description: trim(substr(trimmed, spaceIdx + 1, len(trimmed) - spaceIdx - 1))
        };
    }
    
    return {
        name: trimmed,
        description: ""
    };
}

// Extract function signature from declaration
fn parseFunctionSignature(line: string) -> any {
    // Example: fn foo(a: int, b: string) -> string
    let result = {
        name: "",
        params: [],
        returnType: ""
    };
    
    // Find function name (after "fn ")
    if (startsWith(line, "fn ")) {
        let rest = substr(line, 3, len(line) - 3);
        let parenIdx = indexOf(rest, "(");
        
        if (parenIdx > 0) {
            result.name = trim(substr(rest, 0, parenIdx));
            
            // Find params between ()
            let closeIdx = indexOf(rest, ")");
            if (closeIdx > parenIdx) {
                let paramsStr = substr(rest, parenIdx + 1, closeIdx - parenIdx - 1);
                result.params = split(paramsStr, ",");
            }
            
            // Find return type after ->
            let arrowIdx = indexOf(rest, "->");
            if (arrowIdx > 0) {
                let returnPart = trim(substr(rest, arrowIdx + 2, len(rest) - arrowIdx - 2));
                // Remove trailing {
                let braceIdx = indexOf(returnPart, "{");
                if (braceIdx > 0) {
                    result.returnType = trim(substr(returnPart, 0, braceIdx));
                } else {
                    result.returnType = returnPart;
                }
            }
        }
    }
    
    return result;
}

// Parse struct definition
fn parseStructSignature(line: string) -> any {
    let result = {
        name: "",
        fields: []
    };
    
    if (startsWith(line, "struct ")) {
        let rest = substr(line, 7, len(line) - 7);
        let braceIdx = indexOf(rest, "{");
        
        if (braceIdx > 0) {
            result.name = trim(substr(rest, 0, braceIdx));
        } else {
            result.name = trim(rest);
        }
    }
    
    return result;
}

// ============================================
// SOURCE FILE PARSING
// ============================================

// Parse an entire Argon source file
fn parseSourceFile(path: string) -> ModuleDoc {
    let content = readFile(path);
    let lines = split(content, "\n");
    
    let module = ModuleDoc {
        name: extractModuleName(path),
        path: path,
        description: "",
        entries: [],
        imports: []
    };
    
    let currentComment = "";
    let i = 0;
    
    while (i < len(lines)) {
        let line = lines[i];
        let trimmed = trim(line);
        
        // Collect doc comments
        if (startsWith(trimmed, "///") || startsWith(trimmed, "//!")) {
            currentComment = currentComment + trimmed + "\n";
        } else if (startsWith(trimmed, "// ===")) {
            // Section header - could be module description
            if (len(module.description) == 0 && len(currentComment) > 0) {
                let parsed = parseDocComment(currentComment);
                module.description = parsed.description;
            }
            currentComment = "";
        } else if (startsWith(trimmed, "import ")) {
            // Track imports
            let importPath = extractImportPath(trimmed);
            push(module.imports, importPath);
            currentComment = "";
        } else if (startsWith(trimmed, "fn ")) {
            // Function definition
            let sig = parseFunctionSignature(trimmed);
            let docInfo = parseDocComment(currentComment);
            
            let entry = DocEntry {
                name: sig.name,
                kind: "function",
                signature: trimmed,
                description: docInfo.description,
                params: docInfo.params,
                returns: docInfo.returns,
                examples: docInfo.examples,
                deprecated: docInfo.deprecated,
                since: docInfo.since
            };
            
            push(module.entries, entry);
            currentComment = "";
        } else if (startsWith(trimmed, "struct ")) {
            // Struct definition
            let sig = parseStructSignature(trimmed);
            let docInfo = parseDocComment(currentComment);
            
            let entry = DocEntry {
                name: sig.name,
                kind: "struct",
                signature: extractStructBody(lines, i),
                description: docInfo.description,
                params: [],
                returns: "",
                examples: docInfo.examples,
                deprecated: docInfo.deprecated,
                since: docInfo.since
            };
            
            push(module.entries, entry);
            currentComment = "";
        } else if (startsWith(trimmed, "let ") && indexOf(trimmed, "=") > 0) {
            // Constant
            let docInfo = parseDocComment(currentComment);
            let constName = extractConstName(trimmed);
            
            if (isUpperCase(constName)) {
                let entry = DocEntry {
                    name: constName,
                    kind: "const",
                    signature: trimmed,
                    description: docInfo.description,
                    params: [],
                    returns: "",
                    examples: [],
                    deprecated: docInfo.deprecated,
                    since: docInfo.since
                };
                push(module.entries, entry);
            }
            currentComment = "";
        } else if (!startsWith(trimmed, "//") && len(trimmed) > 0) {
            currentComment = "";
        }
        
        i = i + 1;
    }
    
    return module;
}

// Extract module name from path
fn extractModuleName(path: string) -> string {
    let parts = split(path, "/");
    let filename = parts[len(parts) - 1];
    // Remove .ar extension
    if (endsWith(filename, ".ar")) {
        return substr(filename, 0, len(filename) - 3);
    }
    return filename;
}

// Extract import path from import statement
fn extractImportPath(line: string) -> string {
    let start = indexOf(line, "\"");
    let end = lastIndexOf(line, "\"");
    if (start >= 0 && end > start) {
        return substr(line, start + 1, end - start - 1);
    }
    return "";
}

// Extract constant name
fn extractConstName(line: string) -> string {
    let rest = substr(line, 4, len(line) - 4); // Remove "let "
    let eqIdx = indexOf(rest, "=");
    if (eqIdx > 0) {
        return trim(substr(rest, 0, eqIdx));
    }
    return "";
}

// Check if string is uppercase
fn isUpperCase(s: string) -> bool {
    let i = 0;
    while (i < len(s)) {
        let c = charAt(s, i);
        if (c >= "a" && c <= "z") {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Extract struct body (multi-line)
fn extractStructBody(lines: [string], startIdx: int) -> string {
    let body = "";
    let i = startIdx;
    let braceCount = 0;
    let started = false;
    
    while (i < len(lines)) {
        let line = lines[i];
        body = body + line + "\n";
        
        // Count braces
        let j = 0;
        while (j < len(line)) {
            let c = charAt(line, j);
            if (c == "{") { braceCount = braceCount + 1; started = true; }
            if (c == "}") { braceCount = braceCount - 1; }
            j = j + 1;
        }
        
        if (started && braceCount == 0) {
            return body;
        }
        
        i = i + 1;
    }
    
    return body;
}

// ============================================
// HTML GENERATION
// ============================================

// Generate HTML documentation for a module
fn generateModuleHtml(module: ModuleDoc) -> string {
    let html = "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n";
    html = html + "  <meta charset=\"UTF-8\">\n";
    html = html + "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    html = html + "  <title>" + module.name + " - Argon API Documentation</title>\n";
    html = html + "  <link rel=\"stylesheet\" href=\"style.css\">\n";
    html = html + "</head>\n<body>\n";
    
    // Header
    html = html + "<header>\n";
    html = html + "  <h1>ðŸ“š " + module.name + "</h1>\n";
    html = html + "  <p class=\"module-path\">" + module.path + "</p>\n";
    html = html + "</header>\n\n";
    
    // Description
    if (len(module.description) > 0) {
        html = html + "<section class=\"description\">\n";
        html = html + "  <p>" + module.description + "</p>\n";
        html = html + "</section>\n\n";
    }
    
    // Table of Contents
    html = html + "<nav class=\"toc\">\n";
    html = html + "  <h2>Contents</h2>\n";
    html = html + "  <ul>\n";
    
    let i = 0;
    while (i < len(module.entries)) {
        let entry = module.entries[i];
        html = html + "    <li><a href=\"#" + entry.name + "\">" + entry.name + "</a> <span class=\"kind\">" + entry.kind + "</span></li>\n";
        i = i + 1;
    }
    
    html = html + "  </ul>\n";
    html = html + "</nav>\n\n";
    
    // Entries
    html = html + "<main>\n";
    
    i = 0;
    while (i < len(module.entries)) {
        let entry = module.entries[i];
        html = html + generateEntryHtml(entry);
        i = i + 1;
    }
    
    html = html + "</main>\n\n";
    
    // Footer
    html = html + "<footer>\n";
    html = html + "  <p>Generated by argondoc v" + VERSION + "</p>\n";
    html = html + "</footer>\n";
    
    html = html + "</body>\n</html>\n";
    
    return html;
}

// Generate HTML for a single entry
fn generateEntryHtml(entry: DocEntry) -> string {
    let html = "<article class=\"entry " + entry.kind + "\" id=\"" + entry.name + "\">\n";
    
    // Header
    html = html + "  <h3>\n";
    if (entry.deprecated) {
        html = html + "    <span class=\"deprecated-badge\">Deprecated</span>\n";
    }
    html = html + "    <span class=\"kind-badge\">" + entry.kind + "</span>\n";
    html = html + "    " + entry.name + "\n";
    html = html + "  </h3>\n\n";
    
    // Signature
    html = html + "  <pre class=\"signature\"><code>" + escapeHtml(entry.signature) + "</code></pre>\n\n";
    
    // Description
    if (len(entry.description) > 0) {
        html = html + "  <div class=\"description\">\n";
        html = html + "    <p>" + entry.description + "</p>\n";
        html = html + "  </div>\n\n";
    }
    
    // Parameters
    if (len(entry.params) > 0) {
        html = html + "  <div class=\"params\">\n";
        html = html + "    <h4>Parameters</h4>\n";
        html = html + "    <dl>\n";
        
        let i = 0;
        while (i < len(entry.params)) {
            let param = entry.params[i];
            html = html + "      <dt><code>" + param.name + "</code></dt>\n";
            html = html + "      <dd>" + param.description + "</dd>\n";
            i = i + 1;
        }
        
        html = html + "    </dl>\n";
        html = html + "  </div>\n\n";
    }
    
    // Returns
    if (len(entry.returns) > 0) {
        html = html + "  <div class=\"returns\">\n";
        html = html + "    <h4>Returns</h4>\n";
        html = html + "    <p>" + entry.returns + "</p>\n";
        html = html + "  </div>\n\n";
    }
    
    // Examples
    if (len(entry.examples) > 0) {
        html = html + "  <div class=\"examples\">\n";
        html = html + "    <h4>Examples</h4>\n";
        
        let i = 0;
        while (i < len(entry.examples)) {
            html = html + "    <pre class=\"example\"><code>" + escapeHtml(entry.examples[i]) + "</code></pre>\n";
            i = i + 1;
        }
        
        html = html + "  </div>\n\n";
    }
    
    // Since version
    if (len(entry.since) > 0) {
        html = html + "  <p class=\"since\">Since: " + entry.since + "</p>\n";
    }
    
    html = html + "</article>\n\n";
    
    return html;
}

// Escape HTML special characters
fn escapeHtml(s: string) -> string {
    let result = s;
    result = replaceAll(result, "&", "&amp;");
    result = replaceAll(result, "<", "&lt;");
    result = replaceAll(result, ">", "&gt;");
    result = replaceAll(result, "\"", "&quot;");
    return result;
}

// ============================================
// CSS GENERATION
// ============================================

fn generateCss() -> string {
    return ":root {\n" +
        "  --primary: #6366f1;\n" +
        "  --primary-dark: #4f46e5;\n" +
        "  --bg: #0f172a;\n" +
        "  --bg-card: #1e293b;\n" +
        "  --text: #e2e8f0;\n" +
        "  --text-muted: #94a3b8;\n" +
        "  --border: #334155;\n" +
        "  --success: #22c55e;\n" +
        "  --warning: #f59e0b;\n" +
        "  --danger: #ef4444;\n" +
        "}\n\n" +
        "* { margin: 0; padding: 0; box-sizing: border-box; }\n\n" +
        "body {\n" +
        "  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;\n" +
        "  background: var(--bg);\n" +
        "  color: var(--text);\n" +
        "  line-height: 1.6;\n" +
        "}\n\n" +
        "header {\n" +
        "  background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);\n" +
        "  padding: 3rem 2rem;\n" +
        "  text-align: center;\n" +
        "}\n\n" +
        "header h1 { font-size: 2.5rem; margin-bottom: 0.5rem; }\n" +
        ".module-path { color: rgba(255,255,255,0.7); font-family: monospace; }\n\n" +
        "nav.toc {\n" +
        "  background: var(--bg-card);\n" +
        "  padding: 1.5rem 2rem;\n" +
        "  border-bottom: 1px solid var(--border);\n" +
        "}\n\n" +
        ".toc h2 { font-size: 1.25rem; margin-bottom: 1rem; }\n" +
        ".toc ul { list-style: none; display: flex; flex-wrap: wrap; gap: 1rem; }\n" +
        ".toc a { color: var(--primary); text-decoration: none; }\n" +
        ".toc a:hover { text-decoration: underline; }\n" +
        ".toc .kind { color: var(--text-muted); font-size: 0.8rem; }\n\n" +
        "main { max-width: 1000px; margin: 0 auto; padding: 2rem; }\n\n" +
        "article.entry {\n" +
        "  background: var(--bg-card);\n" +
        "  border: 1px solid var(--border);\n" +
        "  border-radius: 0.5rem;\n" +
        "  padding: 1.5rem;\n" +
        "  margin-bottom: 1.5rem;\n" +
        "}\n\n" +
        "article h3 {\n" +
        "  font-size: 1.5rem;\n" +
        "  margin-bottom: 1rem;\n" +
        "  display: flex;\n" +
        "  align-items: center;\n" +
        "  gap: 0.5rem;\n" +
        "}\n\n" +
        ".kind-badge {\n" +
        "  background: var(--primary);\n" +
        "  color: white;\n" +
        "  padding: 0.25rem 0.5rem;\n" +
        "  border-radius: 0.25rem;\n" +
        "  font-size: 0.75rem;\n" +
        "  font-weight: 500;\n" +
        "  text-transform: uppercase;\n" +
        "}\n\n" +
        ".deprecated-badge {\n" +
        "  background: var(--warning);\n" +
        "  color: black;\n" +
        "  padding: 0.25rem 0.5rem;\n" +
        "  border-radius: 0.25rem;\n" +
        "  font-size: 0.75rem;\n" +
        "  font-weight: 500;\n" +
        "}\n\n" +
        "pre.signature {\n" +
        "  background: var(--bg);\n" +
        "  padding: 1rem;\n" +
        "  border-radius: 0.375rem;\n" +
        "  overflow-x: auto;\n" +
        "  font-family: 'Fira Code', monospace;\n" +
        "  font-size: 0.9rem;\n" +
        "}\n\n" +
        ".description { margin: 1rem 0; color: var(--text-muted); }\n" +
        ".params, .returns, .examples { margin-top: 1rem; }\n" +
        ".params h4, .returns h4, .examples h4 {\n" +
        "  font-size: 1rem;\n" +
        "  color: var(--text-muted);\n" +
        "  margin-bottom: 0.5rem;\n" +
        "}\n\n" +
        "dl { margin-left: 1rem; }\n" +
        "dt { font-family: monospace; color: var(--primary); }\n" +
        "dd { margin-left: 1rem; margin-bottom: 0.5rem; color: var(--text-muted); }\n\n" +
        "pre.example {\n" +
        "  background: var(--bg);\n" +
        "  padding: 1rem;\n" +
        "  border-radius: 0.375rem;\n" +
        "  border-left: 3px solid var(--success);\n" +
        "  font-family: 'Fira Code', monospace;\n" +
        "  font-size: 0.85rem;\n" +
        "}\n\n" +
        ".since { color: var(--text-muted); font-size: 0.85rem; margin-top: 1rem; }\n\n" +
        "footer {\n" +
        "  text-align: center;\n" +
        "  padding: 2rem;\n" +
        "  color: var(--text-muted);\n" +
        "  border-top: 1px solid var(--border);\n" +
        "}\n";
}

// ============================================
// INDEX GENERATION
// ============================================

fn generateIndexHtml(modules: [ModuleDoc]) -> string {
    let html = "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n";
    html = html + "  <meta charset=\"UTF-8\">\n";
    html = html + "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    html = html + "  <title>Argon API Documentation</title>\n";
    html = html + "  <link rel=\"stylesheet\" href=\"style.css\">\n";
    html = html + "</head>\n<body>\n";
    
    html = html + "<header>\n";
    html = html + "  <h1>ðŸ“– Argon API Documentation</h1>\n";
    html = html + "  <p>Standard Library Reference</p>\n";
    html = html + "</header>\n\n";
    
    html = html + "<main>\n";
    html = html + "  <section class=\"modules\">\n";
    html = html + "    <h2>Modules</h2>\n";
    html = html + "    <div class=\"module-grid\">\n";
    
    let i = 0;
    while (i < len(modules)) {
        let mod = modules[i];
        html = html + "      <a href=\"" + mod.name + ".html\" class=\"module-card\">\n";
        html = html + "        <h3>" + mod.name + "</h3>\n";
        html = html + "        <p>" + substr(mod.description, 0, 100) + "...</p>\n";
        html = html + "        <span class=\"count\">" + toString(len(mod.entries)) + " items</span>\n";
        html = html + "      </a>\n";
        i = i + 1;
    }
    
    html = html + "    </div>\n";
    html = html + "  </section>\n";
    html = html + "</main>\n\n";
    
    html = html + "<footer>\n";
    html = html + "  <p>Generated by argondoc v" + VERSION + "</p>\n";
    html = html + "</footer>\n";
    
    html = html + "</body>\n</html>\n";
    
    return html;
}

// ============================================
// MAIN ENTRY POINT
// ============================================

fn main() {
    print("ðŸ”§ argondoc v" + VERSION);
    print("Generating documentation...\n");
    
    // Create output directory
    system("mkdir -p " + OUTPUT_DIR);
    
    // Get stdlib files
    let files = listDir("stdlib");
    let modules = [];
    
    let i = 0;
    while (i < len(files)) {
        let file = files[i];
        if (endsWith(file, ".ar")) {
            print("  Processing: " + file);
            let module = parseSourceFile("stdlib/" + file);
            push(modules, module);
            
            // Generate HTML for this module
            let html = generateModuleHtml(module);
            writeFile(OUTPUT_DIR + "/" + module.name + ".html", html);
        }
        i = i + 1;
    }
    
    // Generate index
    let indexHtml = generateIndexHtml(modules);
    writeFile(OUTPUT_DIR + "/index.html", indexHtml);
    
    // Generate CSS
    let css = generateCss();
    writeFile(OUTPUT_DIR + "/style.css", css);
    
    print("\nâœ… Documentation generated in " + OUTPUT_DIR + "/");
    print("   " + toString(len(modules)) + " modules documented.");
    
    return 0;
}
