# Cryo Benchmark Definitions Explained

Here is the breakdown of the different Cryo execution modes used in the benchmark suite:

## 1. Cryo Interpreter
*   **What it is:** The reference implementation written in **Rust**.
*   **How it runs:** It reads Cryo source code, parses it into an AST (Abstract Syntax Tree), and "walks" the tree to execute instructions one by one.
*   **Speed:** **Slow** (~5 seconds).
*   **Why:** It has the overhead of the host language (Rust) processing every single operation at runtime. No machine code is generated.

## 2. Cryo Native (LLVM)
*   **What it is:** A native binary executable generated by the **Rust-based specific compiler**.
*   **How it runs:** The Rust tool (`cryo`) translates Cryo source code -> LLVM IR. Then `clang` optimizes this IR and compiles it into machine code (x86_64).
*   **Speed:** **Very Fast** (~0.006 seconds).
*   **Why:** It runs directly on the CPU as optimized machine instructions, identical to C++ or Rust release builds.

## 3. Cryo Compiler (Self)
*   **What it is:** The compiler logic written **entirely in Cryo language** (`self-host/compiler.ar`).
*   **How it runs:** In the benchmark, this Cryo script is executed by the **Cryo Interpreter**. It reads a source file (e.g., `fib_poly.ar`) and outputs LLVM IR.
*   **Speed:** **Moderate** (0.02 seconds).
*   **Why:** This measures the **compilation time** (how long it takes to compile code), not the execution time of the resulting program. It is surprisingly fast because the logic is simple, even though it runs on the slow interpreter.

## 4. Cryo Self-Hosted (Binary)
*   **What it is:** The native binary executabled generated by the **Cryo Compiler (Self)**.
*   **How it runs:** 
    1. `compiler.ar` (running on interpreter) reads `fib_poly.ar` -> generates `fib_poly.ar.ll`.
    2. `clang` compiles `fib_poly.ar.ll` -> `fib_poly_self` (Executable).
    3. This benchmark measures the running time of `fib_poly_self`.
*   **Speed:** **Very Fast** (~0.006 seconds).
*   **Why:** Even though the *compiler* was written in Cryo, the *output* is standard LLVM IR. Once compiled by Clang, the resulting binary is indistinguishable from one created by C++ or Rust mechanisms.

---

## Comparison Table

| Name | Runner | Role | Speed (Approx) |
| :--- | :--- | :--- | :--- |
| **Cryo Interpreter** | Rust Program | **Runs Code** | üê¢ Slow (4.9s) |
| **Cryo Native (LLVM)** | CPU (Native) | **Runs Code** | ‚ö° Fast (0.006s) |
| **Cryo Compiler (Self)** | Cryo Interpreter | **Compiles Code** | ‚è±Ô∏è Compile Time (0.02s) |
| **Cryo Self-Hosted** | CPU (Native) | **Runs Code** | ‚ö° Fast (0.006s) |
