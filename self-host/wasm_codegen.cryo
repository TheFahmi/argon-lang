// ============================================
// CRYO WASM CODE GENERATOR
// WebAssembly Text (WAT) Output Backend
// Part of Cryo Compiler v2.19.0
// ============================================

// WASM Target Types
let TARGET_NATIVE = 0;
let TARGET_WASM32 = 1;
let TARGET_WASM32_WASI = 2;

// WASM Value Types
let WASM_I32 = "i32";
let WASM_I64 = "i64";
let WASM_F32 = "f32";
let WASM_F64 = "f64";

// WASM Sections
let wasm_imports = [];    // [(module, name, signature)]
let wasm_exports = [];    // [(name, internal_name)]
let wasm_functions = [];  // [(name, params, locals, body)]
let wasm_globals = [];    // [(name, type, init)]
let wasm_data = [];       // [(offset, data)]
let wasm_memory_size = 1; // Pages (64KB each)

// String table for data section
let string_table = [];
let string_offset = 1024;  // Start strings at offset 1024

// Local variable tracking
let wasm_locals = [];
let wasm_local_count = 0;

// Label counter for blocks/loops
let wasm_label_count = 0;

// =================== HELPER FUNCTIONS ===================

fn wasmFreshLabel() {
    let label = "$L" + wasm_label_count;
    wasm_label_count = wasm_label_count + 1;
    return label;
}

fn wasmAddLocal(name: string, typ: string) {
    let entry = [name, typ, wasm_local_count];
    wasm_locals = push(wasm_locals, entry);
    wasm_local_count = wasm_local_count + 1;
    return wasm_local_count - 1;
}

fn wasmFindLocal(name: string) {
    let i = 0;
    while (i < len(wasm_locals)) {
        let entry = wasm_locals[i];
        if (entry[0] == name) {
            return entry[2];  // Return index
        }
        i = i + 1;
    }
    return -1;
}

fn wasmAddString(s: string) {
    // Add string to data section, return offset
    let offset = string_offset;
    let entry = [offset, s];
    string_table = push(string_table, entry);
    string_offset = string_offset + len(s) + 1;  // +1 for null terminator
    return offset;
}

// =================== WAT CODE GENERATION ===================

fn emitWatHeader() {
    let code = "(module\n";
    code = code + "  ;; Cryo WASM Module - Generated by Cryo Compiler v2.19.0\n\n";
    return code;
}

fn emitWatMemory() {
    let code = "  ;; Memory (1 page = 64KB)\n";
    code = code + "  (memory (export \"memory\") " + wasm_memory_size + ")\n\n";
    return code;
}

fn emitWatImports() {
    let code = "  ;; Imports\n";
    
    // Add WASI imports for print
    code = code + "  (import \"wasi_snapshot_preview1\" \"fd_write\"\n";
    code = code + "    (func $fdWrite(param i32 i32 i32 i32) (result i32)))\n";
    
    let i = 0;
    while (i < len(wasm_imports)) {
        let imp = wasm_imports[i];
        let module_name = imp[0];
        let func_name = imp[1];
        let sig = imp[2];
        code = code + "  (import \"" + module_name + "\" \"" + func_name + "\"\n";
        code = code + "    (func $" + func_name + " " + sig + "))\n";
        i = i + 1;
    }
    
    code = code + "\n";
    return code;
}

fn emitWatGlobals() {
    let code = "  ;; Globals\n";
    
    // Heap pointer for simple allocator
    code = code + "  (global $heapPtr(mut i32) (i32.const 4096))\n";
    
    let i = 0;
    while (i < len(wasm_globals)) {
        let g = wasm_globals[i];
        code = code + "  (global $" + g[0] + " (mut " + g[1] + ") (" + g[1] + ".const " + g[2] + "))\n";
        i = i + 1;
    }
    
    code = code + "\n";
    return code;
}

fn emitWatData() {
    let code = "  ;; Data Section (strings)\n";
    
    let i = 0;
    while (i < len(string_table)) {
        let entry = string_table[i];
        let offset = entry[0];
        let str_val = entry[1];
        // Escape special characters in string
        code = code + "  (data (i32.const " + offset + ") \"" + str_val + "\\00\")\n";
        i = i + 1;
    }
    
    code = code + "\n";
    return code;
}

fn emitWatRuntime() {
    let code = "  ;; Cryo Runtime Functions\n\n";
    
    // Simple allocator
    code = code + "  (func $cryoAlloc(param $size i32) (result i32)\n";
    code = code + "    (local $ptr i32)\n";
    code = code + "    global.get $heap_ptr\n";
    code = code + "    local.set $ptr\n";
    code = code + "    global.get $heap_ptr\n";
    code = code + "    local.get $size\n";
    code = code + "    i32.add\n";
    code = code + "    global.set $heap_ptr\n";
    code = code + "    local.get $ptr\n";
    code = code + "  )\n\n";
    
    // Print function (WASI)
    code = code + "  (func $print (param $ptr i32) (param $len i32)\n";
    code = code + "    ;; Setup iovec at offset 0\n";
    code = code + "    (i32.store (i32.const 0) (local.get $ptr))\n";
    code = code + "    (i32.store (i32.const 4) (local.get $len))\n";
    code = code + "    ;; fdWrite(stdout=1, iovec_ptr=0, iovec_len=1, nwritten=8)\n";
    code = code + "    (drop (call $fd_write\n";
    code = code + "      (i32.const 1)   ;; fd = stdout\n";
    code = code + "      (i32.const 0)   ;; iovec ptr\n";
    code = code + "      (i32.const 1)   ;; iovec len\n";
    code = code + "      (i32.const 8))) ;; nwritten ptr\n";
    code = code + "  )\n\n";
    
    // Print newline
    code = code + "  (func $println (param $ptr i32) (param $len i32)\n";
    code = code + "    (call $print (local.get $ptr) (local.get $len))\n";
    code = code + "    ;; Print newline\n";
    code = code + "    (i32.store8 (i32.const 100) (i32.const 10))\n";
    code = code + "    (call $print (i32.const 100) (i32.const 1))\n";
    code = code + "  )\n\n";
    
    return code;
}

// =================== EXPRESSION CODE GENERATION ===================

fn genWasmExpr(node: any) {
    let node_type = node[0];
    
    // Number literal
    if (node_type == 1) { // AST_NUM
        let val = node[1];
        return "i64.const " + val + "\n";
    }
    
    // Variable reference
    if (node_type == 2) { // AST_VAR
        let name = node[1];
        let idx = wasmFindLocal(name);
        if (idx >= 0) {
            return "local.get $" + name + "\n";
        }
        // Global variable
        return "global.get $" + name + "\n";
    }
    
    // Binary operation
    if (node_type == 3) { // AST_BINOP
        let op = node[1];
        let left = node[2];
        let right = node[3];
        
        let code = genWasmExpr(left);
        code = code + genWasmExpr(right);
        
        if (op == "+") { code = code + "i64.add\n"; }
        else if (op == "-") { code = code + "i64.sub\n"; }
        else if (op == "*") { code = code + "i64.mul\n"; }
        else if (op == "/") { code = code + "i64.div_s\n"; }
        else if (op == "%") { code = code + "i64.rem_s\n"; }
        else if (op == "==") { code = code + "i64.eq\n"; }
        else if (op == "!=") { code = code + "i64.ne\n"; }
        else if (op == "<") { code = code + "i64.lt_s\n"; }
        else if (op == "<=") { code = code + "i64.le_s\n"; }
        else if (op == ">") { code = code + "i64.gt_s\n"; }
        else if (op == ">=") { code = code + "i64.ge_s\n"; }
        
        return code;
    }
    
    // Function call
    if (node_type == 4) { // AST_CALL
        let fn_name = node[1];
        let args = node[2];
        
        let code = "";
        let i = 0;
        while (i < len(args)) {
            code = code + genWasmExpr(args[i]);
            i = i + 1;
        }
        code = code + "call $" + fn_name + "\n";
        return code;
    }
    
    // String literal
    if (node_type == 30) { // AST_STR
        let str_val = node[1];
        let offset = wasmAddString(str_val);
        let str_len = len(str_val);
        // Push pointer and length
        return "i32.const " + offset + "\ni32.const " + str_len + "\n";
    }
    
    return ";; Unknown node type: " + node_type + "\n";
}

// =================== STATEMENT CODE GENERATION ===================

fn genWasmStmt(node: any, indent: string) {
    let node_type = node[0];
    
    // Let declaration
    if (node_type == 10) { // AST_LET
        let name = node[1];
        let init = node[2];
        wasmAddLocal(name, "i64");
        
        let code = indent + ";; let " + name + "\n";
        code = code + indent + genWasmExpr(init);
        code = code + indent + "local.set $" + name + "\n";
        return code;
    }
    
    // Assignment
    if (node_type == 11) { // AST_ASSIGN
        let name = node[1];
        let val = node[2];
        
        let code = indent + ";; " + name + " = ...\n";
        code = code + indent + genWasmExpr(val);
        code = code + indent + "local.set $" + name + "\n";
        return code;
    }
    
    // Return statement
    if (node_type == 12) { // AST_RETURN
        let expr = node[1];
        let code = indent + ";; return\n";
        if (expr != 0) {
            code = code + indent + genWasmExpr(expr);
        }
        code = code + indent + "return\n";
        return code;
    }
    
    // Print statement
    if (node_type == 13) { // AST_PRINT
        let expr = node[1];
        let code = indent + ";; print\n";
        code = code + indent + genWasmExpr(expr);
        code = code + indent + "call $println\n";
        return code;
    }
    
    // If statement
    if (node_type == 14) { // AST_IF
        let cond = node[1];
        let then_block = node[2];
        let else_block = node[3];
        
        let code = indent + ";; if\n";
        code = code + indent + genWasmExpr(cond);
        code = code + indent + "if\n";
        
        // Generate then block
        let then_stmts = then_block[1];
        let i = 0;
        while (i < len(then_stmts)) {
            code = code + genWasmStmt(then_stmts[i], indent + "  ");
            i = i + 1;
        }
        
        // Generate else block if present
        if (else_block != 0) {
            code = code + indent + "else\n";
            let else_stmts = else_block[1];
            let j = 0;
            while (j < len(else_stmts)) {
                code = code + genWasmStmt(else_stmts[j], indent + "  ");
                j = j + 1;
            }
        }
        
        code = code + indent + "end\n";
        return code;
    }
    
    // While loop
    if (node_type == 15) { // AST_WHILE
        let cond = node[1];
        let body = node[2];
        let break_label = wasmFreshLabel();
        let cont_label = wasmFreshLabel();
        
        let code = indent + ";; while\n";
        code = code + indent + "block " + break_label + "\n";
        code = code + indent + "  loop " + cont_label + "\n";
        
        // Condition check
        code = code + indent + "    " + genWasmExpr(cond);
        code = code + indent + "    i64.eqz\n";
        code = code + indent + "    br_if " + break_label + "\n";
        
        // Body
        let body_stmts = body[1];
        let i = 0;
        while (i < len(body_stmts)) {
            code = code + genWasmStmt(body_stmts[i], indent + "    ");
            i = i + 1;
        }
        
        code = code + indent + "    br " + cont_label + "\n";
        code = code + indent + "  end\n";
        code = code + indent + "end\n";
        return code;
    }
    
    // Block (just statements)
    if (node_type == 21) { // AST_BLOCK
        let stmts = node[1];
        let code = "";
        let i = 0;
        while (i < len(stmts)) {
            code = code + genWasmStmt(stmts[i], indent);
            i = i + 1;
        }
        return code;
    }
    
    // Expression statement (function call, etc)
    if (node_type == 4) { // AST_CALL
        return indent + genWasmExpr(node) + "drop\n";
    }
    
    return indent + ";; Unknown statement type: " + node_type + "\n";
}

// =================== FUNCTION CODE GENERATION ===================

fn genWasmFunction(node: any) {
    let node_type = node[0];
    
    // Regular function or async function
    if (node_type == 20 || node_type == 140) { // AST_FUNC or AST_ASYNC_FUNC
        let fn_name = node[1];
        let params = node[2];
        let body = node[3];
        
        // Reset locals for this function
        wasm_locals = [];
        wasm_local_count = 0;
        
        // Add parameters as locals
        let i = 0;
        while (i < len(params)) {
            let param = params[i];
            let param_name = param[0];
            wasmAddLocal(param_name, "i64");
            i = i + 1;
        }
        
        // Generate function header
        let code = "  (func $" + fn_name;
        
        // Export main as _start
        if (fn_name == "main") {
            code = code + " (export \"_start\")";
        }
        
        // Parameters
        i = 0;
        while (i < len(params)) {
            let param = params[i];
            code = code + " (param $" + param[0] + " i64)";
            i = i + 1;
        }
        
        // Return type (assume i64 for now, could check)
        // code = code + " (result i64)";
        code = code + "\n";
        
        // Pre-scan body for let declarations to add local declarations
        // For now, we'll emit them inline
        
        // Function body
        let body_stmts = body[1];
        i = 0;
        while (i < len(body_stmts)) {
            code = code + genWasmStmt(body_stmts[i], "    ");
            i = i + 1;
        }
        
        code = code + "  )\n\n";
        
        // Check if this should be exported
        // For now, export all non-main functions too
        let export_entry = [fn_name, fn_name];
        wasm_exports = push(wasm_exports, export_entry);
        
        return code;
    }
    
    return ";; Skipped node type: " + node_type + "\n";
}

fn emitWatExports() {
    let code = "  ;; Exports\n";
    
    let i = 0;
    while (i < len(wasm_exports)) {
        let exp = wasm_exports[i];
        if (exp[0] != "main") {  // main is exported as _start
            code = code + "  (export \"" + exp[0] + "\" (func $" + exp[1] + "))\n";
        }
        i = i + 1;
    }
    
    code = code + "\n";
    return code;
}

fn emitWatFooter() {
    return ")\n";
}

// =================== MAIN WASM GENERATION ===================

fn generateWasm(ast: any) {
    let code = emitWatHeader();
    code = code + emitWatMemory();
    code = code + emitWatImports();
    code = code + emitWatGlobals();
    code = code + emitWatRuntime();
    
    // Generate all functions
    let i = 0;
    while (i < len(ast)) {
        let node = ast[i];
        let node_type = node[0];
        
        // Only process functions
        if (node_type == 20 || node_type == 140) {
            code = code + genWasmFunction(node);
        }
        i = i + 1;
    }
    
    code = code + emitWatData();
    code = code + emitWatFooter();
    
    return code;
}
