// ============================================
// ARGON SELF-HOSTING COMPILER v2.3
// Written entirely in Argon
// Complete Lexer, Parser, and Code Generator
// ============================================

let OPT_UNSAFE = 0; // Optimization flag

// Stage detection: In Stage 0 (Rust), parseInt("1") = 1 (raw).
// In Stage 1 (compiled), parseInt("1") = 3 (tagged: 1*2+1).
// So if parseInt("1") > 2, we're in Stage 1.
let IS_STAGE1 = 0;
fn detect_stage() {
    let test = parseInt("1");
    if (test > 2) {
        IS_STAGE1 = 1;
    }
}

// =================== TOKEN TYPE CONSTANTS ===================

let TOK_EOF = 0;
let TOK_FN = 1;
let TOK_LET = 2;
let TOK_RETURN = 3;
let TOK_IF = 4;
let TOK_ELSE = 5;
let TOK_WHILE = 6;
let TOK_PRINT = 7;
let TOK_TRUE = 8;
let TOK_FALSE = 9;
let TOK_ID = 10;
let TOK_NUM = 11;
let TOK_STR = 12;
let TOK_PLUS = 20;
let TOK_MINUS = 21;
let TOK_STAR = 22;
let TOK_SLASH = 23;
let TOK_LPAREN = 30;
let TOK_RPAREN = 31;
let TOK_LBRACE = 32;
let TOK_RBRACE = 33;
let TOK_LBRACK = 34;
let TOK_RBRACK = 35;
let TOK_EQ = 40;
let TOK_EQEQ = 41;
let TOK_LT = 42;
let TOK_GT = 43;
let TOK_SEMI = 50;
let TOK_COMMA = 51;
let TOK_COLON = 52;
let TOK_BREAK = 54;
let TOK_CONTINUE = 55;

// =================== LEXER ===================

fn is_digit(ch: string) {
    if (ch == "0") { return true; }
    if (ch == "1") { return true; }
    if (ch == "2") { return true; }
    if (ch == "3") { return true; }
    if (ch == "4") { return true; }
    if (ch == "5") { return true; }
    if (ch == "6") { return true; }
    if (ch == "7") { return true; }
    if (ch == "8") { return true; }
    if (ch == "9") { return true; }
    return false;
}

fn is_letter(ch: string) {
    // lowercase a-z
    if (ch == "a") { return true; }
    if (ch == "b") { return true; }
    if (ch == "c") { return true; }
    if (ch == "d") { return true; }
    if (ch == "e") { return true; }
    if (ch == "f") { return true; }
    if (ch == "g") { return true; }
    if (ch == "h") { return true; }
    if (ch == "i") { return true; }
    if (ch == "j") { return true; }
    if (ch == "k") { return true; }
    if (ch == "l") { return true; }
    if (ch == "m") { return true; }
    if (ch == "n") { return true; }
    if (ch == "o") { return true; }
    if (ch == "p") { return true; }
    if (ch == "q") { return true; }
    if (ch == "r") { return true; }
    if (ch == "s") { return true; }
    if (ch == "t") { return true; }
    if (ch == "u") { return true; }
    if (ch == "v") { return true; }
    if (ch == "w") { return true; }
    if (ch == "x") { return true; }
    if (ch == "y") { return true; }
    if (ch == "z") { return true; }
    // uppercase A-Z
    if (ch == "A") { return true; }
    if (ch == "B") { return true; }
    if (ch == "C") { return true; }
    if (ch == "D") { return true; }
    if (ch == "E") { return true; }
    if (ch == "F") { return true; }
    if (ch == "G") { return true; }
    if (ch == "H") { return true; }
    if (ch == "I") { return true; }
    if (ch == "J") { return true; }
    if (ch == "K") { return true; }
    if (ch == "L") { return true; }
    if (ch == "M") { return true; }
    if (ch == "N") { return true; }
    if (ch == "O") { return true; }
    if (ch == "P") { return true; }
    if (ch == "Q") { return true; }
    if (ch == "R") { return true; }
    if (ch == "S") { return true; }
    if (ch == "T") { return true; }
    if (ch == "U") { return true; }
    if (ch == "V") { return true; }
    if (ch == "W") { return true; }
    if (ch == "X") { return true; }
    if (ch == "Y") { return true; }
    if (ch == "Z") { return true; }
    // underscore
    if (ch == "_") { return true; }
    return false;
}

fn is_alnum(ch: string) {
    if (is_letter(ch)) { return true; }
    if (is_digit(ch)) { return true; }
    return false;
}

// Helper to check if char is double quote (ASCII 34)
fn is_quote(ch: string) {
    // Compare with escaped quote character
    if (ch == "\"") { return true; }
    return false;
}

// Helper to check if char is backslash (ASCII 92)  
fn is_backslash(ch: string) {
    // Compare with escaped backslash character
    if (ch == "\\") { return true; }
    return false;
}

fn is_whitespace(c: string) {
    if (c == " ") { return true; }
    if (c == "\n") { return true; }
    if (c == "\t") { return true; }
    if (c == "\r") { return true; }
    return false;
}

// Token structure: [type, value]
fn make_token(typ: int, val: string) {
    return [typ, val];
}

fn tokenize(source: string) {
    let tokens = [];
    let pos = 0;
    let n = len(source);
    
    while (pos < n) {
        let c = source[pos];
        
        // Skip whitespace
        if (is_whitespace(c)) {
            pos = pos + 1;
        }
        // Skip comments
        else if (c == "/") {
            if (pos + 1 < n) {
                if (source[pos + 1] == "/") {
                    // Skip until end of line
                    pos = pos + 2;
                    let in_comment = 1;
                    while (in_comment == 1) {
                        if (pos < n) {
                            if (source[pos] == "\n") {
                                pos = pos + 1;
                                in_comment = 0;
                            } else {
                                pos = pos + 1;
                            }
                        } else {
                            in_comment = 0;
                        }
                    }
                } else {
                    tokens = push(tokens, make_token(TOK_SLASH, "/"));
                    pos = pos + 1;
                }
            } else {
                tokens = push(tokens, make_token(TOK_SLASH, "/"));
                pos = pos + 1;
            }
        }
        // String literals
        else if (is_quote(c)) {
            pos = pos + 1;
            let str_val = "";
            let str_done = 0;
            while (str_done == 0) {
                if (pos < n) {
                    let sc = source[pos];
                    if (is_backslash(sc)) {
                        // Backslash - escape sequence
                        pos = pos + 1;
                        if (pos < n) {
                            let esc = source[pos];
                            if (esc == "n") { str_val = str_val + "\n"; }
                            else if (esc == "t") { str_val = str_val + "\t"; }
                            else if (esc == "r") { str_val = str_val + "\r"; }
                            else if (is_quote(esc)) { str_val = str_val + "\""; }
                            else if (is_backslash(esc)) { str_val = str_val + "\\"; }
                            else if (esc == "0") { str_val = str_val + "\0"; }
                            else { str_val = str_val + esc; }
                            pos = pos + 1;
                        } else {
                            str_done = 1;
                        }
                    } else if (is_quote(sc)) {
                        pos = pos + 1;
                        str_done = 1;
                    } else {
                        str_val = str_val + sc;
                        pos = pos + 1;
                    }
                } else {
                    str_done = 1;
                }
            }
            tokens = push(tokens, make_token(TOK_STR, str_val));
        }
        // Single char tokens
        else if (c == "+") { tokens = push(tokens, make_token(TOK_PLUS, "+")); pos = pos + 1; }
        else if (c == "-") { tokens = push(tokens, make_token(TOK_MINUS, "-")); pos = pos + 1; }
        else if (c == "*") { tokens = push(tokens, make_token(TOK_STAR, "*")); pos = pos + 1; }
        else if (c == "(") { tokens = push(tokens, make_token(TOK_LPAREN, "(")); pos = pos + 1; }
        else if (c == ")") { tokens = push(tokens, make_token(TOK_RPAREN, ")")); pos = pos + 1; }
        else if (c == "{") { tokens = push(tokens, make_token(TOK_LBRACE, "{")); pos = pos + 1; }
        else if (c == "}") { tokens = push(tokens, make_token(TOK_RBRACE, "}")); pos = pos + 1; }
        else if (c == "[") { tokens = push(tokens, make_token(TOK_LBRACK, "[")); pos = pos + 1; }
        else if (c == "]") { tokens = push(tokens, make_token(TOK_RBRACK, "]")); pos = pos + 1; }
        else if (c == ";") { tokens = push(tokens, make_token(TOK_SEMI, ";")); pos = pos + 1; }
        else if (c == ",") { tokens = push(tokens, make_token(TOK_COMMA, ",")); pos = pos + 1; }
        else if (c == ":") { tokens = push(tokens, make_token(TOK_COLON, ":")); pos = pos + 1; }
        else if (c == ".") { tokens = push(tokens, make_token(53, ".")); pos = pos + 1; }
        // Two-char tokens
        else if (c == "=") {
            if (pos + 1 < n) {
                if (source[pos + 1] == "=") {
                    tokens = push(tokens, make_token(TOK_EQEQ, "=="));
                    pos = pos + 2;
                } else {
                    tokens = push(tokens, make_token(TOK_EQ, "="));
                    pos = pos + 1;
                }
            } else {
                tokens = push(tokens, make_token(TOK_EQ, "="));
                pos = pos + 1;
            }
        }
        else if (c == "!") {
            if (pos + 1 < n) {
                if (source[pos + 1] == "=") {
                    tokens = push(tokens, make_token(44, "!="));
                    pos = pos + 2;
                } else {
                    pos = pos + 1;
                }
            } else {
                pos = pos + 1;
            }
        }
        else if (c == "<") { 
            if (pos + 1 < n) {
                if (source[pos + 1] == "=") {
                    tokens = push(tokens, make_token(45, "<="));
                    pos = pos + 2;
                } else {
                    tokens = push(tokens, make_token(TOK_LT, "<")); 
                    pos = pos + 1; 
                }
            } else {
                tokens = push(tokens, make_token(TOK_LT, "<")); 
                pos = pos + 1; 
            }
        }
        else if (c == ">") { 
            if (pos + 1 < n) {
                if (source[pos + 1] == "=") {
                    tokens = push(tokens, make_token(46, ">="));
                    pos = pos + 2;
                } else {
                    tokens = push(tokens, make_token(TOK_GT, ">")); 
                    pos = pos + 1; 
                }
            } else {
                tokens = push(tokens, make_token(TOK_GT, ">")); 
                pos = pos + 1; 
            }
        }
        // Numbers
        else if (is_digit(c)) {
            let num_str = "";
            let num_done = 0;
            while (num_done == 0) {
                if (pos < n) {
                    let dc = source[pos];
                    if (is_digit(dc)) {
                        num_str = num_str + dc;
                        pos = pos + 1;
                    } else {
                        num_done = 1;
                    }
                } else {
                    num_done = 1;
                }
            }
            tokens = push(tokens, make_token(TOK_NUM, num_str));
        }
        // Identifiers & Keywords
        else if (is_letter(c)) {
            let id_str = "";
            let id_done = 0;
            while (id_done == 0) {
                if (pos < n) {
                    let ic = source[pos];
                    if (is_alnum(ic)) {
                        id_str = id_str + ic;
                        pos = pos + 1;
                    } else {
                        id_done = 1;
                    }
                } else {
                    id_done = 1;
                }
            }
            // Check keywords
            if (id_str == "fn") { tokens = push(tokens, make_token(TOK_FN, "fn")); }
            else if (id_str == "let") { tokens = push(tokens, make_token(TOK_LET, "let")); }
            else if (id_str == "return") { tokens = push(tokens, make_token(TOK_RETURN, "return")); }
            else if (id_str == "if") { tokens = push(tokens, make_token(TOK_IF, "if")); }
            else if (id_str == "else") { tokens = push(tokens, make_token(TOK_ELSE, "else")); }
            else if (id_str == "while") { tokens = push(tokens, make_token(TOK_WHILE, "while")); }
            else if (id_str == "print") { tokens = push(tokens, make_token(TOK_PRINT, "print")); }
            else if (id_str == "true") { tokens = push(tokens, make_token(TOK_TRUE, "true")); }
            else if (id_str == "false") { tokens = push(tokens, make_token(TOK_FALSE, "false")); }
            else if (id_str == "null") { tokens = push(tokens, make_token(60, "null")); }
            else if (id_str == "break") { tokens = push(tokens, make_token(TOK_BREAK, "break")); }
            else if (id_str == "continue") { tokens = push(tokens, make_token(TOK_CONTINUE, "continue")); }
            else { tokens = push(tokens, make_token(TOK_ID, id_str)); }
        }
        // Skip unknown
        else {
            pos = pos + 1;
        }
    }
    
    tokens = push(tokens, make_token(TOK_EOF, ""));
    return tokens;
}

// =================== AST NODE TYPES ===================

let AST_NUM = 1;
let AST_VAR = 2;
let AST_BINOP = 3;
let AST_CALL = 4;
let AST_LET = 10;
let AST_ASSIGN = 11;
let AST_RETURN = 12;
let AST_PRINT = 13;
let AST_IF = 14;
let AST_WHILE = 15;
let AST_FUNC = 20;
let AST_BLOCK = 21;
let AST_BREAK = 22;
let AST_CONTINUE = 23;

// =================== PARSER ===================

// Parser state
let p_tokens = [];
let p_pos = 0;

fn p_current() {
    return p_tokens[p_pos];
}

fn p_current_type() {
    let tok = p_tokens[p_pos];
    return tok[0];
}

fn p_current_val() {
    let tok = p_tokens[p_pos];
    return tok[1];
}

fn p_advance() {
    p_pos = p_pos + 1;
}

fn p_match(t: int) {
    if (p_current_type() == t) {
        p_advance();
        return true;
    }
    return false;
}

fn p_expect(t: int) {
    if (p_current_type() == t) {
        p_advance();
        return true;
    }
    print("Parse error: unexpected token");
    return false;
}

// Node constructors
fn make_num(val: int) {
    return [AST_NUM, val];
}

fn make_var(name: string) {
    return [AST_VAR, name];
}

fn make_binop(op: string, left: any, right: any) {
    return [AST_BINOP, op, left, right];
}

fn make_call(name: string, args: any) {
    return [AST_CALL, name, args];
}

fn make_let(name: string, init: any) {
    return [AST_LET, name, init];
}

fn make_assign(name: string, val: any) {
    return [AST_ASSIGN, name, val];
}

fn make_print(expr: any) {
    return [AST_PRINT, expr];
}

fn make_return(expr: any) {
    return [AST_RETURN, expr];
}

fn make_if(cond: any, then_b: any, else_b: any) {
    return [AST_IF, cond, then_b, else_b];
}

fn make_while(cond: any, body: any) {
    return [AST_WHILE, cond, body];
}

fn make_func(name: string, params: any, body: any) {
    return [AST_FUNC, name, params, body];
}

fn make_block(stmts: any) {
    return [AST_BLOCK, stmts];
}

// Expression parsing (recursive descent)
fn parse_primary() {
    let t = p_current_type();
    let v = p_current_val();
    
    // String literal
    if (t == TOK_STR) {
        p_advance();
        return [30, v]; // AST_STR = 30
    }
    
    // Array literal
    if (t == 34) { // TOK_LBRACK = 34
        p_advance();
        let items = [];
        if (p_current_type() != 35) { // TOK_RBRACK
            items = push(items, parse_expr());
            while (p_current_type() == TOK_COMMA) {
                p_advance();
                items = push(items, parse_expr());
            }
        }
        p_expect(35); // TOK_RBRACK
        return [31, items]; // AST_ARRAY = 31
    }

    // Number
    if (t == TOK_NUM) {
        p_advance();
        return make_num(parseInt(v));
    }
    // Variable or function call
    if (t == TOK_ID) {
        let name = v;
        p_advance();
        
        // Check for function call
        if (p_current_type() == TOK_LPAREN) {
            p_advance(); // skip (
            let args = [];
            
            if (p_current_type() != TOK_RPAREN) {
                args = push(args, parse_expr());
                while (p_current_type() == TOK_COMMA) {
                    p_advance();
                    args = push(args, parse_expr());
                }
            }
            p_expect(TOK_RPAREN);
            return make_call(name, args);
        }
        
        // Check for index access [expr]
        if (p_current_type() == 34) { // TOK_LBRACK
            p_advance();
            let idx = parse_expr();
            p_expect(35); // TOK_RBRACK
            // Desugar to argon_get(var, idx)
            // But wait, make_call expects args array.
            let args = [];
            args = push(args, make_var(name));
            args = push(args, idx);
            return [AST_CALL, "argon_get", args];
        }
        
        return make_var(name);
    }
    // Parenthesized expression
    if (t == TOK_LPAREN) {
        p_advance();
        let expr = parse_expr();
        p_expect(TOK_RPAREN);
        return expr;
    }
    // True/False literals
    if (t == TOK_TRUE) {
        p_advance();
        return make_num(1);
    }
    if (t == TOK_FALSE) {
        p_advance();
        return make_num(0);
    }
    
    // Null literal
    if (t == 60) { // TOK_NULL
        p_advance();
        return make_num(0);
    }
    
    print("Parse error at primary: " + v);
    return make_num(0);
}

fn parse_factor() {
    let left = parse_primary();
    
    while (p_current_type() == TOK_STAR) {
        p_advance();
        let right = parse_primary();
        left = make_binop("*", left, right);
    }
    while (p_current_type() == TOK_SLASH) {
        p_advance();
        let right = parse_primary();
        left = make_binop("/", left, right);
    }
    
    return left;
}

fn parse_term() {
    let left = parse_factor();
    
    while (p_current_type() == TOK_PLUS) {
        p_advance();
        let right = parse_factor();
        left = make_binop("+", left, right);
    }
    while (p_current_type() == TOK_MINUS) {
        p_advance();
        let right = parse_factor();
        left = make_binop("-", left, right);
    }
    
    return left;
}

fn parse_comparison() {
    let left = parse_term();
    
    if (p_current_type() == TOK_LT) {
        p_advance();
        let right = parse_term();
        return make_binop("<", left, right);
    }
    if (p_current_type() == TOK_GT) {
        p_advance();
        let right = parse_term();
        return make_binop(">", left, right);
    }
    if (p_current_type() == TOK_EQEQ) {
        p_advance();
        let right = parse_term();
        return make_binop("==", left, right);
    }
    // Added
    if (p_current_type() == 44) { // TOK_NE (!=)
        p_advance();
        let right = parse_term();
        return make_binop("!=", left, right);
    }
    if (p_current_type() == 45) { // TOK_LE (<=)
        p_advance();
        let right = parse_term();
        return make_binop("<=", left, right);
    }
    if (p_current_type() == 46) { // TOK_GE (>=)
        p_advance();
        let right = parse_term();
        return make_binop(">=", left, right);
    }
    
    return left;
}

fn parse_expr() {
    return parse_comparison();
}

// Statement parsing
fn parse_statement() {
    let t = p_current_type();
    
    // let statement
    if (t == TOK_LET) {
        p_advance();
        let name = p_current_val();
        p_expect(TOK_ID);
        
        // Optional type annotation
        if (p_current_type() == TOK_COLON) {
            p_advance();
            p_advance(); // skip type
        }
        
        p_expect(TOK_EQ);
        let init = parse_expr();
        p_expect(TOK_SEMI);
        return make_let(name, init);
    }
    
    // print statement
    if (t == TOK_PRINT) {
        p_advance();
        p_expect(TOK_LPAREN);
        let expr = parse_expr();
        p_expect(TOK_RPAREN);
        p_expect(TOK_SEMI);
        return make_print(expr);
    }
    
    // return statement
    if (t == TOK_RETURN) {
        p_advance();
        let expr = make_num(0);
        if (p_current_type() != TOK_SEMI) {
            expr = parse_expr();
        }
        p_expect(TOK_SEMI);
        return make_return(expr);
    }
    
    // if statement
    if (t == TOK_IF) {
        p_advance();
        p_expect(TOK_LPAREN);
        let cond = parse_expr();
        p_expect(TOK_RPAREN);
        p_expect(TOK_LBRACE);
        
        let then_stmts = [];
        while (p_current_type() != TOK_RBRACE) {
            then_stmts = push(then_stmts, parse_statement());
        }
        p_expect(TOK_RBRACE);
        
        let else_stmts = [];
        if (p_current_type() == TOK_ELSE) {
            p_advance();
            
            if (p_current_type() == TOK_IF) {
                // else if ... -> else { if ... }
                else_stmts = push(else_stmts, parse_statement());
            } else {
                p_expect(TOK_LBRACE);
                while (p_current_type() != TOK_RBRACE) {
                    else_stmts = push(else_stmts, parse_statement());
                }
                p_expect(TOK_RBRACE);
            }
        }
        
        return make_if(cond, make_block(then_stmts), make_block(else_stmts));
    }
    
    // while statement
    if (t == TOK_WHILE) {
        p_advance();
        p_expect(TOK_LPAREN);
        let cond = parse_expr();
        p_expect(TOK_RPAREN);
        p_expect(TOK_LBRACE);
        
        let body_stmts = [];
        while (p_current_type() != TOK_RBRACE) {
            body_stmts = push(body_stmts, parse_statement());
        }
        p_expect(TOK_RBRACE);
        
        return make_while(cond, make_block(body_stmts));
    }
    
    // break statement
    if (t == TOK_BREAK) {
        p_advance();
        p_expect(TOK_SEMI);
        return [AST_BREAK];
    }
    
    // continue statement
    if (t == TOK_CONTINUE) {
        p_advance();
        p_expect(TOK_SEMI);
        return [AST_CONTINUE];
    }
    
    // Assignment or expression statement
    if (t == TOK_ID) {
        let name = p_current_val();
        p_advance();
        
        if (p_current_type() == TOK_EQ) {
            p_advance();
            let val = parse_expr();
            p_expect(TOK_SEMI);
            return make_assign(name, val);
        }
        
        // Expression statement (function call)
        p_pos = p_pos - 1; // backtrack
        let expr = parse_expr();
        p_expect(TOK_SEMI);
        return expr;
    }
    
    print("Unexpected token in statement: " + p_current_val());
    p_advance();
    return make_num(0);
}

fn parse_function() {
    p_expect(TOK_FN);
    let name = p_current_val();
    p_expect(TOK_ID);
    p_expect(TOK_LPAREN);
    
    let params = [];
    if (p_current_type() == TOK_ID) {
        params = push(params, p_current_val());
        p_advance();
        
        // Skip type annotation
        if (p_current_type() == TOK_COLON) {
            p_advance();
            p_advance();
        }
        
        while (p_current_type() == TOK_COMMA) {
            p_advance();
            params = push(params, p_current_val());
            p_advance();
            if (p_current_type() == TOK_COLON) {
                p_advance();
                p_advance();
            }
        }
    }
    p_expect(TOK_RPAREN);
    p_expect(TOK_LBRACE);
    
    let body = [];
    while (p_current_type() != TOK_RBRACE) {
        body = push(body, parse_statement());
    }
    p_expect(TOK_RBRACE);
    
    return make_func(name, params, make_block(body));
}

fn parse_program(tokens: any) {
    p_tokens = tokens;
    p_pos = 0;
    
    let nodes = [];
    while (p_current_type() != TOK_EOF) {
        let cur_type = p_current_type();
        if (cur_type == TOK_FN) {
            nodes = push(nodes, parse_function());
        } else {
            // Assume it's a statement (let, etc)
            nodes = push(nodes, parse_statement());
        }
        
        // Prevent infinite loop if parser gets stuck
        if (p_pos > len(tokens) + 10) {
            print("Parse Error: Infinite loop detected at pos " + p_pos);
            return nodes;
        }
    }
    
    return nodes;
}

// =================== CODE GENERATOR (LLVM IR) ===================

let cg_output = "";
let cg_temp = 0;
let cg_label = 0;
let cg_vars = [];
let cg_var_names = [];
let cg_global_vars = []; // Track global variable names
let cg_strings = []; // [ [id, content], ... ]
let cg_str_id_counter = 0;
let cg_loop_cond_label = ""; // For continue
let cg_loop_end_label = "";  // For break

fn cg_is_global(name: string) {
    let i = 0;
    while (i < len(cg_global_vars)) {
        if (cg_global_vars[i] == name) { return true; }
        i = i + 1;
    }
    return false;
}

fn cg_emit(s: string) {
    cg_output = cg_output + "  " + s + "\n";
}

fn cg_emit_raw(s: string) {
    cg_output = cg_output + s + "\n";
}

fn cg_next_temp() {
    let t = "%t" + cg_temp;
    cg_temp = cg_temp + 1;
    return t;
}

fn cg_next_label() {
    let l = "L" + cg_label;
    cg_label = cg_label + 1;
    return l;
}

fn cg_find_var(name: string) {
    let i = 0;
    while (i < len(cg_var_names)) {
        if (cg_var_names[i] == name) {
            return cg_vars[i];
        }
        i = i + 1;
    }
    return null;
}

fn cg_add_var(name: string, ptr: string) {
    cg_var_names = push(cg_var_names, name);
    cg_vars = push(cg_vars, ptr);
}

fn cg_get_str_const(content: string) {
    // Check if exists
    let i = 0;
    while (i < len(cg_strings)) {
        let entry = cg_strings[i];
        if (entry[1] == content) {
            return "@.str." + entry[0];
        }
        i = i + 1;
    }
    // Add new
    let id = cg_str_id_counter;
    cg_str_id_counter = cg_str_id_counter + 1;
    let entry = [id, content];
    cg_strings = push(cg_strings, entry);
    return "@.str." + id;
}

fn cg_gen_expr(expr: any) {
    let node_type = expr[0];
    
    // Number literal - Tagged Integer format (n*2+1)
    // In Stage 0, parseInt returns raw value, so we tag it.
    // In Stage 1, parseInt returns already-tagged value, so we use it as-is.
    if (node_type == AST_NUM) {
        let n = expr[1];  // Could be raw or tagged depending on stage
        if (IS_STAGE1 == 1) {
            // n is already tagged from parseInt
            return "" + n;
        } else {
            // n is raw, need to tag it
            return "" + ((n * 2) + 1);
        }
    }
    
    // String Literal
    if (node_type == 30) { // AST_STR
        let s = expr[1];
        let str_ptr = cg_get_str_const(s);
        let t1 = cg_next_temp();
        let array_len = len(s) + 1;
        let cast = "getelementptr inbounds ([" + array_len + " x i8], [" + array_len + " x i8]* " + str_ptr + ", i64 0, i64 0)";
        // Fix: Call argon_str_new to create a valid Object from the raw C-string
        cg_emit(t1 + " = call i64 @argon_str_new(i8* " + cast + ")");
        return t1;
    }
    

    
    // Variable
    if (node_type == AST_VAR) {
        let name = expr[1];
        
        if (cg_is_global(name)) {
             let temp = cg_next_temp();
             cg_emit(temp + " = load i64, i64* @" + name);
             return temp;
        }
        
        let ptr = cg_find_var(name);
        if (ptr != null) {
            let temp = cg_next_temp();
            cg_emit(temp + " = load i64, i64* " + ptr);
            return temp;
        }
        return "0";
    }
    
    // Binary operation
    if (node_type == AST_BINOP) {
        let op = expr[1];
        let left = expr[2];
        let right = expr[3];
        
        let l = cg_gen_expr(left);
        let r = cg_gen_expr(right);
        let res = cg_next_temp();
        
        // OPTIMIZATION: Fast Path for Integers
        // Operations: +, -, <, >, ==
        let can_opt = false;
        if (op == "+") { can_opt = true; }
        else if (op == "-") { can_opt = true; }
        else if (op == "<") { can_opt = true; }
        else if (op == ">") { can_opt = true; }
        else if (op == "==") { can_opt = true; }
        
        if (can_opt) {
             let label_fast = cg_next_label();
             let label_slow = cg_next_label();
             let label_done = cg_next_label();
             
             // Check if both are integers: (left & right & 1) == 1
             let t1 = cg_next_temp();
             let t2 = cg_next_temp();
             let t3 = cg_next_temp();
             cg_emit(t1 + " = and i64 " + l + ", " + r);
             cg_emit(t2 + " = and i64 " + t1 + ", 1");
             
             if (OPT_UNSAFE == 1) {
                 cg_emit("br label %" + label_fast);
             } else {
                 cg_emit(t3 + " = icmp eq i64 " + t2 + ", 1");
                 let t3_ex = cg_next_temp();
                 cg_emit(t3_ex + " = call i1 @llvm.expect.i1(i1 " + t3 + ", i1 1)");
                 cg_emit("br i1 " + t3_ex + ", label %" + label_fast + ", label %" + label_slow);
             }
             
             // --- FAST PATH (Native Instructions) ---
             cg_emit_raw("\n" + label_fast + ":");
             let res_fast = cg_next_temp();
             
             if (op == "+") {
                 // (2n+1) + (2m+1) - 1 = 2(n+m) + 1
                 let t_add = cg_next_temp();
                 cg_emit(t_add + " = add i64 " + l + ", " + r);
                 cg_emit(res_fast + " = sub i64 " + t_add + ", 1");
             }
             else if (op == "-") {
                 // (2n+1) - (2m+1) + 1 = 2(n-m) + 1
                 let t_sub = cg_next_temp();
                 cg_emit(t_sub + " = sub i64 " + l + ", " + r);
                 cg_emit(res_fast + " = add i64 " + t_sub + ", 1");
             }
             else if (op == "==") {
                  let t_cmp = cg_next_temp();
                  cg_emit(t_cmp + " = icmp eq i64 " + l + ", " + r);
                  cg_emit(res_fast + " = select i1 " + t_cmp + ", i64 3, i64 1");
             }
             else if (op == "<") {
                  let t_cmp = cg_next_temp();
                  cg_emit(t_cmp + " = icmp slt i64 " + l + ", " + r);
                  cg_emit(res_fast + " = select i1 " + t_cmp + ", i64 3, i64 1");
             }
             else if (op == ">") {
                  let t_cmp = cg_next_temp();
                  cg_emit(t_cmp + " = icmp sgt i64 " + l + ", " + r);
                  cg_emit(res_fast + " = select i1 " + t_cmp + ", i64 3, i64 1");
             }
             cg_emit("br label %" + label_done);
             
             // --- SLOW PATH (Function Call) ---
             cg_emit_raw("\n" + label_slow + ":");
             let target = "";
             if (op == "+") { target = "argon_add"; }
             else if (op == "-") { target = "argon_sub"; }
             else if (op == "<") { target = "argon_lt"; }
             else if (op == ">") { target = "argon_gt"; }
             else if (op == "==") { target = "argon_eq"; }
             
             let res_slow = cg_next_temp();
             cg_emit(res_slow + " = call i64 @" + target + "(i64 " + l + ", i64 " + r + ")");
             cg_emit("br label %" + label_done);
             
             // --- MERGE ---
             cg_emit_raw("\n" + label_done + ":");
             let final_res = cg_next_temp();
             cg_emit(final_res + " = phi i64 [ " + res_fast + ", %" + label_fast + " ], [ " + res_slow + ", %" + label_slow + " ]");
             return final_res;
        }

        let target = "";
        if (op == "*") { target = "argon_mul"; }
        else if (op == "/") { target = "argon_div"; }
        
        if (target != "") {
             cg_emit(res + " = call i64 @" + target + "(i64 " + l + ", i64 " + r + ")");
             return res;
        }
        
        if (op == "!=") {
             let eq_res = cg_next_temp();
             cg_emit(eq_res + " = call i64 @argon_eq(i64 " + l + ", i64 " + r + ")");
             cg_emit(res + " = xor i64 " + eq_res + ", 2");
             return res;
        }
        
        if (op == "<=") {
             let lt_res = cg_next_temp();
             let eq_res = cg_next_temp();
             cg_emit(lt_res + " = call i64 @argon_lt(i64 " + l + ", i64 " + r + ")");
             cg_emit(eq_res + " = call i64 @argon_eq(i64 " + l + ", i64 " + r + ")");
             cg_emit(res + " = or i64 " + lt_res + ", " + eq_res);
             return res;
        }
        
        if (op == ">=") {
             let gt_res = cg_next_temp();
             let eq_res = cg_next_temp();
             cg_emit(gt_res + " = call i64 @argon_gt(i64 " + l + ", i64 " + r + ")");
             cg_emit(eq_res + " = call i64 @argon_eq(i64 " + l + ", i64 " + r + ")");
             cg_emit(res + " = or i64 " + gt_res + ", " + eq_res);
             return res;
        }
        
        return "0";
    }
    
    // Function call
    if (node_type == AST_CALL) {
        let name = expr[1];
        let args = expr[2];
        let res = cg_next_temp();
        
        // Map intrinsics (Restored for compat)
        let target = name;
        if (name == "len") { target = "argon_len"; }
        else if (name == "push") { target = "argon_push"; }
        else if (name == "charCodeAt") { target = "argon_char_code_at"; }
        else if (name == "parseInt") { target = "argon_parse_int"; }
        else if (name == "readFile") { target = "argon_read_file"; }
        else if (name == "writeFile") { target = "argon_write_file"; }
        else if (name == "fileExists") { target = "argon_file_exists"; }
        else if (name == "getArgs") { target = "argon_get_args"; }
        
        let arg_str = "";
        let i = 0;
        while (i < len(args)) {
             if (i > 0) { arg_str = arg_str + ", "; }
             let val = cg_gen_expr(args[i]);
             arg_str = arg_str + "i64 " + val;
             i = i + 1;
        }
        
        cg_emit(res + " = call i64 @" + target + "(" + arg_str + ")");
        return res;
    }
    
    // Array literal
    if (node_type == 31) { // AST_ARRAY
        let items = expr[1];
        let arr = cg_next_temp();
        cg_emit(arr + " = call i64 @argon_arr_new()");
        
        let i = 0;
        while (i < len(items)) {
            let item = items[i];
            let val = cg_gen_expr(item);
            // push returns new len, ignore it.
            let dummy = cg_next_temp();
            cg_emit(dummy + " = call i64 @argon_push(i64 " + arr + ", i64 " + val + ")");
            i = i + 1;
        }
        return arr;
    }
    
    return "0";
}

fn cg_gen_stmt(stmt: any) {
    let node_type = stmt[0];
    
    // Let statement
    if (node_type == AST_LET) {
        let name = stmt[1];
        let init = stmt[2];
        let val = cg_gen_expr(init);
        
        // This is local let, alloc stack
        let ptr = "%" + name + ".ptr." + cg_temp;
        cg_temp = cg_temp + 1;
        
        cg_emit(ptr + " = alloca i64");
        cg_emit("store i64 " + val + ", i64* " + ptr);
        
        cg_add_var(name, ptr);
        return;
    }
    
    // Assignment
    if (node_type == AST_ASSIGN) {
        let name = stmt[1];
        let val_expr = stmt[2];
        let val = cg_gen_expr(val_expr);
        
        if (cg_is_global(name)) {
            cg_emit("store i64 " + val + ", i64* @" + name);
        } else {
            let ptr = cg_find_var(name);
            if (ptr != null) {
                cg_emit("store i64 " + val + ", i64* " + ptr);
            }
        }
        return;
    }
    
    // Print statement
    if (node_type == AST_PRINT) {
        let expr = stmt[1];
        let val = cg_gen_expr(expr);
        
        // Use argon_print which handles all Argon value types
        cg_emit("call void @argon_print(i64 " + val + ")");
        return;
    }
    
    // Return statement
    if (node_type == AST_RETURN) {
        let expr = stmt[1];
        
        // TAIL CALL OPTIMIZATION
        if (expr[0] == AST_CALL) {
             let name = expr[1];
             let args = expr[2];
             
             let arg_str = "";
             let i = 0;
             while (i < len(args)) {
                  if (i > 0) { arg_str = arg_str + ", "; }
                  let val = cg_gen_expr(args[i]);
                  arg_str = arg_str + "i64 " + val;
                  i = i + 1;
             }
             
             let res = cg_next_temp();
             cg_emit(res + " = tail call i64 @" + name + "(" + arg_str + ")");
             cg_emit("ret i64 " + res);
             return;
        }
        
        let val = cg_gen_expr(expr);
        cg_emit("ret i64 " + val);
        return;
    }
    
    // While statement
    if (node_type == AST_WHILE) {
        let cond = stmt[1];
        let body = stmt[2];
        
        let cond_label = cg_next_label();
        let body_label = cg_next_label();
        let end_label = cg_next_label();
        
        // Save current loop labels for nested loops
        let saved_cond = cg_loop_cond_label;
        let saved_end = cg_loop_end_label;
        cg_loop_cond_label = cond_label;
        cg_loop_end_label = end_label;
        
        cg_emit("br label %" + cond_label);
        cg_emit_raw("\n" + cond_label + ":");
        
        // OPTIMIZATION: Condition Flow for specific comparisons
        let opt_while = false;
        if (cond[0] == 3) { // AST_BINOP
            let op = cond[1];
            if (op == "<") { opt_while = true; }
            else if (op == ">") { opt_while = true; }
            else if (op == "==") { opt_while = true; }
        }
        
        if (opt_while) {
            let op = cond[1];
            let left = cond[2];
            let right = cond[3];
            let l = cg_gen_expr(left);
            let r = cg_gen_expr(right);
            
            let label_fast = cg_next_label();
            let label_slow = cg_next_label();
            
            // Check types (both int?)
            let t1 = cg_next_temp();
            let t2 = cg_next_temp();
            let t3 = cg_next_temp();
            cg_emit(t1 + " = and i64 " + l + ", " + r);
            cg_emit(t2 + " = and i64 " + t1 + ", 1");
            
            if (OPT_UNSAFE == 1) {
                cg_emit("br label %" + label_fast);
            } else {
                cg_emit(t3 + " = icmp eq i64 " + t2 + ", 1");
                let t3_ex = cg_next_temp();
                cg_emit(t3_ex + " = call i1 @llvm.expect.i1(i1 " + t3 + ", i1 1)");
                cg_emit("br i1 " + t3_ex + ", label %" + label_fast + ", label %" + label_slow);
            }
            
            // FAST PATH: Direct Branching
            cg_emit_raw("\n" + label_fast + ":");
            let t_cmp = cg_next_temp();
            let cmp_instr = "icmp eq";
            if (op == "<") { cmp_instr = "icmp slt"; }
            if (op == ">") { cmp_instr = "icmp sgt"; }
            
            cg_emit(t_cmp + " = " + cmp_instr + " i64 " + l + ", " + r);
            cg_emit("br i1 " + t_cmp + ", label %" + body_label + ", label %" + end_label);
            
            // SLOW PATH: Fallback to runtime
            cg_emit_raw("\n" + label_slow + ":");
            let target = "argon_eq";
            if (op == "<") { target = "argon_lt"; }
            if (op == ">") { target = "argon_gt"; }
            
            let res_slow = cg_next_temp();
            cg_emit(res_slow + " = call i64 @" + target + "(i64 " + l + ", i64 " + r + ")");
            let slow_bool = cg_next_temp();
            cg_emit(slow_bool + " = icmp ne i64 " + res_slow + ", 1");
            cg_emit("br i1 " + slow_bool + ", label %" + body_label + ", label %" + end_label);
        
        } else {
            // Normal unoptimized condition
            let cond_val = cg_gen_expr(cond);
            let cond_bool = cg_next_temp();
            cg_emit(cond_bool + " = icmp ne i64 " + cond_val + ", 1");
            cg_emit("br i1 " + cond_bool + ", label %" + body_label + ", label %" + end_label);
        }
        
        cg_emit_raw("\n" + body_label + ":");
        let body_stmts = body[1];
        let i = 0;
        while (i < len(body_stmts)) {
            cg_gen_stmt(body_stmts[i]);
            i = i + 1;
        }
        cg_emit("br label %" + cond_label);
        
        cg_emit_raw("\n" + end_label + ":");
        
        // Restore saved loop labels
        cg_loop_cond_label = saved_cond;
        cg_loop_end_label = saved_end;
        return;
    }
    
    // Break statement
    if (node_type == AST_BREAK) {
        cg_emit("br label %" + cg_loop_end_label);
        // Need a new label for any code after break (unreachable)
        let after_break = cg_next_label();
        cg_emit_raw("\n" + after_break + ":");
        return;
    }
    
    // Continue statement
    if (node_type == AST_CONTINUE) {
        cg_emit("br label %" + cg_loop_cond_label);
        // Need a new label for any code after continue (unreachable)
        let after_continue = cg_next_label();
        cg_emit_raw("\n" + after_continue + ":");
        return;
    }
    
    // Expression statement (function call as statement)
    if (node_type == AST_CALL) {
        // Just evaluate the expression for its side effects
        cg_gen_expr(stmt);
        return;
    }
    
    // If statement
    if (node_type == AST_IF) {
        let cond = stmt[1];
        let then_block = stmt[2];
        let else_block = stmt[3];
        
        let then_label = cg_next_label();
        let else_label = cg_next_label();
        let end_label = cg_next_label();
        
        let cond_val = cg_gen_expr(cond);
        let cond_bool = cg_next_temp();
        cg_emit(cond_bool + " = icmp ne i64 " + cond_val + ", 1");
        cg_emit("br i1 " + cond_bool + ", label %" + then_label + ", label %" + else_label);
        
        cg_emit_raw("\n" + then_label + ":");
        let then_stmts = then_block[1];
        let ti = 0;
        while (ti < len(then_stmts)) {
            cg_gen_stmt(then_stmts[ti]);
            ti = ti + 1;
        }
        cg_emit("br label %" + end_label);
        
        cg_emit_raw("\n" + else_label + ":");
        let else_stmts = else_block[1];
        let ei = 0;
        while (ei < len(else_stmts)) {
            cg_gen_stmt(else_stmts[ei]);
            ei = ei + 1;
        }
        cg_emit("br label %" + end_label);
        
        cg_emit_raw("\n" + end_label + ":");
        return;
    }
}

fn cg_gen_param_str(params: any) {
    let res = "";
    let i = 0;
    while (i < len(params)) {
        if (i > 0) { res = res + ", "; }
        res = res + "i64 %arg" + i;
        i = i + 1;
    }
    return res;
}

fn escape_llvm(s: string) {
    let res = "";
    let i = 0;
    while (i < len(s)) {
        let c = s[i];
        if (c == "\n") { res = res + "\\0A"; }
        else if (c == "\t") { res = res + "\\09"; }
        else if (c == "\r") { res = res + "\\0D"; }
        else if (is_quote(c)) { res = res + "\\22"; }
        else if (is_backslash(c)) { res = res + "\\5C"; }
        else { 
            res = res + c;
        }
        i = i + 1;
    }
    return res;
}

fn cg_generate(nodes: any) {
    cg_output = "";
    cg_strings = [];
    cg_str_id_counter = 0;
    
    // 1. Collect Globals and Generate Declarations
    cg_global_vars = [];
    let globals_decl = "";
    
    let i = 0;
    while (i < len(nodes)) {
        let node = nodes[i];
        if (node[0] == 10) { // AST_LET
            let name = node[1];
            cg_global_vars = push(cg_global_vars, name);
            globals_decl = globals_decl + "@" + name + " = global i64 0\n";
        }
        i = i + 1;
    }
    
    // 2. Generate __init_globals
    // Reset temp counters
    cg_temp = 0;
    cg_label = 0;
    cg_vars = [];
    cg_var_names = [];
    
    if (len(cg_global_vars) > 0) {
        cg_emit_raw("define void @__init_globals() {");
        cg_emit_raw("entry:");
        
        i = 0;
        while (i < len(nodes)) {
            let node = nodes[i];
            if (node[0] == 10) { // AST_LET
                 let name = node[1];
                 let init = node[2];
                 // Generate init value
                 let val = cg_gen_expr(init);
                 cg_emit("store i64 " + val + ", i64* @" + name);
            }
            i = i + 1;
        }
        
        cg_emit("ret void");
        cg_emit_raw("}");
        cg_emit_raw("");
    }
    
    // 3. Generate Functions
    i = 0;
    while (i < len(nodes)) {
        let node = nodes[i];
        if (node[0] == 20) { // AST_FUNC
            let name = node[1];
            let params = node[2];
            let body = node[3];
            
            // Inline function generation logic to access params correctly
            // Reset local state for function
            cg_temp = 0;
            cg_label = 0;
            cg_vars = [];
            cg_var_names = [];
            
            if (name == "main") {
                cg_emit_raw("define i32 @main(i32 %argc, i8** %argv) {");
                cg_emit_raw("entry:");
                
                // Call globals init
                if (len(cg_global_vars) > 0) {
                    cg_emit("call void @__init_globals()");
                }
                
                let stmts = body[1];
                let j = 0;
                while (j < len(stmts)) {
                    cg_gen_stmt(stmts[j]);
                    j = j + 1;
                }
                cg_emit("ret i32 0");
                cg_emit_raw("}");
            } else {
                let param_str = cg_gen_param_str(params);
                cg_emit_raw("define i64 @" + name + "(" + param_str + ") {");
                cg_emit_raw("entry:");
                
                // Allow stack allocation for params
                let k = 0;
                while (k < len(params)) {
                    let pname = params[k];
                    let ptr = "%" + pname + ".ptr";
                    cg_emit(ptr + " = alloca i64");
                    cg_emit("store i64 %arg" + k + ", i64* " + ptr);
                    cg_add_var(pname, ptr);
                    k = k + 1;
                }
                
                let stmts = body[1];
                let j = 0;
                while (j < len(stmts)) {
                    cg_gen_stmt(stmts[j]);
                    j = j + 1;
                }
                // Implicit return 0
                cg_emit("ret i64 0");
                cg_emit_raw("}");
            }
            cg_emit_raw("");
        }
        i = i + 1;
    }
    
    let body_code = cg_output;
    cg_output = ""; // Reset for header
    
    // 4. Generate Header
    cg_emit_raw("; Argon Self-Hosted Compiler Output");
    cg_emit_raw("; Generated by compiler.argon");
    cg_emit_raw("");
    cg_emit_raw("declare i32 @printf(i8*, ...)");
    cg_emit_raw("declare i64 @argon_get(i64, i64)");
    cg_emit_raw("declare i64 @argon_set(i64, i64, i64)");
    cg_emit_raw("declare i64 @argon_arr_new()");
    cg_emit_raw("declare i64 @argon_push(i64, i64)");
    cg_emit_raw("declare i64 @argon_str_new(i8*)");
    cg_emit_raw("declare i64 @argon_add(i64, i64)");
    cg_emit_raw("declare i64 @argon_sub(i64, i64)");
    cg_emit_raw("declare i64 @argon_mul(i64, i64)");
    cg_emit_raw("declare i64 @argon_div(i64, i64)");
    cg_emit_raw("declare i64 @argon_lt(i64, i64)");
    cg_emit_raw("declare i64 @argon_gt(i64, i64)");
    cg_emit_raw("declare i64 @argon_eq(i64, i64)");
    cg_emit_raw("declare i1 @llvm.expect.i1(i1, i1)");
    cg_emit_raw("declare i64 @argon_len(i64)");
    cg_emit_raw("declare void @argon_print(i64)");
    cg_emit_raw("declare i64 @argon_get_args()");
    cg_emit_raw("declare i64 @argon_read_file(i64)");
    cg_emit_raw("declare i64 @argon_write_file(i64, i64)");
    cg_emit_raw("declare i64 @argon_listen(i64)");
    cg_emit_raw("declare i64 @argon_accept(i64)");
    cg_emit_raw("declare i64 @argon_socket_read(i64)");
    cg_emit_raw("declare i64 @argon_socket_write(i64, i64)");
    cg_emit_raw("declare i64 @argon_socket_close(i64)");
    cg_emit_raw("declare i64 @argon_file_exists(i64)");
    cg_emit_raw("declare i64 @argon_char_code_at(i64, i64)");
    cg_emit_raw("declare i64 @argon_parse_int(i64)");
    // Multi-threading (v2.3)
    cg_emit_raw("declare i64 @argon_thread_spawn(i64)");
    cg_emit_raw("declare i64 @argon_thread_join(i64)");
    cg_emit_raw("declare i64 @argon_mutex_new()");
    cg_emit_raw("declare i64 @argon_mutex_lock(i64)");
    cg_emit_raw("declare i64 @argon_mutex_unlock(i64)");
    cg_emit_raw("declare i64 @argon_atomic_new(i64)");
    cg_emit_raw("declare i64 @argon_atomic_load(i64)");
    cg_emit_raw("declare i64 @argon_atomic_store(i64, i64)");
    cg_emit_raw("declare i64 @argon_atomic_add(i64, i64)");
    cg_emit_raw("declare i64 @argon_atomic_cas(i64, i64, i64)");
    cg_emit_raw("declare i64 @argon_sleep(i64)");
    cg_emit_raw("@.str.int = private constant [5 x i8] c\"%ld\\0A\\00\"");
    cg_emit_raw("@.str.str = private constant [4 x i8] c\"%s\\0A\\00\"");
    
    cg_emit_raw(globals_decl);
    

    
    // 5. String Constants
    i = 0;
    while (i < len(cg_strings)) {
        let entry = cg_strings[i];
        let id_name = entry[0];
        let content = entry[1];
        let esc = escape_llvm(content);
        cg_emit_raw("@.str." + id_name + " = private constant [" + (len(content)+1) + " x i8] c\"" + esc + "\\00\"");
        i = i + 1;
    }
    
    cg_emit_raw("");
    cg_output = cg_output + body_code;
    return cg_output;
}

// =================== MAIN COMPILER ===================

fn compile_file(filename: string) {
    print("========================================");
    print("  ARGON SELF-HOSTING COMPILER v2.3");
    print("  Written 100% in Argon Language");
    print("========================================");
    print("");
    print("Compiling: " + filename);
    
    if (fileExists(filename) == false) {
        print("Error: File not found");
        return;
    }
    
    let source = readFile(filename);
    print("Source size: " + len(source) + " bytes");
    print("");
    
    // Phase 1: Lexical Analysis
    print("[1/3] Lexical Analysis...");
    let tokens = tokenize(source);
    print("      Generated " + len(tokens) + " tokens");
    
    // Phase 2: Parsing
    print("[2/3] Parsing...");
    let ast = parse_program(tokens);
    print("      Parsed " + len(ast) + " functions");
    
    // Phase 3: Code Generation
    print("[3/3] Code Generation (LLVM IR)...");
    let llvm_ir = cg_generate(ast);
    print("      Generated " + len(llvm_ir) + " bytes of LLVM IR");
    print("");
    
    // Write output
    let output_file = filename + ".ll";
    writeFile(output_file, llvm_ir);
    print("Output written to: " + output_file);
    print("");
    print("========================================");
    print("  COMPILATION COMPLETE!");
    print("========================================");
}

// =================== ENTRY POINT ===================

fn main() {
    detect_stage(); // Detect if running in Stage 0 or Stage 1
    let args = getArgs();
    let num_args = len(args);
    let target_file = "self-host/test_input.argon";
    let i = 1; // skip 0 (program name)
    
    while (i < num_args) {
        let arg = args[i];
        if (arg == "--unsafe-math") {
            OPT_UNSAFE = 1;
        } else {
            target_file = arg;
        }
        i = i + 1;
    }
    
    compile_file(target_file);
}
