// ============================================
// ARGON SELF-HOSTING COMPILER v2.16.0
// Written entirely in Argon
// Complete Lexer, Parser, and Code Generator
// With Generics, REPL, Structs, Enums & Match
// ============================================

let OPT_UNSAFE = 0; // Optimization flag

// =================== GENERICS (Phase 2) ===================
// Storage for generic function templates
// Format: [[name, type_params, params, body], ...]
let generic_funcs = [];

// Storage for instantiation requests
// Format: [[generic_name, type_args, mangled_name], ...]
let instantiations = [];

// Already generated specialized functions
let generated_specs = [];

// Stage detection: In Stage 0 (Rust), parseInt("1") = 1 (raw).
// In Stage 1 (compiled), parseInt("1") = 3 (tagged: 1*2+1).
// So if parseInt("1") > 2, we're in Stage 1.
let IS_STAGE1 = 0;
fn detect_stage() {
    let test = parseInt("1");
    if (test > 2) {
        IS_STAGE1 = 1;
    }
}

// =================== TOKEN TYPE CONSTANTS ===================

let TOK_EOF = 0;
let TOK_FN = 1;
let TOK_LET = 2;
let TOK_RETURN = 3;
let TOK_IF = 4;
let TOK_ELSE = 5;
let TOK_WHILE = 6;
let TOK_PRINT = 7;
let TOK_TRUE = 8;
let TOK_FALSE = 9;
let TOK_ID = 10;
let TOK_NUM = 11;
let TOK_STR = 12;
let TOK_PLUS = 20;
let TOK_MINUS = 21;
let TOK_STAR = 22;
let TOK_SLASH = 23;
let TOK_LPAREN = 30;
let TOK_RPAREN = 31;
let TOK_LBRACE = 32;
let TOK_RBRACE = 33;
let TOK_LBRACK = 34;
let TOK_RBRACK = 35;
let TOK_EQ = 40;
let TOK_EQEQ = 41;
let TOK_LT = 42;
let TOK_GT = 43;
let TOK_SEMI = 50;
let TOK_COMMA = 51;
let TOK_COLON = 52;
let TOK_BREAK = 54;
let TOK_CONTINUE = 55;
let TOK_STRUCT = 56;
let TOK_ENUM = 58;
let TOK_MATCH = 59;
let TOK_ARROW = 61;
let TOK_IMPORT = 62;
let TOK_FROM = 63;
let TOK_NOT = 70;

// =================== LEXER ===================

fn is_digit(ch: string) {
    if (ch == "0") { return true; }
    if (ch == "1") { return true; }
    if (ch == "2") { return true; }
    if (ch == "3") { return true; }
    if (ch == "4") { return true; }
    if (ch == "5") { return true; }
    if (ch == "6") { return true; }
    if (ch == "7") { return true; }
    if (ch == "8") { return true; }
    if (ch == "9") { return true; }
    return false;
}

fn is_letter(ch: string) {
    // lowercase a-z
    if (ch == "a") { return true; }
    if (ch == "b") { return true; }
    if (ch == "c") { return true; }
    if (ch == "d") { return true; }
    if (ch == "e") { return true; }
    if (ch == "f") { return true; }
    if (ch == "g") { return true; }
    if (ch == "h") { return true; }
    if (ch == "i") { return true; }
    if (ch == "j") { return true; }
    if (ch == "k") { return true; }
    if (ch == "l") { return true; }
    if (ch == "m") { return true; }
    if (ch == "n") { return true; }
    if (ch == "o") { return true; }
    if (ch == "p") { return true; }
    if (ch == "q") { return true; }
    if (ch == "r") { return true; }
    if (ch == "s") { return true; }
    if (ch == "t") { return true; }
    if (ch == "u") { return true; }
    if (ch == "v") { return true; }
    if (ch == "w") { return true; }
    if (ch == "x") { return true; }
    if (ch == "y") { return true; }
    if (ch == "z") { return true; }
    // uppercase A-Z
    if (ch == "A") { return true; }
    if (ch == "B") { return true; }
    if (ch == "C") { return true; }
    if (ch == "D") { return true; }
    if (ch == "E") { return true; }
    if (ch == "F") { return true; }
    if (ch == "G") { return true; }
    if (ch == "H") { return true; }
    if (ch == "I") { return true; }
    if (ch == "J") { return true; }
    if (ch == "K") { return true; }
    if (ch == "L") { return true; }
    if (ch == "M") { return true; }
    if (ch == "N") { return true; }
    if (ch == "O") { return true; }
    if (ch == "P") { return true; }
    if (ch == "Q") { return true; }
    if (ch == "R") { return true; }
    if (ch == "S") { return true; }
    if (ch == "T") { return true; }
    if (ch == "U") { return true; }
    if (ch == "V") { return true; }
    if (ch == "W") { return true; }
    if (ch == "X") { return true; }
    if (ch == "Y") { return true; }
    if (ch == "Z") { return true; }
    // underscore
    if (ch == "_") { return true; }
    return false;
}

fn is_alnum(ch: string) {
    if (is_letter(ch)) { return true; }
    if (is_digit(ch)) { return true; }
    return false;
}

// Helper to check if char is double quote (ASCII 34)
fn is_quote(ch: string) {
    // Compare with escaped quote character
    if (ch == "\"") { return true; }
    return false;
}

// Helper to check if char is backslash (ASCII 92)  
fn is_backslash(ch: string) {
    // Compare with escaped backslash character
    if (ch == "\\") { return true; }
    return false;
}

fn is_whitespace(c: string) {
    if (c == " ") { return true; }
    if (c == "\n") { return true; }
    if (c == "\t") { return true; }
    if (c == "\r") { return true; }
    return false;
}

// Token structure: [type, value]
fn make_token(typ: int, val: string) {
    return [typ, val];
}

fn tokenize(source: string) {
    let tokens = [];
    let pos = 0;
    let n = len(source);
    
    while (pos < n) {
        let c = source[pos];
        
        // Skip whitespace
        if (is_whitespace(c)) {
            pos = pos + 1;
        }
        // Skip comments
        else if (c == "/") {
            if (pos + 1 < n) {
                if (source[pos + 1] == "/") {
                    // Skip until end of line
                    pos = pos + 2;
                    let in_comment = 1;
                    while (in_comment == 1) {
                        if (pos < n) {
                            if (source[pos] == "\n") {
                                pos = pos + 1;
                                in_comment = 0;
                            } else {
                                pos = pos + 1;
                            }
                        } else {
                            in_comment = 0;
                        }
                    }
                } else {
                    tokens = push(tokens, make_token(TOK_SLASH, "/"));
                    pos = pos + 1;
                }
            } else {
                tokens = push(tokens, make_token(TOK_SLASH, "/"));
                pos = pos + 1;
            }
        }
        // String literals
        else if (is_quote(c)) {
            pos = pos + 1;
            let str_val = "";
            let str_done = 0;
            while (str_done == 0) {
                if (pos < n) {
                    let sc = source[pos];
                    if (is_backslash(sc)) {
                        // Backslash - escape sequence
                        pos = pos + 1;
                        if (pos < n) {
                            let esc = source[pos];
                            if (esc == "n") { str_val = str_val + "\n"; }
                            else if (esc == "t") { str_val = str_val + "\t"; }
                            else if (esc == "r") { str_val = str_val + "\r"; }
                            else if (is_quote(esc)) { str_val = str_val + "\""; }
                            else if (is_backslash(esc)) { str_val = str_val + "\\"; }
                            else if (esc == "0") { str_val = str_val + "\0"; }
                            else { str_val = str_val + esc; }
                            pos = pos + 1;
                        } else {
                            str_done = 1;
                        }
                    } else if (is_quote(sc)) {
                        pos = pos + 1;
                        str_done = 1;
                    } else {
                        str_val = str_val + sc;
                        pos = pos + 1;
                    }
                } else {
                    str_done = 1;
                }
            }
            tokens = push(tokens, make_token(TOK_STR, str_val));
        }
        // Single char tokens
        else if (c == "+") { tokens = push(tokens, make_token(TOK_PLUS, "+")); pos = pos + 1; }
        else if (c == "-") { tokens = push(tokens, make_token(TOK_MINUS, "-")); pos = pos + 1; }
        else if (c == "*") { tokens = push(tokens, make_token(TOK_STAR, "*")); pos = pos + 1; }
        else if (c == "(") { tokens = push(tokens, make_token(TOK_LPAREN, "(")); pos = pos + 1; }
        else if (c == ")") { tokens = push(tokens, make_token(TOK_RPAREN, ")")); pos = pos + 1; }
        else if (c == "{") { tokens = push(tokens, make_token(TOK_LBRACE, "{")); pos = pos + 1; }
        else if (c == "}") { tokens = push(tokens, make_token(TOK_RBRACE, "}")); pos = pos + 1; }
        else if (c == "[") { tokens = push(tokens, make_token(TOK_LBRACK, "[")); pos = pos + 1; }
        else if (c == "]") { tokens = push(tokens, make_token(TOK_RBRACK, "]")); pos = pos + 1; }
        else if (c == ";") { tokens = push(tokens, make_token(TOK_SEMI, ";")); pos = pos + 1; }
        else if (c == ",") { tokens = push(tokens, make_token(TOK_COMMA, ",")); pos = pos + 1; }
        else if (c == ":") { tokens = push(tokens, make_token(TOK_COLON, ":")); pos = pos + 1; }
        else if (c == ".") { tokens = push(tokens, make_token(53, ".")); pos = pos + 1; }
        // Two-char tokens
        else if (c == "=") {
            if (pos + 1 < n) {
                if (source[pos + 1] == "=") {
                    tokens = push(tokens, make_token(TOK_EQEQ, "=="));
                    pos = pos + 2;
                } else if (source[pos + 1] == ">") {
                    tokens = push(tokens, make_token(TOK_ARROW, "=>"));
                    pos = pos + 2;
                } else {
                    tokens = push(tokens, make_token(TOK_EQ, "="));
                    pos = pos + 1;
                }
            } else {
                tokens = push(tokens, make_token(TOK_EQ, "="));
                pos = pos + 1;
            }
        }
        else if (c == "!") {
            if (pos + 1 < n) {
                if (source[pos + 1] == "=") {
                    tokens = push(tokens, make_token(44, "!="));
                    pos = pos + 2;
                } else {
                    // Single ! is NOT operator
                    tokens = push(tokens, make_token(70, "!"));
                    pos = pos + 1;
                }
            } else {
                tokens = push(tokens, make_token(70, "!"));
                pos = pos + 1;
            }
        }
        else if (c == "<") { 
            if (pos + 1 < n) {
                if (source[pos + 1] == "=") {
                    tokens = push(tokens, make_token(45, "<="));
                    pos = pos + 2;
                } else {
                    tokens = push(tokens, make_token(TOK_LT, "<")); 
                    pos = pos + 1; 
                }
            } else {
                tokens = push(tokens, make_token(TOK_LT, "<")); 
                pos = pos + 1; 
            }
        }
        else if (c == ">") { 
            if (pos + 1 < n) {
                if (source[pos + 1] == "=") {
                    tokens = push(tokens, make_token(46, ">="));
                    pos = pos + 2;
                } else {
                    tokens = push(tokens, make_token(TOK_GT, ">")); 
                    pos = pos + 1; 
                }
            } else {
                tokens = push(tokens, make_token(TOK_GT, ">")); 
                pos = pos + 1; 
            }
        }
        // Numbers
        else if (is_digit(c)) {
            let num_str = "";
            let num_done = 0;
            while (num_done == 0) {
                if (pos < n) {
                    let dc = source[pos];
                    if (is_digit(dc)) {
                        num_str = num_str + dc;
                        pos = pos + 1;
                    } else {
                        num_done = 1;
                    }
                } else {
                    num_done = 1;
                }
            }
            tokens = push(tokens, make_token(TOK_NUM, num_str));
        }
        // Identifiers & Keywords
        else if (is_letter(c)) {
            let id_str = "";
            let id_done = 0;
            while (id_done == 0) {
                if (pos < n) {
                    let ic = source[pos];
                    if (is_alnum(ic)) {
                        id_str = id_str + ic;
                        pos = pos + 1;
                    } else {
                        id_done = 1;
                    }
                } else {
                    id_done = 1;
                }
            }
            // Check keywords
            if (id_str == "fn") { tokens = push(tokens, make_token(TOK_FN, "fn")); }
            else if (id_str == "let") { tokens = push(tokens, make_token(TOK_LET, "let")); }
            else if (id_str == "return") { tokens = push(tokens, make_token(TOK_RETURN, "return")); }
            else if (id_str == "if") { tokens = push(tokens, make_token(TOK_IF, "if")); }
            else if (id_str == "else") { tokens = push(tokens, make_token(TOK_ELSE, "else")); }
            else if (id_str == "while") { tokens = push(tokens, make_token(TOK_WHILE, "while")); }
            else if (id_str == "print") { tokens = push(tokens, make_token(TOK_PRINT, "print")); }
            else if (id_str == "true") { tokens = push(tokens, make_token(TOK_TRUE, "true")); }
            else if (id_str == "false") { tokens = push(tokens, make_token(TOK_FALSE, "false")); }
            else if (id_str == "null") { tokens = push(tokens, make_token(60, "null")); }
            else if (id_str == "break") { tokens = push(tokens, make_token(TOK_BREAK, "break")); }
            else if (id_str == "continue") { tokens = push(tokens, make_token(TOK_CONTINUE, "continue")); }
            else if (id_str == "struct") { tokens = push(tokens, make_token(TOK_STRUCT, "struct")); }
            else if (id_str == "enum") { tokens = push(tokens, make_token(TOK_ENUM, "enum")); }
            else if (id_str == "match") { tokens = push(tokens, make_token(TOK_MATCH, "match")); }
            else if (id_str == "import") { tokens = push(tokens, make_token(TOK_IMPORT, "import")); }
            else if (id_str == "from") { tokens = push(tokens, make_token(TOK_FROM, "from")); }
            else { tokens = push(tokens, make_token(TOK_ID, id_str)); }
        }
        // Skip unknown
        else {
            pos = pos + 1;
        }
    }
    
    tokens = push(tokens, make_token(TOK_EOF, ""));
    return tokens;
}

// =================== AST NODE TYPES ===================

let AST_NUM = 1;
let AST_VAR = 2;
let AST_BINOP = 3;
let AST_CALL = 4;
let AST_LET = 10;
let AST_ASSIGN = 11;
let AST_RETURN = 12;
let AST_PRINT = 13;
let AST_IF = 14;
let AST_WHILE = 15;
let AST_FUNC = 20;
let AST_BLOCK = 21;
let AST_BREAK = 22;
let AST_CONTINUE = 23;

// Struct-related AST types (using 100+ to avoid conflicts)
let AST_STRUCT_DEF = 100;
let AST_STRUCT_INST = 101;
let AST_FIELD_ACCESS = 102;
let AST_METHOD_CALL = 103;
let AST_ENUM_DEF = 110;
let AST_MATCH = 111;
let AST_IMPORT = 120;

// =================== PARSER ===================

// Parser state
let p_tokens = [];
let p_pos = 0;

fn p_current() {
    return p_tokens[p_pos];
}

fn p_current_type() {
    let tok = p_tokens[p_pos];
    return tok[0];
}

fn p_current_val() {
    let tok = p_tokens[p_pos];
    return tok[1];
}

fn p_advance() {
    p_pos = p_pos + 1;
}

fn p_match(t: int) {
    if (p_current_type() == t) {
        p_advance();
        return true;
    }
    return false;
}

fn p_expect(t: int) {
    if (p_current_type() == t) {
        p_advance();
        return true;
    }
    print("Parse error: unexpected token. Expected type " + t + " got " + p_current_type() + " val " + p_current_val() + " at " + p_pos);
    return false;
}

// Node constructors
fn make_num(val: int) {
    return [AST_NUM, val];
}

fn make_var(name: string) {
    return [AST_VAR, name];
}

fn make_binop(op: string, left: any, right: any) {
    return [AST_BINOP, op, left, right];
}

fn make_call(name: string, args: any) {
    return [AST_CALL, name, args];
}

fn make_let(name: string, init: any) {
    return [AST_LET, name, init];
}

fn make_assign(name: string, val: any) {
    return [AST_ASSIGN, name, val];
}

fn make_print(expr: any) {
    return [AST_PRINT, expr];
}

fn make_return(expr: any) {
    return [AST_RETURN, expr];
}

fn make_if(cond: any, then_b: any, else_b: any) {
    return [AST_IF, cond, then_b, else_b];
}

fn make_while(cond: any, body: any) {
    return [AST_WHILE, cond, body];
}

fn make_func(name: string, params: any, body: any) {
    return [AST_FUNC, name, params, body];
}

fn make_block(stmts: any) {
    return [AST_BLOCK, stmts];
}

// Expression parsing (recursive descent)
fn parse_primary() {
    let t = p_current_type();
    let v = p_current_val();
    
    // NOT operator: !expr
    if (t == TOK_NOT) {
        p_advance();
        let not_expr = parse_primary();
        return [71, not_expr]; // AST_NOT = 71
    }
    
    // String literal
    if (t == TOK_STR) {
        p_advance();
        return [30, v]; // AST_STR = 30
    }
    
    // Array literal
    if (t == 34) { // TOK_LBRACK = 34
        p_advance();
        let items = [];
        if (p_current_type() != 35) { // TOK_RBRACK
            items = push(items, parse_expr());
            while (p_current_type() == TOK_COMMA) {
                p_advance();
                items = push(items, parse_expr());
            }
        }
        p_expect(35); // TOK_RBRACK
        return [31, items]; // AST_ARRAY = 31
    }

    // Number
    if (t == TOK_NUM) {
        p_advance();
        return make_num(parseInt(v));
    }
    // Variable, function call, struct instantiation, or field access
    if (t == TOK_ID) {
        let id_name = v;
        p_advance();
        
        // Check for struct instantiation: StructName { field: value, ... }
        if (p_current_type() == TOK_LBRACE) {
            p_advance(); // skip {
            let inst_fields = [];
            
            while (p_current_type() != TOK_RBRACE) {
                let inst_fname = p_current_val();
                p_advance();
                p_expect(TOK_COLON);
                let inst_fval = parse_expr();
                
                let inst_entry = [];
                inst_entry = push(inst_entry, inst_fname);
                inst_entry = push(inst_entry, inst_fval);
                inst_fields = push(inst_fields, inst_entry);
                
                if (p_current_type() == TOK_COMMA) {
                    p_advance();
                }
            }
            p_expect(TOK_RBRACE);
            return [101, id_name, inst_fields]; // AST_STRUCT_INST = 101
        }
        
        // Check for generic type arguments: func<int, string>(...)
        let call_type_args = [];
        if (p_current_type() == TOK_LT) {
            // Could be generic call OR comparison (a < b)
            // Heuristic: if followed by identifier/type and then > or ,, it's generic
            p_advance(); // skip <
            while (p_current_type() != TOK_GT) {
                call_type_args = push(call_type_args, p_current_val());
                p_advance(); // skip type arg
                if (p_current_type() == TOK_COMMA) {
                    p_advance();
                }
            }
            p_expect(TOK_GT);
            // Now check for ( - if present, it's a generic call
        }
        
        // Check for function call
        if (p_current_type() == TOK_LPAREN) {
            p_advance(); // skip (
            let call_args = [];
            
            if (p_current_type() != TOK_RPAREN) {
                call_args = push(call_args, parse_expr());
                while (p_current_type() == TOK_COMMA) {
                    p_advance();
                    call_args = push(call_args, parse_expr());
                }
            }
            p_expect(TOK_RPAREN);
            
            // If we have type args, this is a generic call
            if (len(call_type_args) > 0) {
                // Create mangled name: func_int_string
                let mangled = id_name;
                let ti = 0;
                while (ti < len(call_type_args)) {
                    mangled = mangled + "_" + call_type_args[ti];
                    ti = ti + 1;
                }
                
                // Record instantiation request
                let inst = [];
                inst = push(inst, id_name);
                inst = push(inst, call_type_args);
                inst = push(inst, mangled);
                instantiations = push(instantiations, inst);
                
                // Return call to mangled name
                return make_call(mangled, call_args);
            }
            
            return make_call(id_name, call_args);
        }
        
        // Check for index access [expr]
        if (p_current_type() == 34) { // TOK_LBRACK
            p_advance();
            let idx_expr = parse_expr();
            p_expect(35); // TOK_RBRACK
            let idx_args = [];
            idx_args = push(idx_args, make_var(id_name));
            idx_args = push(idx_args, idx_expr);
            return [AST_CALL, "argon_get", idx_args];
        }
        
        // Check for field access .field or method call .method()
        if (p_current_type() == 53) { // TOK_DOT = 53
            let base_obj = make_var(id_name);
            
            while (p_current_type() == 53) {
                p_advance(); // skip .
                let member_name = p_current_val();
                p_advance();
                
                // Check if this is a method call: .method()
                if (p_current_type() == TOK_LPAREN) {
                    p_advance(); // skip (
                    
                    // Collect method arguments
                    let method_args = [];
                    // First arg is always the object (self)
                    method_args = push(method_args, base_obj);
                    
                    if (p_current_type() != TOK_RPAREN) {
                        method_args = push(method_args, parse_expr());
                        while (p_current_type() == TOK_COMMA) {
                            p_advance();
                            method_args = push(method_args, parse_expr());
                        }
                    }
                    p_expect(TOK_RPAREN);
                    
                    // Create method call: [AST_CALL, "StructType_method", args]
                    // We need to figure out struct type from base_obj
                    // For now, use a special node AST_METHOD_CALL = 103
                    // which codegen will resolve
                    base_obj = [103, base_obj, member_name, method_args]; // AST_METHOD_CALL
                } else {
                    // Regular field access
                    base_obj = [102, base_obj, member_name]; // AST_FIELD_ACCESS
                }
            }
            
            // Check for array indexing after field access: obj.field[idx]
            while (p_current_type() == 34) { // TOK_LBRACK
                p_advance();
                let idx_expr = parse_expr();
                p_expect(35); // TOK_RBRACK
                let idx_args = [];
                idx_args = push(idx_args, base_obj);
                idx_args = push(idx_args, idx_expr);
                base_obj = [AST_CALL, "argon_get", idx_args];
            }
            
            return base_obj;
        }
        
        return make_var(id_name);
    }
    // Parenthesized expression
    if (t == TOK_LPAREN) {
        p_advance();
        let paren_expr = parse_expr();
        p_expect(TOK_RPAREN);
        return paren_expr;
    }
    // True/False literals
    if (t == TOK_TRUE) {
        p_advance();
        return make_num(1);
    }
    if (t == TOK_FALSE) {
        p_advance();
        return make_num(0);
    }
    
    // Null literal
    if (t == 60) { // TOK_NULL
        p_advance();
        return make_num(0);
    }
    
    // Match expression
    if (t == TOK_MATCH) {
        // print("DEBUG: Parsing MATCH");
        p_advance();
        // Parse target as simple variable/call, NOT full expr
        // (to avoid confusing match block { with struct instantiation)
        let match_target_name = p_current_val();
        p_advance();
        // Simple variable for now
        let match_expr = make_var(match_target_name);
        p_expect(TOK_LBRACE);
        
        let match_cases = [];
        while (p_current_type() != TOK_RBRACE) {
            // print("DEBUG: Parsing MATCH CASE");
            // Parse Pattern: ID or ID(var)
            let pat_typ = p_current_type();
            let pat_val = p_current_val();
            
            // For now, assume pattern is just ID (Enum Variant)
            // TODO: Handle numeric literals or other patterns
            p_expect(TOK_ID); 
            
            let pat_bind = "";
            // Check for binding: Variant(var_name)
            if (p_current_type() == TOK_LPAREN) {
                p_advance();
                pat_bind = p_current_val();
                p_expect(TOK_ID); // Variable name to bind
                p_expect(TOK_RPAREN);
            }
            
            p_expect(TOK_ARROW); // =>
            
            // Parse Body
            let case_body_stmts = [];
            if (p_current_type() == TOK_LBRACE) {
                p_advance();
                while (p_current_type() != TOK_RBRACE) {
                    case_body_stmts = push(case_body_stmts, parse_statement());
                }
                p_expect(TOK_RBRACE);
            } else {
                // Single statement/expression
                case_body_stmts = push(case_body_stmts, parse_statement());
            }
            
            let match_case = [];
            match_case = push(match_case, pat_val); // Pattern Name (Variant)
            match_case = push(match_case, pat_bind); // Bind Variable (or "")
            match_case = push(match_case, make_block(case_body_stmts)); // Body
            
            match_cases = push(match_cases, match_case);
            
            if (p_current_type() == TOK_COMMA) {
                p_advance();
            }
        }
        p_expect(TOK_RBRACE);
        return [111, match_expr, match_cases]; // AST_MATCH = 111
    }

    print("Parse error at primary: " + v);
    return make_num(0);
}

fn parse_factor() {
    let left = parse_primary();
    
    while (p_current_type() == TOK_STAR) {
        p_advance();
        let right = parse_primary();
        left = make_binop("*", left, right);
    }
    while (p_current_type() == TOK_SLASH) {
        p_advance();
        let right = parse_primary();
        left = make_binop("/", left, right);
    }
    
    return left;
}

fn parse_term() {
    let left = parse_factor();
    
    while (p_current_type() == TOK_PLUS) {
        p_advance();
        let right = parse_factor();
        left = make_binop("+", left, right);
    }
    while (p_current_type() == TOK_MINUS) {
        p_advance();
        let right = parse_factor();
        left = make_binop("-", left, right);
    }
    
    return left;
}

fn parse_comparison() {
    let left = parse_term();
    
    if (p_current_type() == TOK_LT) {
        p_advance();
        let right = parse_term();
        return make_binop("<", left, right);
    }
    if (p_current_type() == TOK_GT) {
        p_advance();
        let right = parse_term();
        return make_binop(">", left, right);
    }
    if (p_current_type() == TOK_EQEQ) {
        p_advance();
        let right = parse_term();
        return make_binop("==", left, right);
    }
    // Added
    if (p_current_type() == 44) { // TOK_NE (!=)
        p_advance();
        let right = parse_term();
        return make_binop("!=", left, right);
    }
    if (p_current_type() == 45) { // TOK_LE (<=)
        p_advance();
        let right = parse_term();
        return make_binop("<=", left, right);
    }
    if (p_current_type() == 46) { // TOK_GE (>=)
        p_advance();
        let right = parse_term();
        return make_binop(">=", left, right);
    }
    
    return left;
}

fn parse_expr() {
    return parse_comparison();
}

// Statement parsing
fn parse_statement() {
    let t = p_current_type();
    
    // let statement
    if (t == TOK_LET) {
        p_advance();
        let let_name = p_current_val();
        p_expect(TOK_ID);
        
        // Optional type annotation
        if (p_current_type() == TOK_COLON) {
            p_advance();
            p_advance(); // skip type
        }
        
        p_expect(TOK_EQ);
        let let_init = parse_expr();
        p_expect(TOK_SEMI);
        return make_let(let_name, let_init);
    }
    
    // print statement
    if (t == TOK_PRINT) {
        p_advance();
        p_expect(TOK_LPAREN);
        let print_arg = parse_expr();
        p_expect(TOK_RPAREN);
        p_expect(TOK_SEMI);
        return make_print(print_arg);
    }
    
    // return statement
    if (t == TOK_RETURN) {
        p_advance();
        let ret_expr = make_num(0);
        if (p_current_type() != TOK_SEMI) {
            ret_expr = parse_expr();
        }
        p_expect(TOK_SEMI);
        return make_return(ret_expr);
    }
    
    // if statement
    if (t == TOK_IF) {
        p_advance();
        p_expect(TOK_LPAREN);
        let cond = parse_expr();
        p_expect(TOK_RPAREN);
        p_expect(TOK_LBRACE);
        
        let then_stmts = [];
        while (p_current_type() != TOK_RBRACE) {
            then_stmts = push(then_stmts, parse_statement());
        }
        p_expect(TOK_RBRACE);
        
        let else_stmts = [];
        if (p_current_type() == TOK_ELSE) {
            p_advance();
            
            if (p_current_type() == TOK_IF) {
                // else if ... -> else { if ... }
                else_stmts = push(else_stmts, parse_statement());
            } else {
                p_expect(TOK_LBRACE);
                while (p_current_type() != TOK_RBRACE) {
                    else_stmts = push(else_stmts, parse_statement());
                }
                p_expect(TOK_RBRACE);
            }
        }
        
        return make_if(cond, make_block(then_stmts), make_block(else_stmts));
    }
    
    // while statement
    if (t == TOK_WHILE) {
        p_advance();
        p_expect(TOK_LPAREN);
        let cond = parse_expr();
        p_expect(TOK_RPAREN);
        p_expect(TOK_LBRACE);
        
        let body_stmts = [];
        while (p_current_type() != TOK_RBRACE) {
            body_stmts = push(body_stmts, parse_statement());
        }
        p_expect(TOK_RBRACE);
        
        return make_while(cond, make_block(body_stmts));
    }
    
    // break statement
    if (t == TOK_BREAK) {
        p_advance();
        p_expect(TOK_SEMI);
        return [AST_BREAK];
    }
    
    // continue statement
    if (t == TOK_CONTINUE) {
        p_advance();
        p_expect(TOK_SEMI);
        return [AST_CONTINUE];
    }

    // Match statement (expression used as statement)
    if (t == TOK_MATCH) {
        let match_expr = parse_expr();
        // Option: allow match without semicolon if likely block-like?
        // But parse_expr consumes it.
        // For now, Argon statements often require semicolons or implicitly handle block-likes.
        // If we treat it as expr, it might not require semi if it's the last thing?
        // Let's rely on standard expr stmt rule or specific rule.
        // Actually, parse_primary consumes match.
        // So here we need to call parse_expr.
        // But parse_expr calls parse_comparison -> parse_term -> parse_factor -> parse_primary.
        // So 'match' IS a primary.
        
        // However, parse_statement needs to Trigger on TOK_MATCH.
        // Since TOK_MATCH is NOT TOK_ID, it falls through to "Unexpected token".
        return match_expr;
    }
    
    // Assignment or expression statement
    if (t == TOK_ID) {
        let assign_name = p_current_val();
        p_advance();
        
        if (p_current_type() == TOK_EQ) {
            p_advance();
            let assign_val = parse_expr();
            p_expect(TOK_SEMI);
            return make_assign(assign_name, assign_val);
        }
        
        // Expression statement (function call)
        p_pos = p_pos - 1; // backtrack
        let stmt_expr = parse_expr();
        p_expect(TOK_SEMI);
        return stmt_expr;
    }
    
    print("Unexpected token in statement: " + p_current_val());
    p_advance();
    return make_num(0);
}

fn parse_function() {
    p_expect(TOK_FN);
    let fn_name = p_current_val();
    p_expect(TOK_ID);
    
    // Check for generic params: fn name<T, U>(...)
    let fn_type_params = [];
    if (p_current_type() == TOK_LT) {
        p_advance(); // skip <
        while (p_current_type() != TOK_GT) {
            fn_type_params = push(fn_type_params, p_current_val());
            p_advance(); // skip T
            if (p_current_type() == TOK_COMMA) {
                p_advance();
            }
        }
        p_expect(TOK_GT);
    }
    
    // Check for method definition: fn StructName.method_name(...)
    // If we see a dot, this is a method
    if (p_current_type() == 53) { // TOK_DOT = 53
        p_advance(); // skip .
        let method_name = p_current_val();
        p_expect(TOK_ID);
        // Mangle the name: StructName_method_name
        fn_name = fn_name + "_" + method_name;
    }
    
    p_expect(TOK_LPAREN);
    
    let fn_params = [];
    if (p_current_type() == TOK_ID) {
        fn_params = push(fn_params, p_current_val());
        p_advance();
        
        // Skip type annotation
        if (p_current_type() == TOK_COLON) {
            p_advance(); // skip :
            p_advance(); // skip type name
            // Skip generic type args: param: Box<int>
            if (p_current_type() == TOK_LT) {
                p_advance();
                while (p_current_type() != TOK_GT) {
                    p_advance();
                    if (p_current_type() == TOK_COMMA) { p_advance(); }
                }
                p_expect(TOK_GT);
            }
        }
        
        while (p_current_type() == TOK_COMMA) {
            p_advance();
            fn_params = push(fn_params, p_current_val());
            p_advance();
            if (p_current_type() == TOK_COLON) {
                p_advance(); // skip :
                p_advance(); // skip type name
                // Skip generic type args
                if (p_current_type() == TOK_LT) {
                    p_advance();
                    while (p_current_type() != TOK_GT) {
                        p_advance();
                        if (p_current_type() == TOK_COMMA) { p_advance(); }
                    }
                    p_expect(TOK_GT);
                }
            }
        }
    }
    p_expect(TOK_RPAREN);
    p_expect(TOK_LBRACE);
    
    let fn_body = [];
    while (p_current_type() != TOK_RBRACE) {
        fn_body = push(fn_body, parse_statement());
    }
    p_expect(TOK_RBRACE);
    
    // If this is a generic function, store it for later instantiation
    if (len(fn_type_params) > 0) {
        let gen_entry = [];
        gen_entry = push(gen_entry, fn_name);
        gen_entry = push(gen_entry, fn_type_params);
        gen_entry = push(gen_entry, fn_params);
        gen_entry = push(gen_entry, make_block(fn_body));
        generic_funcs = push(generic_funcs, gen_entry);
        // Return a placeholder - generic functions are not emitted directly
        return [130, fn_name, fn_type_params]; // AST_GENERIC_FUNC = 130
    }
    
    return make_func(fn_name, fn_params, make_block(fn_body));
}

fn parse_struct_def() {
    p_advance(); // skip 'struct'
    let struct_name = p_current_val();
    p_advance(); // skip name
    
    // START GENERIC PARAMS
    if (p_current_type() == TOK_LT) {
        p_advance(); // skip <
        while (p_current_type() != TOK_GT) {
            p_advance(); // skip T
            if (p_current_type() == TOK_COMMA) {
                p_advance();
            }
        }
        p_expect(TOK_GT); // skip >
    }
    // END GENERIC PARAMS

    p_expect(TOK_LBRACE);
    
    let struct_fields = [];
    while (p_current_type() != TOK_RBRACE) {
        let field_name = p_current_val();
        p_advance(); // field name
        p_expect(TOK_COLON);
        let field_type = p_current_val();
        p_advance(); // type
        
        // START GENERIC TYPE ARGS
        if (p_current_type() == TOK_LT) {
            p_advance(); // skip <
            while (p_current_type() != TOK_GT) {
                p_advance(); // skip type
                if (p_current_type() == TOK_COMMA) {
                    p_advance();
                }
            }
            p_expect(TOK_GT); // skip >
        }
        // END GENERIC TYPE ARGS
        
        let field_def = [];
        field_def = push(field_def, field_name);
        field_def = push(field_def, field_type);
        struct_fields = push(struct_fields, field_def);
        
        if (p_current_type() == TOK_COMMA) {
            p_advance();
        }
    }
    p_expect(TOK_RBRACE);
    
    return [100, struct_name, struct_fields]; // AST_STRUCT_DEF = 100
}

fn parse_enum_def() {
    p_advance(); // skip 'enum'
    let enum_name = p_current_val();
    p_advance(); // name
    p_expect(TOK_LBRACE);
    
    let enum_variants = [];
    while (p_current_type() != TOK_RBRACE) {
        let variant_name = p_current_val();
        p_advance(); // variant name
        
        // Optional params (just check syntax for now)
        let variant_has_data = 0;
        if (p_current_type() == TOK_LPAREN) {
            p_advance();
            // We only support single data field for now: Variant(Type)
            // or maybe just skip parsing types
            if (p_current_type() != TOK_RPAREN) {
                 p_advance(); // consume type/name
            }
            p_expect(TOK_RPAREN);
            variant_has_data = 1;
        }
        
        let variant_def = [];
        variant_def = push(variant_def, variant_name);
        variant_def = push(variant_def, variant_has_data);
        enum_variants = push(enum_variants, variant_def);
        
        if (p_current_type() == TOK_COMMA) {
            p_advance();
        }
    }
    p_expect(TOK_RBRACE);
    
    return [110, enum_name, enum_variants]; // AST_ENUM_DEF = 110
}

fn parse_program(tokens: any) {
    p_tokens = tokens;
    p_pos = 0;
    
    let xz_nodes = [];
    while (p_current_type() != TOK_EOF) {
        let xz_cur_type = p_current_type();
        // DEBUG: print("Top token: " + p_current_val() + " (" + xz_cur_type + ")");
        
        if (xz_cur_type == 1) { // TOK_FN = 1
            let xz_fn = parse_function();
            xz_nodes = push(xz_nodes, xz_fn);
        } else if (xz_cur_type == 56) { // TOK_STRUCT = 56
            let xz_st = parse_struct_def();
            xz_nodes = push(xz_nodes, xz_st);
        } else if (xz_cur_type == 58) { // TOK_ENUM = 58
            let xz_en = parse_enum_def();
            xz_nodes = push(xz_nodes, xz_en);
        } else if (xz_cur_type == 62) { // TOK_IMPORT = 62
            // Supports two syntaxes:
            // 1. import "filename";           -> import all
            // 2. import {a, b} from "file";   -> import selective
            p_advance(); // skip 'import'
            
            let import_names = []; // Empty = import all
            let import_path = "";
            
            if (p_current_type() == 32) { // TOK_LBRACE = 32
                // Selective import: import {name1, name2} from "path";
                p_advance(); // skip '{'
                while (p_current_type() != 33) { // TOK_RBRACE = 33
                    let imp_name = p_current_val();
                    import_names = push(import_names, imp_name);
                    p_expect(10); // TOK_ID
                    if (p_current_type() == 51) { // TOK_COMMA
                        p_advance();
                    }
                }
                p_expect(33); // TOK_RBRACE
                p_expect(63); // TOK_FROM
                import_path = p_current_val();
                p_expect(12); // TOK_STR
            } else {
                // Simple import: import "filename";
                import_path = p_current_val();
                p_expect(12); // TOK_STR = 12
            }
            
            p_expect(50); // TOK_SEMI = 50
            xz_nodes = push(xz_nodes, [120, import_path, import_names]); // AST_IMPORT = 120
        } else {
            // Assume it's a statement (let, etc)
            let xz_stmt = parse_statement();
            xz_nodes = push(xz_nodes, xz_stmt);
        }
        
        // Prevent infinite loop if parser gets stuck
        if (p_pos > len(tokens) + 10) {
            print("Parse Error: Infinite loop detected at pos " + p_pos);
            return xz_nodes;
        }
    }
    
    return xz_nodes;
}

// =================== CODE GENERATOR (LLVM IR) ===================

let cg_output = "";
let cg_temp = 0;
let cg_label = 0;
let cg_vars = [];
let cg_var_names = [];
let cg_global_vars = []; // Track global variable names
let cg_strings = []; // [ [id, content], ... ]
let cg_str_id_counter = 0;
let cg_loop_cond_label = ""; // For continue
let cg_loop_end_label = "";  // For break
let cg_structs = []; // Track struct definitions [[name, fields], ...]
let cg_enums = [];   // Track enum definitions [[name, variants], ...]
let cg_sinst_return = ""; // Workaround for struct instantiation return value
let cg_last_expr = ""; // Store last expression result for AST_RETURN workaround

fn cg_find_field_index(ffi_fname: string) {
    let ffi_si = 0;
    while (ffi_si < len(cg_structs)) {
        let ffi_struct_def = cg_structs[ffi_si];
        let ffi_fields = ffi_struct_def[1];
        let ffi_fi = 0;
        while (ffi_fi < len(ffi_fields)) {
            let ffi_field_entry = ffi_fields[ffi_fi];
            let ffi_fn = ffi_field_entry[0];
            if (ffi_fn == ffi_fname) {
                return ffi_fi;
            }
            ffi_fi = ffi_fi + 1;
        }
        ffi_si = ffi_si + 1;
    }
    return 0;
}

fn cg_is_global(name: string) {
    let i = 0;
    while (i < len(cg_global_vars)) {
        if (cg_global_vars[i] == name) { return true; }
        i = i + 1;
    }
    return false;
}

fn cg_emit(s: string) {
    cg_output = cg_output + "  " + s + "\n";
}

fn cg_emit_raw(s: string) {
    cg_output = cg_output + s + "\n";
}

fn cg_next_temp() {
    let temp_result = "%t" + cg_temp;
    cg_temp = cg_temp + 1;
    return temp_result;
}

fn cg_next_label() {
    let label_result = "L" + cg_label;
    cg_label = cg_label + 1;
    return label_result;
}

fn cg_find_var(name: string) {
    // Search backwards to support variable shadowing
    // (find most recently declared variable with this name)
    let i = len(cg_var_names) - 1;
    while (i >= 0) {
        if (cg_var_names[i] == name) {
            return cg_vars[i];
        }
        i = i - 1;
    }
    return null;
}

fn cg_add_var(name: string, ptr: string) {
    cg_var_names = push(cg_var_names, name);
    cg_vars = push(cg_vars, ptr);
}

fn cg_get_str_const(content: string) {
    // Check if exists
    let i = 0;
    while (i < len(cg_strings)) {
        let cached_entry = cg_strings[i];
        let cached_content = cached_entry[1];
        if (cached_content == content) {
            let cached_id = cached_entry[0];
            return "@.str." + cached_id;
        }
        i = i + 1;
    }
    // Add new
    let new_id = cg_str_id_counter;
    cg_str_id_counter = cg_str_id_counter + 1;
    let new_entry = [new_id, content];
    cg_strings = push(cg_strings, new_entry);
    return "@.str." + new_id;
}

fn cg_gen_expr(cge_input: any) {
    let node_type = cge_input[0];
    // DEBUG
    
    // Number literal - Tagged Integer format (n*2+1)
    // In Stage 0, parseInt returns raw value, so we tag it.
    // In Stage 1, parseInt returns already-tagged value, so we use it as-is.
    if (node_type == AST_NUM) {
        let n = cge_input[1];  // Could be raw or tagged depending on stage
        if (IS_STAGE1 == 1) {
            // n is already tagged from parseInt
            return "" + n;
        } else {
            // n is raw, need to tag it
            return "" + ((n * 2) + 1);
        }
    }
    
    // String Literal
    if (node_type == 30) { // AST_STR
        let str_val = cge_input[1];
        let str_ptr = cg_get_str_const(str_val);
        let t1 = cg_next_temp();
        let str_len = len(str_val);
        let array_len = str_len + 1;
        let cast = "getelementptr inbounds ([" + array_len + " x i8], [" + array_len + " x i8]* " + str_ptr + ", i64 0, i64 0)";
        // Fix: Call argon_str_new to create a valid Object from the raw C-string
        cg_emit(t1 + " = call i64 @argon_str_new(i8* " + cast + ")");
        return t1;
    }
    

    
    // Variable
    if (node_type == AST_VAR) {
        let var_name = cge_input[1];
        
        if (cg_is_global(var_name)) {
             let var_temp = cg_next_temp();
             cg_emit(var_temp + " = load i64, i64* @" + var_name);
             return var_temp;
        }
        
        let var_ptr = cg_find_var(var_name);
        if (var_ptr != null) {
            let var_temp2 = cg_next_temp();
            cg_emit(var_temp2 + " = load i64, i64* " + var_ptr);
            return var_temp2;
        }
        return "0";
    }
    
    // NOT operator: !expr
    // In tagged format: true = 3, false = 1
    // NOT flips: 3 -> 1, 1 -> 3
    if (node_type == 71) { // AST_NOT = 71
        let not_input = cge_input[1];
        let not_val = cg_gen_expr(not_input);
        let not_res = cg_next_temp();
        // XOR with 2 flips the second bit: 1 (01) -> 3 (11), 3 (11) -> 1 (01)
        cg_emit(not_res + " = xor i64 " + not_val + ", 2");
        return not_res;
    }
    
    // Binary operation
    if (node_type == AST_BINOP) {
        let binop_op = cge_input[1];
        let binop_left = cge_input[2];
        let binop_right = cge_input[3];
        
        let binop_l = cg_gen_expr(binop_left);
        let binop_r = cg_gen_expr(binop_right);
        let binop_res = cg_next_temp();
        
        // OPTIMIZATION: Fast Path for Integers
        // Operations: +, -, <, >, ==
        let can_opt = false;
        if (binop_op == "+") { can_opt = true; }
        else if (binop_op == "-") { can_opt = true; }
        else if (binop_op == "<") { can_opt = true; }
        else if (binop_op == ">") { can_opt = true; }
        else if (binop_op == "==") { can_opt = true; }
        
        if (can_opt) {
             let label_fast = cg_next_label();
             let label_slow = cg_next_label();
             let label_done = cg_next_label();
             
             // Check if both are integers: (left & right & 1) == 1
             let binop_t1 = cg_next_temp();
             let binop_t2 = cg_next_temp();
             let binop_t3 = cg_next_temp();
             cg_emit(binop_t1 + " = and i64 " + binop_l + ", " + binop_r);
             cg_emit(binop_t2 + " = and i64 " + binop_t1 + ", 1");
             
             if (OPT_UNSAFE == 1) {
                 cg_emit("br label %" + label_fast);
             } else {
                 cg_emit(binop_t3 + " = icmp eq i64 " + binop_t2 + ", 1");
                 let binop_t3_ex = cg_next_temp();
                 cg_emit(binop_t3_ex + " = call i1 @llvm.expect.i1(i1 " + binop_t3 + ", i1 1)");
                 cg_emit("br i1 " + binop_t3_ex + ", label %" + label_fast + ", label %" + label_slow);
             }
             
             // --- FAST PATH (Native Instructions) ---
             cg_emit_raw("\n" + label_fast + ":");
             let res_fast = cg_next_temp();
             
             if (binop_op == "+") {
                 // (2n+1) + (2m+1) - 1 = 2(n+m) + 1
                 let t_add = cg_next_temp();
                 cg_emit(t_add + " = add i64 " + binop_l + ", " + binop_r);
                 cg_emit(res_fast + " = sub i64 " + t_add + ", 1");
             }
             else if (binop_op == "-") {
                 // (2n+1) - (2m+1) + 1 = 2(n-m) + 1
                 let t_sub = cg_next_temp();
                 cg_emit(t_sub + " = sub i64 " + binop_l + ", " + binop_r);
                 cg_emit(res_fast + " = add i64 " + t_sub + ", 1");
             }
             else if (binop_op == "==") {
                  let t_cmp = cg_next_temp();
                  cg_emit(t_cmp + " = icmp eq i64 " + binop_l + ", " + binop_r);
                  cg_emit(res_fast + " = select i1 " + t_cmp + ", i64 3, i64 1");
             }
             else if (binop_op == "<") {
                  let t_cmp = cg_next_temp();
                  cg_emit(t_cmp + " = icmp slt i64 " + binop_l + ", " + binop_r);
                  cg_emit(res_fast + " = select i1 " + t_cmp + ", i64 3, i64 1");
             }
             else if (binop_op == ">") {
                  let t_cmp = cg_next_temp();
                  cg_emit(t_cmp + " = icmp sgt i64 " + binop_l + ", " + binop_r);
                  cg_emit(res_fast + " = select i1 " + t_cmp + ", i64 3, i64 1");
             }
             cg_emit("br label %" + label_done);
             
             // --- SLOW PATH (Function Call) ---
             cg_emit_raw("\n" + label_slow + ":");
             let target = "";
             if (binop_op == "+") { target = "argon_add"; }
             else if (binop_op == "-") { target = "argon_sub"; }
             else if (binop_op == "<") { target = "argon_lt"; }
             else if (binop_op == ">") { target = "argon_gt"; }
             else if (binop_op == "==") { target = "argon_eq"; }
             
             let res_slow = cg_next_temp();
             cg_emit(res_slow + " = call i64 @" + target + "(i64 " + binop_l + ", i64 " + binop_r + ")");
             cg_emit("br label %" + label_done);
             
             // --- MERGE ---
             cg_emit_raw("\n" + label_done + ":");
             let final_res = cg_next_temp();
             cg_emit(final_res + " = phi i64 [ " + res_fast + ", %" + label_fast + " ], [ " + res_slow + ", %" + label_slow + " ]");
             return final_res;
        }

        let target = "";
        if (binop_op == "*") { target = "argon_mul"; }
        else if (binop_op == "/") { target = "argon_div"; }
        
        if (target != "") {
             cg_emit(binop_res + " = call i64 @" + target + "(i64 " + binop_l + ", i64 " + binop_r + ")");
             return binop_res;
        }
        
        if (binop_op == "!=") {
             let eq_res = cg_next_temp();
             cg_emit(eq_res + " = call i64 @argon_eq(i64 " + binop_l + ", i64 " + binop_r + ")");
             cg_emit(binop_res + " = xor i64 " + eq_res + ", 2");
             return binop_res;
        }
        
        if (binop_op == "<=") {
             let lt_res = cg_next_temp();
             let eq_res = cg_next_temp();
             cg_emit(lt_res + " = call i64 @argon_lt(i64 " + binop_l + ", i64 " + binop_r + ")");
             cg_emit(eq_res + " = call i64 @argon_eq(i64 " + binop_l + ", i64 " + binop_r + ")");
             cg_emit(binop_res + " = or i64 " + lt_res + ", " + eq_res);
             return binop_res;
        }
        
        if (binop_op == ">=") {
             let gt_res = cg_next_temp();
             let eq_res = cg_next_temp();
             cg_emit(gt_res + " = call i64 @argon_gt(i64 " + binop_l + ", i64 " + binop_r + ")");
             cg_emit(eq_res + " = call i64 @argon_eq(i64 " + binop_l + ", i64 " + binop_r + ")");
             cg_emit(binop_res + " = or i64 " + gt_res + ", " + eq_res);
             return binop_res;
        }
        
        return "0";
    }
    
    // Function call
    if (node_type == AST_CALL) {
        let call_name = cge_input[1];
        let call_args = cge_input[2];
        let call_res = cg_next_temp();
        
        // Map intrinsics (Restored for compat)
        let call_target = call_name;
        if (call_name == "len") { call_target = "argon_len"; }
        else if (call_name == "push") { call_target = "argon_push"; }
        // CamelCase (Legacy/JS)
        else if (call_name == "charCodeAt") { call_target = "argon_char_code_at"; }
        else if (call_name == "parseInt") { call_target = "argon_parse_int"; }
        else if (call_name == "readFile") { call_target = "argon_read_file"; }
        else if (call_name == "system") { call_target = "argon_system"; }
        else if (call_name == "exit") { call_target = "argon_exit"; }
        else if (call_name == "getEnv") { call_target = "argon_get_env"; }
        else if (call_name == "input") { call_target = "argon_stdin_read"; }
        else if (call_name == "writeFile") { call_target = "argon_write_file"; }
        else if (call_name == "fileExists") { call_target = "argon_file_exists"; }
        else if (call_name == "getArgs") { call_target = "argon_get_args"; }
        // snake_case (Consistent)
        else if (call_name == "char_code_at") { call_target = "argon_char_code_at"; }
        else if (call_name == "parse_int") { call_target = "argon_parse_int"; }
        else if (call_name == "read_file") { call_target = "argon_read_file"; }
        else if (call_name == "write_file") { call_target = "argon_write_file"; }
        else if (call_name == "file_exists") { call_target = "argon_file_exists"; }
        else if (call_name == "get_args") { call_target = "argon_get_args"; }
        else if (call_name == "char_from_code") { call_target = "argon_char_from_code"; }
        else if (call_name == "exit") { call_target = "argon_exit"; }
        else if (call_name == "get_env") { call_target = "argon_get_env"; }
        
        // Check if call_name is an Enum Variant Constructor
        // We iterate all collected enums to find matching variant
        // Since we don't have scope (Enum::Variant), variant names must be unique or we check all.
        let enum_cons_variant_idx = 0 - 1;
        let enum_cons_has_data = 0;
        
        let eci = 0;
        while (eci < len(cg_enums)) {
             let ec_def = cg_enums[eci];
             let ec_variants = ec_def[1];
             let evi = 0;
             while (evi < len(ec_variants)) {
                 let ev_def = ec_variants[evi]; // [name, has_data]
                 if (ev_def[0] == call_name) {
                     enum_cons_variant_idx = evi;
                     enum_cons_has_data = ev_def[1];
                     // Found match
                     evi = len(ec_variants);
                     eci = len(cg_enums);
                 } else {
                     evi = evi + 1;
                 }
             }
             if (eci < len(cg_enums)) { eci = eci + 1; } // Check continue condition
        }
        
        // If it IS an enum constructor
        if (enum_cons_variant_idx != (0 - 1)) {
             // Create Array [discriminator, data...]
             let enum_obj = cg_next_temp();
             cg_emit(enum_obj + " = call i64 @argon_arr_new()");
             
             // Push discriminator
             let disc_tag = (enum_cons_variant_idx * 2) + 1;
             let dumb1 = cg_next_temp();
             cg_emit(dumb1 + " = call i64 @argon_push(i64 " + enum_obj + ", i64 " + disc_tag + ")");
             
             // Push data args
             // Note: Enum variant assumes 0 or 1 args for now based on 'has_data'
             // But user might pass args. Flatten match args?
             // Just push all provided args.
             let ec_arg_i = 0;
             while (ec_arg_i < len(call_args)) {
                 let ec_arg_val = cg_gen_expr(call_args[ec_arg_i]);
                 let dumb2 = cg_next_temp();
                 cg_emit(dumb2 + " = call i64 @argon_push(i64 " + enum_obj + ", i64 " + ec_arg_val + ")");
                 ec_arg_i = ec_arg_i + 1;
             }
             
             return enum_obj;
        }

        let call_arg_str = "";
        let ci = 0;
        while (ci < len(call_args)) {
             if (ci > 0) { call_arg_str = call_arg_str + ", "; }
             let call_arg_val = cg_gen_expr(call_args[ci]);
             call_arg_str = call_arg_str + "i64 " + call_arg_val;
             ci = ci + 1;
        }
        
        cg_emit(call_res + " = call i64 @" + call_target + "(" + call_arg_str + ")");
        return call_res;
    }
    
    // Array literal
    if (node_type == 31) { // AST_ARRAY
        let items = cge_input[1];
        let arr = cg_next_temp();
        cg_emit(arr + " = call i64 @argon_arr_new()");
        
        let i = 0;
        while (i < len(items)) {
            let item = items[i];
            let val = cg_gen_expr(item);
            let dummy = cg_next_temp();
            cg_emit(dummy + " = call i64 @argon_push(i64 " + arr + ", i64 " + val + ")");
            i = i + 1;
        }
        return arr;
    }
    
    // Struct instantiation: create array with field values
    if (node_type == 101) { // AST_STRUCT_INST = 101
        let sinst_field_inits = cge_input[2]; // [[fname, fval], ...]
        
        // Get temp for struct array - save to GLOBAL before any recursive calls
        // This works around potential return value corruption in Stage 1
        let sinst_my_arr = cg_next_temp();
        cg_sinst_return = sinst_my_arr; // Save to global immediately
        cg_emit(sinst_my_arr + " = call i64 @argon_arr_new()");
        
        // Collect all field values FIRST (without using local)
        let sinst_vals = [];
        let sinst_i = 0;
        while (sinst_i < len(sinst_field_inits)) {
            let sinst_field = sinst_field_inits[sinst_i];
            let sinst_expr = sinst_field[1];
            let sinst_val = cg_gen_expr(sinst_expr);
            sinst_vals = push(sinst_vals, sinst_val);
            sinst_i = sinst_i + 1;
        }
        
        
        // Now emit push calls using collected values AND global saved temp
        let sinst_j = 0;
        while (sinst_j < len(sinst_vals)) {
            let sinst_v = sinst_vals[sinst_j];
            let sinst_dummy = cg_next_temp();
            cg_emit(sinst_dummy + " = call i64 @argon_push(i64 " + cg_sinst_return + ", i64 " + sinst_v + ")");
            sinst_j = sinst_j + 1;
        }
        
        
        // Return the global saved value, not the local
        let sinst_result = cg_sinst_return;
        return sinst_result;
    }
    
    // Field access: get field by index
    if (node_type == 102) { // AST_FIELD_ACCESS = 102
        let access_base = cge_input[1];
        let access_fname = cge_input[2];
        
        let access_base_val = cg_gen_expr(access_base);
        let access_idx = cg_find_field_index(access_fname);
        
        // For LLVM IR, we need tagged format: idx*2+1
        // access_idx is 0, 1, 2, etc (raw value)
        // Tagged values: 0->1, 1->3, 2->5, etc
        let access_idx_val = "1"; // default for index 0
        if (access_idx == 1) { access_idx_val = "3"; }
        if (access_idx == 2) { access_idx_val = "5"; }
        if (access_idx == 3) { access_idx_val = "7"; }
        if (access_idx == 4) { access_idx_val = "9"; }
        
        
        let access_result = cg_next_temp();
        cg_emit(access_result + " = call i64 @argon_get(i64 " + access_base_val + ", i64 " + access_idx_val + ")");
        return access_result;
    }
    
    // Method call: [103, base_obj, method_name, args]
    // Transform to function call: StructType_method(base_obj, args...)
    if (node_type == 103) { // AST_METHOD_CALL
        let mcall_base = cge_input[1];  // The object (unused directly, it's in args)
        let mcall_method = cge_input[2]; // Method name
        let mcall_args = cge_input[3];   // Args array (first is self)
        
        // For now, we need to figure out the struct type
        // We'll try each struct and see if it has a matching method
        // Generate call to each possible mangled name
        // For simplicity: iterate through structs and try to find method
        
        // Build the mangled function name by trying each struct
        // In practice, we'd need type inference. For now, try all structs.
        let mcall_func_name = "";
        let msi = 0;
        while (msi < len(cg_structs)) {
            let mstruct = cg_structs[msi];
            let msname = mstruct[0];
            // Try this struct's method name
            mcall_func_name = msname + "_" + mcall_method;
            msi = msi + 1;
            // Just use the first one for now - TODO: proper type resolution
            if (msi == 1) {
                // Use first struct that could match
            }
        }
        
        // If no structs found, just use the method name directly
        if (mcall_func_name == "") {
            mcall_func_name = mcall_method;
        }
        
        // Generate argument values
        let mcall_arg_str = "";
        let mai = 0;
        while (mai < len(mcall_args)) {
            if (mai > 0) { mcall_arg_str = mcall_arg_str + ", "; }
            let ma_temp_start = cg_temp;
            cg_gen_expr(mcall_args[mai]);
            let ma_result = "%t" + ma_temp_start;
            mcall_arg_str = mcall_arg_str + "i64 " + ma_result;
            mai = mai + 1;
        }
        
        let mcall_result = cg_next_temp();
        cg_emit(mcall_result + " = call i64 @" + mcall_func_name + "(" + mcall_arg_str + ")");
        return mcall_result;
    }
    
    // Match Expression
    if (node_type == 111) { // AST_MATCH
        let match_target = cge_input[1];
        let match_cases = cge_input[2]; // [[pat, bind, body], ...]
        
        let target_val = cg_gen_expr(match_target);
        let match_end_label = cg_next_label();
        
        // Get discriminator from target_val[0]
        // TODO: Handle simple integer enums if we decide to optimize later.
        // For now, assume enum is always array [disc, data...]
        let disc_val = cg_next_temp();
        cg_emit(disc_val + " = call i64 @argon_get(i64 " + target_val + ", i64 1)"); // Index 0 (tagged 1)
        
        // Loop through cases and generate checks
        let mi = 0;
        while (mi < len(match_cases)) {
            let mcase = match_cases[mi];
            let pat_name = mcase[0]; // Variant Name
            let pat_bind = mcase[1]; // Binding Var Name
            let case_body = mcase[2];
            
            let next_case_label = cg_next_label();
            let case_body_label = cg_next_label();
            
            // Check discriminator
            // We need to resolve pat_name (Variant) to its index
            let variant_idx = 0 - 1;
            
            // Search all enums for this variant
            let found_enum = 0;
            let ei = 0;
            while (ei < len(cg_enums)) {
                let edef = cg_enums[ei];
                let evariants = edef[1];
                let vi = 0;
                while (vi < len(evariants)) {
                    let vdef = evariants[vi];
                    if (vdef[0] == pat_name) {
                        variant_idx = vi;
                        found_enum = 1;
                        // Break out of inner loop
                        vi = len(evariants); 
                    } else {
                        vi = vi + 1;
                    }
                }
                if (found_enum == 1) {
                    ei = len(cg_enums);
                } else {
                    ei = ei + 1;
                }
            }
            
            if (variant_idx != (0 - 1)) {
                let vidx_tagged = (variant_idx * 2) + 1;
                if (IS_STAGE1 == 1) { vidx_tagged = variant_idx; } // Wait, constant folding vs runtime
                // variant_idx is constant int.
                let cmp_res = cg_next_temp();
                
                // If STAGE1, numbers are already tagged in the compiler's memory? 
                // No, 'variant_idx' is a pure int here.
                // But the runtime 'disc_val' is a tagged int.
                // So we should compare against tagged variant_idx.
                // Tag it here:
                vidx_tagged = (variant_idx * 2) + 1;
                
                cg_emit(cmp_res + " = icmp eq i64 " + disc_val + ", " + vidx_tagged);
                cg_emit("br i1 " + cmp_res + ", label %" + case_body_label + ", label %" + next_case_label);
                
                cg_emit_raw("\n" + case_body_label + ":");
                
                // Binding: if pat_bind is set, extract data
                if (pat_bind != "") {
                    // Extract payload: target_val[1]
                    let bind_val = cg_next_temp();
                    cg_emit(bind_val + " = call i64 @argon_get(i64 " + target_val + ", i64 3)"); // Index 1 (tagged 3)
                    
                    // Alloc stack for binding
                    let bind_ptr = "%" + pat_bind + ".ptr." + cg_temp;
                    cg_temp = cg_temp + 1;
                    cg_emit(bind_ptr + " = alloca i64");
                    cg_emit("store i64 " + bind_val + ", i64* " + bind_ptr);
                    cg_add_var(pat_bind, bind_ptr); // Scoping? 
                    // Note: cg_add_var pushes to global list, usually cleaned up by function reset?
                    // Actually 'cg_vars' is reset per function.
                    // But inside a block, we might shadow?
                    // For now, assume unique names or shadowing works by list order (last added found first).
                    // Yes, cg_find_var searches backwards? 
                    // Let's check cg_find_var implementation.
                    // It searches forward 0..len. `push` adds to end.
                    // We need find to search from end to support shadowing properly.
                    // Current cg_find_var searches 0 to len. So it finds FIRST (oldest).
                    // Shadowing requires finding LAST (newest).
                    // TODO: Fix shadowing in cg_find_var if needed.
                    // For now, it works if variable names are unique.
                }
                
                // Generate Body
                // Match returns a value? 
                // We need to support 'expr' behavior (phi node?).
                // AST_MATCH is currently expected to return value?
                // For simplicity, let's assume it returns 0 for now or handled via side-effects (print).
                // Or implementing PHI is hard here without knowing type/result of block.
                // Let's make it an expression that evaluates the block.
                // Block usually returns result of last stmt? 
                // AST_BLOCK handling? `cg_gen_stmt` handles block, but doesn't return value.
                // If body is a block, we iterate stmts.
                // If body is expression?
                
                // Assuming stmt context for now.
                // If we need expression result, we need 'cg_last_expr_val' or similar.
                
                let bstmts = case_body[1];
                let bi = 0;
                while (bi < len(bstmts)) {
                    cg_gen_stmt(bstmts[bi]);
                    bi = bi + 1;
                }
                
                cg_emit("br label %" + match_end_label);
                
                cg_emit_raw("\n" + next_case_label + ":");
                
            } else {
                // Unknown variant or default?
                // Just emit branch to next
                cg_emit("br label %" + next_case_label);
                cg_emit_raw("\n" + next_case_label + ":");
            }
            
            mi = mi + 1;
        }
        
        cg_emit("br label %" + match_end_label);
        cg_emit_raw("\n" + match_end_label + ":");
        return "0"; // Result of match expression (void/0 for now)
    }

    return "0";
}

fn cg_gen_stmt(stmt: any) {
    let node_type = stmt[0];
    
    // Let statement
    if (node_type == AST_LET) {
        let let_name = stmt[1];
        let let_init = stmt[2];
        let let_val = cg_gen_expr(let_init);
        
        // This is local let, alloc stack
        let let_ptr = "%" + let_name + ".ptr." + cg_temp;
        cg_temp = cg_temp + 1;
        
        cg_emit(let_ptr + " = alloca i64");
        cg_emit("store i64 " + let_val + ", i64* " + let_ptr);
        
        cg_add_var(let_name, let_ptr);
        return;
    }
    
    // Assignment
    if (node_type == AST_ASSIGN) {
        let assign_name = stmt[1];
        let assign_expr = stmt[2];
        let assign_val = cg_gen_expr(assign_expr);
        
        if (cg_is_global(assign_name)) {
            cg_emit("store i64 " + assign_val + ", i64* @" + assign_name);
        } else {
            let assign_ptr = cg_find_var(assign_name);
            if (assign_ptr != null) {
                cg_emit("store i64 " + assign_val + ", i64* " + assign_ptr);
            }
        }
        return;
    }
    
    // Print statement
    if (node_type == AST_PRINT) {
        let print_expr = stmt[1];
        let print_val = cg_gen_expr(print_expr);
        
        // Use argon_print which handles all Argon value types
        cg_emit("call void @argon_print(i64 " + print_val + ")");
        return;
    }
    
    // Return statement
    if (node_type == AST_RETURN) {
        let expr = stmt[1];
        
        // TAIL CALL OPTIMIZATION - still use direct approach for simple calls
        if (expr[0] == AST_CALL) {
             let name = expr[1];
             let args = expr[2];
             
             // Map intrinsics (same as in cg_gen_expr)
             let call_target = name;
             if (name == "len") { call_target = "argon_len"; }
             else if (name == "push") { call_target = "argon_push"; }
             else if (name == "charCodeAt") { call_target = "argon_char_code_at"; }
             else if (name == "parseInt") { call_target = "argon_parse_int"; }
             else if (name == "readFile") { call_target = "argon_read_file"; }
             else if (name == "writeFile") { call_target = "argon_write_file"; }
             else if (name == "fileExists") { call_target = "argon_file_exists"; }
             else if (name == "getArgs") { call_target = "argon_get_args"; }
             else if (name == "char_code_at") { call_target = "argon_char_code_at"; }
             else if (name == "parse_int") { call_target = "argon_parse_int"; }
             else if (name == "read_file") { call_target = "argon_read_file"; }
             else if (name == "write_file") { call_target = "argon_write_file"; }
             else if (name == "file_exists") { call_target = "argon_file_exists"; }
             else if (name == "get_args") { call_target = "argon_get_args"; }
             else if (name == "char_from_code") { call_target = "argon_char_from_code"; }
             else if (name == "exit") { call_target = "argon_exit"; }
             else if (name == "get_env") { call_target = "argon_get_env"; }
             
             let arg_str = "";
             let i = 0;
             while (i < len(args)) {
                  if (i > 0) { arg_str = arg_str + ", "; }
                  // Get actual result from cg_gen_expr (could be temp or literal)
                  let arg_result = cg_gen_expr(args[i]);
                  arg_str = arg_str + "i64 " + arg_result;
                  i = i + 1;
             }
             
             let res = cg_next_temp();
             cg_emit(res + " = tail call i64 @" + call_target + "(" + arg_str + ")");
             cg_emit("ret i64 " + res);
             return;
        }
        
        // For all other expressions: use the actual result from cg_gen_expr
        // CRITICAL FIX: Don't assume last temp is the result - use the actual return value
        let ret_result = cg_gen_expr(expr);
        cg_emit("ret i64 " + ret_result);
        return;
    }
    
    // While statement
    if (node_type == AST_WHILE) {
        let cond = stmt[1];
        let body = stmt[2];
        
        let cond_label = cg_next_label();
        let body_label = cg_next_label();
        let end_label = cg_next_label();
        
        // Save current loop labels for nested loops
        let saved_cond = cg_loop_cond_label;
        let saved_end = cg_loop_end_label;
        cg_loop_cond_label = cond_label;
        cg_loop_end_label = end_label;
        
        cg_emit("br label %" + cond_label);
        cg_emit_raw("\n" + cond_label + ":");
        
        // OPTIMIZATION: Condition Flow for specific comparisons
        let opt_while = false;
        if (cond[0] == 3) { // AST_BINOP
            let op = cond[1];
            if (op == "<") { opt_while = true; }
            else if (op == ">") { opt_while = true; }
            else if (op == "==") { opt_while = true; }
        }
        
        if (opt_while) {
            let op = cond[1];
            let left = cond[2];
            let right = cond[3];
            let l = cg_gen_expr(left);
            let r = cg_gen_expr(right);
            
            let label_fast = cg_next_label();
            let label_slow = cg_next_label();
            
            // Check types (both int?)
            let t1 = cg_next_temp();
            let t2 = cg_next_temp();
            let t3 = cg_next_temp();
            cg_emit(t1 + " = and i64 " + l + ", " + r);
            cg_emit(t2 + " = and i64 " + t1 + ", 1");
            
            if (OPT_UNSAFE == 1) {
                cg_emit("br label %" + label_fast);
            } else {
                cg_emit(t3 + " = icmp eq i64 " + t2 + ", 1");
                let t3_ex = cg_next_temp();
                cg_emit(t3_ex + " = call i1 @llvm.expect.i1(i1 " + t3 + ", i1 1)");
                cg_emit("br i1 " + t3_ex + ", label %" + label_fast + ", label %" + label_slow);
            }
            
            // FAST PATH: Direct Branching
            cg_emit_raw("\n" + label_fast + ":");
            let t_cmp = cg_next_temp();
            let cmp_instr = "icmp eq";
            if (op == "<") { cmp_instr = "icmp slt"; }
            if (op == ">") { cmp_instr = "icmp sgt"; }
            
            cg_emit(t_cmp + " = " + cmp_instr + " i64 " + l + ", " + r);
            cg_emit("br i1 " + t_cmp + ", label %" + body_label + ", label %" + end_label);
            
            // SLOW PATH: Fallback to runtime
            cg_emit_raw("\n" + label_slow + ":");
            let target = "argon_eq";
            if (op == "<") { target = "argon_lt"; }
            if (op == ">") { target = "argon_gt"; }
            
            let res_slow = cg_next_temp();
            cg_emit(res_slow + " = call i64 @" + target + "(i64 " + l + ", i64 " + r + ")");
            let slow_bool = cg_next_temp();
            cg_emit(slow_bool + " = icmp ne i64 " + res_slow + ", 1");
            cg_emit("br i1 " + slow_bool + ", label %" + body_label + ", label %" + end_label);
        
        } else {
            // Normal unoptimized condition
            let cond_val = cg_gen_expr(cond);
            let cond_bool = cg_next_temp();
            cg_emit(cond_bool + " = icmp ne i64 " + cond_val + ", 1");
            cg_emit("br i1 " + cond_bool + ", label %" + body_label + ", label %" + end_label);
        }
        
        cg_emit_raw("\n" + body_label + ":");
        let body_stmts = body[1];
        let i = 0;
        while (i < len(body_stmts)) {
            cg_gen_stmt(body_stmts[i]);
            i = i + 1;
        }
        cg_emit("br label %" + cond_label);
        
        cg_emit_raw("\n" + end_label + ":");
        
        // Restore saved loop labels
        cg_loop_cond_label = saved_cond;
        cg_loop_end_label = saved_end;
        return;
    }
    
    // Break statement
    if (node_type == AST_BREAK) {
        cg_emit("br label %" + cg_loop_end_label);
        // Need a new label for any code after break (unreachable)
        let after_break = cg_next_label();
        cg_emit_raw("\n" + after_break + ":");
        return;
    }
    
    // Continue statement
    if (node_type == AST_CONTINUE) {
        cg_emit("br label %" + cg_loop_cond_label);
        // Need a new label for any code after continue (unreachable)
        let after_continue = cg_next_label();
        cg_emit_raw("\n" + after_continue + ":");
        return;
    }
    
    // Expression statement (function call as statement)
    if (node_type == AST_CALL) {
        // Just evaluate the expression for its side effects
        cg_gen_expr(stmt);
        return;
    }
    
    // Match statement (delegate to cg_gen_expr which handles AST_MATCH)
    if (node_type == 111) { // AST_MATCH
        cg_gen_expr(stmt);
        return;
    }
    
    // If statement
    if (node_type == AST_IF) {
        let cond = stmt[1];
        let then_block = stmt[2];
        let else_block = stmt[3];
        
        let then_label = cg_next_label();
        let else_label = cg_next_label();
        let end_label = cg_next_label();
        
        let cond_val = cg_gen_expr(cond);
        let cond_bool = cg_next_temp();
        cg_emit(cond_bool + " = icmp ne i64 " + cond_val + ", 1");
        cg_emit("br i1 " + cond_bool + ", label %" + then_label + ", label %" + else_label);
        
        cg_emit_raw("\n" + then_label + ":");
        let then_stmts = then_block[1];
        let ti = 0;
        while (ti < len(then_stmts)) {
            cg_gen_stmt(then_stmts[ti]);
            ti = ti + 1;
        }
        cg_emit("br label %" + end_label);
        
        cg_emit_raw("\n" + else_label + ":");
        let else_stmts = else_block[1];
        let ei = 0;
        while (ei < len(else_stmts)) {
            cg_gen_stmt(else_stmts[ei]);
            ei = ei + 1;
        }
        cg_emit("br label %" + end_label);
        
        cg_emit_raw("\n" + end_label + ":");
        return;
    }
}

fn cg_gen_param_str(params: any) {
    let res = "";
    let i = 0;
    while (i < len(params)) {
        if (i > 0) { res = res + ", "; }
        res = res + "i64 %arg" + i;
        i = i + 1;
    }
    return res;
}

fn escape_llvm(s: string) {
    let res = "";
    let i = 0;
    while (i < len(s)) {
        let c = s[i];
        if (c == "\n") { res = res + "\\0A"; }
        else if (c == "\t") { res = res + "\\09"; }
        else if (c == "\r") { res = res + "\\0D"; }
        else if (is_quote(c)) { res = res + "\\22"; }
        else if (is_backslash(c)) { res = res + "\\5C"; }
        else { 
            res = res + c;
        }
        i = i + 1;
    }
    return res;
}

// =================== MONOMORPHIZATION ===================
// Generate specialized versions of generic functions
// For each instantiation request (e.g., identity<int>),
// find the generic template and create a concrete version
// with mangled name (e.g., identity_int)

fn generate_specialized_funcs() {
    let result = [];
    
    // Iterate through all instantiation requests
    let i = 0;
    while (i < len(instantiations)) {
        let inst = instantiations[i];
        let generic_name = inst[0];    // e.g., "identity"
        let type_args = inst[1];        // e.g., ["int"]
        let mangled_name = inst[2];     // e.g., "identity_int"
        
        // Check if already generated
        let already_done = false;
        let j = 0;
        while (j < len(generated_specs)) {
            if (generated_specs[j] == mangled_name) {
                already_done = true;
                j = len(generated_specs); // break
            }
            j = j + 1;
        }
        
        if (already_done == false) {
            // Find the generic function template
            let k = 0;
            while (k < len(generic_funcs)) {
                let gen_func = generic_funcs[k];
                let gen_name = gen_func[0];
                
                if (gen_name == generic_name) {
                    // Found the template!
                    // gen_func = [name, type_params, params, body]
                    let gen_type_params = gen_func[1]; // ["T"]
                    let gen_params = gen_func[2];      // ["x"]
                    let gen_body = gen_func[3];        // AST_BLOCK
                    
                    // Create specialized function with mangled name
                    // AST_FUNC = [20, name, params, body]
                    let spec_func = [];
                    spec_func = push(spec_func, 20);           // AST_FUNC
                    spec_func = push(spec_func, mangled_name); // Mangled name
                    spec_func = push(spec_func, gen_params);   // Same params
                    spec_func = push(spec_func, gen_body);     // Same body
                    
                    result = push(result, spec_func);
                    generated_specs = push(generated_specs, mangled_name);
                    
                    k = len(generic_funcs); // break
                }
                k = k + 1;
            }
        }
        
        i = i + 1;
    }
    
    return result;
}

fn cg_generate(cg_input_nodes: any) {
    // GENERICS: Generate specialized functions
    let spec_funcs = generate_specialized_funcs();
    let si = 0;
    while (si < len(spec_funcs)) {
        cg_input_nodes = push(cg_input_nodes, spec_funcs[si]);
        si = si + 1;
    }

    cg_output = "";
    cg_strings = [];
    cg_str_id_counter = 0;
    
    // 1. Collect Globals, Structs, Enums and Generate Declarations
    cg_global_vars = [];
    cg_structs = [];
    cg_enums = [];
    let globals_decl = "";
    
    let i = 0;
    while (i < len(cg_input_nodes)) {
        let glob_node = cg_input_nodes[i];
        
        // Skip Generic Templates
        if (glob_node[0] == 130) { // AST_GENERIC_FUNC
            i = i + 1;
            continue;
        }
        
        if (glob_node[0] == 10) { // AST_LET
            let glob_name = glob_node[1];
            cg_global_vars = push(cg_global_vars, glob_name);
            globals_decl = globals_decl + "@" + glob_name + " = global i64 0\n";
        }
        if (glob_node[0] == 100) { // AST_STRUCT_DEF = 100
            let glob_sname = glob_node[1];
            let glob_sfields = glob_node[2];
            let glob_sdef = [];
            glob_sdef = push(glob_sdef, glob_sname);
            glob_sdef = push(glob_sdef, glob_sfields);
            cg_structs = push(cg_structs, glob_sdef);
        }
        if (glob_node[0] == 110) { // AST_ENUM_DEF = 110
            let glob_ename = glob_node[1];
            let glob_evariants = glob_node[2]; // [[name, has_data], ...]
            let glob_edef = [];
            glob_edef = push(glob_edef, glob_ename);
            glob_edef = push(glob_edef, glob_evariants);
            cg_enums = push(cg_enums, glob_edef);
        }
        i = i + 1;
    }
    
    // DEBUG
    
    // 2. Generate __init_globals
    // Reset temp counters
    cg_temp = 0;
    cg_label = 0;
    cg_vars = [];
    cg_var_names = [];
    
    if (len(cg_global_vars) > 0) {
        cg_emit_raw("define void @__init_globals() {");
        cg_emit_raw("entry:");
        
        i = 0;
        while (i < len(cg_input_nodes)) {
            let init_node = cg_input_nodes[i];
            if (init_node[0] == 10) { // AST_LET
                 let init_name = init_node[1];
                 let init_expr = init_node[2];
                 // Generate init value
                 let init_val = cg_gen_expr(init_expr);
                 cg_emit("store i64 " + init_val + ", i64* @" + init_name);
            }
            i = i + 1;
        }
        
        cg_emit("ret void");
        cg_emit_raw("}");
        cg_emit_raw("");
    }
    
    // 3. Generate Functions
    // DEBUG
    
    let fn_i = 0;
    while (fn_i < len(cg_input_nodes)) {
        let fn_node = cg_input_nodes[fn_i];
        // DEBUG
        let fn_elem1 = fn_node[1];
        
        if (fn_node[0] == 20) { // AST_FUNC
            // DEBUG
            
            let fn_name = fn_node[1];
            // DEBUG
            
            let fn_params = fn_node[2];
            let fn_body = fn_node[3];
            
            // DEBUG
            
            // Inline function generation logic to access params correctly
            // Reset local state for function
            cg_temp = 0;
            cg_label = 0;
            cg_vars = [];
            cg_var_names = [];
            
            // DEBUG
            
            if (fn_name == "main") {
                cg_emit_raw("define i64 @main(i32 %argc, i8** %argv) {");
                cg_emit_raw("entry:");
                
                // Call globals init
                if (len(cg_global_vars) > 0) {
                    cg_emit("call void @__init_globals()");
                }
                
                let main_stmts = fn_body[1];
                let mj = 0;
                while (mj < len(main_stmts)) {
                    cg_gen_stmt(main_stmts[mj]);
                    mj = mj + 1;
                }
                cg_emit("ret i64 0");
                cg_emit_raw("}");
            } else {
                let fn_param_str = cg_gen_param_str(fn_params);
                cg_emit_raw("define i64 @" + fn_name + "(" + fn_param_str + ") {");
                cg_emit_raw("entry:");
                
                // Allow stack allocation for params
                let pk = 0;
                while (pk < len(fn_params)) {
                    let fn_pname = fn_params[pk];
                    let fn_ptr = "%" + fn_pname + ".ptr";
                    cg_emit(fn_ptr + " = alloca i64");
                    cg_emit("store i64 %arg" + pk + ", i64* " + fn_ptr);
                    cg_add_var(fn_pname, fn_ptr);
                    pk = pk + 1;
                }
                
                let other_stmts = fn_body[1];
                let oj = 0;
                while (oj < len(other_stmts)) {
                    cg_gen_stmt(other_stmts[oj]);
                    oj = oj + 1;
                }
                // Implicit return 0
                cg_emit("ret i64 0");
                cg_emit_raw("}");
            }
            cg_emit_raw("");
        }
        fn_i = fn_i + 1;
    }
    
    let body_code = cg_output;
    cg_output = ""; // Reset for header
    
    // 4. Generate Header
    cg_emit_raw("; Argon Self-Hosted Compiler Output");
    cg_emit_raw("; Generated by compiler.argon");
    cg_emit_raw("");
    cg_emit_raw("declare i32 @printf(i8*, ...)");
    cg_emit_raw("declare i64 @argon_get(i64, i64)");
    cg_emit_raw("declare i64 @argon_set(i64, i64, i64)");
    cg_emit_raw("declare i64 @argon_arr_new()");
    cg_emit_raw("declare i64 @argon_push(i64, i64)");
    cg_emit_raw("declare i64 @argon_str_new(i8*)");
    cg_emit_raw("declare i64 @argon_add(i64, i64)");
    cg_emit_raw("declare i64 @argon_sub(i64, i64)");
    cg_emit_raw("declare i64 @argon_mul(i64, i64)");
    cg_emit_raw("declare i64 @argon_div(i64, i64)");
    cg_emit_raw("declare i64 @argon_lt(i64, i64)");
    cg_emit_raw("declare i64 @argon_gt(i64, i64)");
    cg_emit_raw("declare i64 @argon_eq(i64, i64)");
    cg_emit_raw("declare i1 @llvm.expect.i1(i1, i1)");
    cg_emit_raw("declare i64 @argon_len(i64)");
    cg_emit_raw("declare void @argon_print(i64)");
    cg_emit_raw("declare i64 @argon_get_args()");
    cg_emit_raw("declare i64 @argon_read_file(i64)");
    cg_emit_raw("declare i64 @argon_write_file(i64, i64)");
    cg_emit_raw("declare i64 @argon_listen(i64)");
    cg_emit_raw("declare i64 @argon_accept(i64)");
    cg_emit_raw("declare i64 @argon_socket_read(i64)");
    cg_emit_raw("declare i64 @argon_socket_write(i64, i64)");
    cg_emit_raw("declare i64 @argon_socket_close(i64)");
    cg_emit_raw("declare i64 @argon_file_exists(i64)");
    cg_emit_raw("declare i64 @argon_char_code_at(i64, i64)");
    cg_emit_raw("declare i64 @argon_parse_int(i64)");
    // Multi-threading (v2.3)
    cg_emit_raw("declare i64 @argon_thread_spawn(i64)");
    cg_emit_raw("declare i64 @argon_thread_join(i64)");
    cg_emit_raw("declare i64 @argon_mutex_new()");
    cg_emit_raw("declare i64 @argon_mutex_lock(i64)");
    cg_emit_raw("declare i64 @argon_mutex_unlock(i64)");
    cg_emit_raw("declare i64 @argon_atomic_new(i64)");
    cg_emit_raw("declare i64 @argon_atomic_load(i64)");
    cg_emit_raw("declare i64 @argon_atomic_store(i64, i64)");
    cg_emit_raw("declare i64 @argon_atomic_add(i64, i64)");
    cg_emit_raw("declare i64 @argon_atomic_cas(i64, i64, i64)");
    cg_emit_raw("declare i64 @argon_sleep(i64)");
    cg_emit_raw("declare i64 @argon_char_from_code(i64)");
    cg_emit_raw("declare i64 @argon_exit(i64)");
    cg_emit_raw("declare i64 @argon_get_env(i64)");
    cg_emit_raw("declare i64 @argon_system(i64)");
    cg_emit_raw("declare i64 @argon_stdin_read()");
    cg_emit_raw("@.str.int = private constant [5 x i8] c\"%ld\\0A\\00\"");
    cg_emit_raw("@.str.str = private constant [4 x i8] c\"%s\\0A\\00\"");
    
    cg_emit_raw(globals_decl);
    

    
    // 5. String Constants
    i = 0;
    while (i < len(cg_strings)) {
        let str_entry = cg_strings[i];
        let str_id = str_entry[0];
        let str_content = str_entry[1];
        let str_esc = escape_llvm(str_content);
        let str_len = len(str_content) + 1;
        cg_emit_raw("@.str." + str_id + " = private constant [" + str_len + " x i8] c\"" + str_esc + "\\00\"");
        i = i + 1;
    }
    
    cg_emit_raw("");
    cg_output = cg_output + body_code;
    return cg_output;
}

// =================== MAIN COMPILER ===================

fn compile_file(filename: string) {
    print("========================================");
    print("  ARGON SELF-HOSTING COMPILER v2.16.0");
    print("  Written 100% in Argon Language");
    print("  With Generics, REPL & Full LSP Support");
    print("========================================");
    print("");
    print("Compiling: " + filename);
    
    if (fileExists(filename) == false) {
        print("Error: File not found");
        return;
    }
    
    let source = readFile(filename);
    print("Source size: " + len(source) + " bytes");
    print("");
    
    // Phase 1: Lexical Analysis
    print("[1/3] Lexical Analysis...");
    let tokens = tokenize(source);
    print("      Generated " + len(tokens) + " tokens");
    
    // Phase 2: Parsing
    print("[2/3] Parsing...");
    let ast = parse_program(tokens);
    print("      Parsed " + len(ast) + " top-level items");
    
    // Phase 2.5: Module Resolution (process imports)
    let imported_files = [];
    let final_ast = [];
    let ast_i = 0;
    while (ast_i < len(ast)) {
        let node = ast[ast_i];
        if (node[0] == 120) { // AST_IMPORT
            let import_path = node[1];
            
            // Check if already imported (avoid circular imports)
            let already_imported = false;
            let imp_j = 0;
            while (imp_j < len(imported_files)) {
                if (imported_files[imp_j] == import_path) {
                    already_imported = true;
                    imp_j = len(imported_files);
                }
                imp_j = imp_j + 1;
            }
            
            if (already_imported == false) {
                imported_files = push(imported_files, import_path);
                
                // Read and parse imported file
                if (fileExists(import_path)) {
                    let import_names = node[2]; // Selective names (empty = all)
                    let selective = len(import_names) > 0;
                    
                    if (selective) {
                        print("      Importing: {" + len(import_names) + " items} from " + import_path);
                    } else {
                        print("      Importing: " + import_path);
                    }
                    
                    let imp_source = readFile(import_path);
                    let imp_tokens = tokenize(imp_source);
                    let imp_ast = parse_program(imp_tokens);
                    
                    // Merge imported AST nodes (excluding imports)
                    let imp_k = 0;
                    while (imp_k < len(imp_ast)) {
                        let imp_node = imp_ast[imp_k];
                        if (imp_node[0] != 120) { // Don't re-add imports
                            let should_include = true;
                            
                            // If selective import, check if this node's name is in the list
                            if (selective) {
                                should_include = false;
                                let node_name = "";
                                
                                // Get node name based on type
                                if (imp_node[0] == 20) { // AST_FUNC
                                    node_name = imp_node[1];
                                } else if (imp_node[0] == 100) { // AST_STRUCT_DEF
                                    node_name = imp_node[1];
                                } else if (imp_node[0] == 110) { // AST_ENUM_DEF
                                    node_name = imp_node[1];
                                } else if (imp_node[0] == 10) { // AST_LET (global)
                                    node_name = imp_node[1];
                                }
                                
                                // Check if in import list
                                let name_i = 0;
                                while (name_i < len(import_names)) {
                                    if (import_names[name_i] == node_name) {
                                        should_include = true;
                                        name_i = len(import_names);
                                    }
                                    name_i = name_i + 1;
                                }
                            }
                            
                            if (should_include) {
                                final_ast = push(final_ast, imp_node);
                            }
                        }
                        imp_k = imp_k + 1;
                    }
                } else {
                    print("      Warning: Import not found: " + import_path);
                }
            }
        } else {
            // Regular node, keep it
            final_ast = push(final_ast, node);
        }
        ast_i = ast_i + 1;
    }
    
    if (len(imported_files) > 0) {
        print("      Imported " + len(imported_files) + " modules");
    }

    // Phase 3: Code Generation
    print("[3/3] Code Generation (LLVM IR)...");
    let llvm_ir = cg_generate(final_ast);
    print("      Generated " + len(llvm_ir) + " bytes of LLVM IR");
    print("");
    
    // Write output
    let output_file = filename + ".ll";
    writeFile(output_file, llvm_ir);
    print("Output written to: " + output_file);
    print("");
    print("========================================");
    print("  COMPILATION COMPLETE!");
    print("========================================");
}

// =================== ENTRY POINT ===================

fn main() {
    detect_stage(); // Detect if running in Stage 0 or Stage 1
    let args = getArgs();
    let num_args = len(args);
    let target_file = "self-host/test_input.argon";
    let i = 1; // skip 0 (program name)
    
    while (i < num_args) {
        let arg = args[i];
        if (arg == "--unsafe-math") {
            OPT_UNSAFE = 1;
        } else {
            target_file = arg;
        }
        i = i + 1;
    }
    
    compile_file(target_file);
}
