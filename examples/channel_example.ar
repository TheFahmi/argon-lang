// ============================================
// Channel Example - Producer/Consumer Pattern
// Demonstrates Argon's channel-based concurrency
// ============================================

import "channel"

fn main() {
    print("=== Argon Channel Example ===\n");
    
    // 1. Basic Channel Usage
    print("1. Basic Channel Communication:");
    let ch = bufferedChannel(5);
    
    // Send some messages
    send(ch, "Hello");
    send(ch, "World");
    send(ch, "from");
    send(ch, "Argon");
    
    print("   Sent 4 messages to channel");
    print("   Pending messages: " + toString(pending(ch)));
    
    // Receive messages
    let result = recv(ch);
    print("   Received: " + result.value);
    
    result = recv(ch);
    print("   Received: " + result.value);
    
    // Drain remaining
    let remaining = drain(ch);
    print("   Drained " + toString(len(remaining)) + " remaining messages");
    
    print("");
    
    // 2. Try Send/Recv (Non-blocking)
    print("2. Non-blocking Operations:");
    let ch2 = bufferedChannel(2);
    
    let sent = trySend(ch2, "Message 1");
    print("   trySend 'Message 1': " + toString(sent));
    
    sent = trySend(ch2, "Message 2");
    print("   trySend 'Message 2': " + toString(sent));
    
    // This should fail - buffer full
    sent = trySend(ch2, "Message 3");
    print("   trySend 'Message 3' (buffer full): " + toString(sent));
    
    // Try receive
    let recvResult = tryRecv(ch2);
    print("   tryRecv: " + recvResult.value + " (ok: " + toString(recvResult.ok) + ")");
    
    print("");
    
    // 3. Channel Close
    print("3. Channel Close:");
    let ch3 = channel();
    
    print("   Channel closed: " + toString(isClosed(ch3)));
    close(ch3);
    print("   After close(): " + toString(isClosed(ch3)));
    
    // Send on closed channel should fail
    let sendResult = send(ch3, "test");
    print("   Send on closed channel: " + toString(sendResult));
    
    print("");
    
    // 4. Fan-out Pattern
    print("4. Fan-out Pattern:");
    let workers = [];
    push(workers, bufferedChannel(3));
    push(workers, bufferedChannel(3));
    push(workers, bufferedChannel(3));
    
    let sentCount = fanOut(workers, "Broadcast message");
    print("   Broadcast to " + toString(sentCount) + " workers");
    
    // Each worker received the message
    let i = 0;
    while (i < len(workers)) {
        let msg = recv(workers[i]);
        print("   Worker " + toString(i) + " received: " + msg.value);
        i = i + 1;
    }
    
    print("");
    
    // 5. Pipeline Pattern
    print("5. Pipeline Pattern:");
    let stage1 = pipelineStage(5);
    let stage2 = pipelineStage(5);
    
    // Send data through pipeline
    send(stage1.input, 10);
    send(stage1.input, 20);
    send(stage1.input, 30);
    
    // Process stage 1 -> stage 2 (double the value)
    while (hasPending(stage1.input)) {
        let data = recv(stage1.input);
        let doubled = data.value * 2;
        send(stage2.input, doubled);
    }
    
    // Read from stage 2
    print("   Pipeline output:");
    while (hasPending(stage2.input)) {
        let out = recv(stage2.input);
        print("     " + toString(out.value));
    }
    
    print("");
    print("=== Channel Example Complete ===");
    
    return 0;
}
