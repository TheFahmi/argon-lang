// Linked List Test for Reference Semantics

struct Node {
    val: int,
    next: Node
}

fn main() {
    print("=== Linked List Test ===");
    
    // Create nodes
    let n1 = Node { val: 1, next: null };
    let n2 = Node { val: 2, next: null };
    let n3 = Node { val: 3, next: null };
    
    // Link them: n1 -> n2 -> n3
    n1.next = n2;
    n2.next = n3;
    
    // Validating structure
    print("Traversing list:");
    print("Node 1: " + n1.val);
    if (n1.next != null) {
        print("Node 2: " + n1.next.val);
        if (n1.next.next != null) {
            print("Node 3: " + n1.next.next.val);
        }
    }
    
    // Modify n3 via n1 traversal (n1.next.next)
    print("Modifying Node 3 via chain (val = 99)...");
    
    // We can't do n1.next.next.val = 99 directly if parser doesn't support chain assignment yet
    // My parser supports FieldAssign(Expr, Field, Val).
    // Expr can be Field(Field(Identifier)).
    // So n1.next.next.val = 99 should work if parser is robust.
    
    n1.next.next.val = 99;
    
    print("Checking original n3 variable:");
    print("n3.val: " + n3.val);
    
    if (n3.val == 99) {
        print("PASS: Linked List works with Reference Semantics!");
    } else {
        print("FAIL: n3 was not modified (Copy Semantics?)");
    }
}
