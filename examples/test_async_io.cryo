// Test Async I/O Library
import "async_io"

fn main() {
    print("========================================");
    print("   CRYO ASYNC I/O LIBRARY TEST");
    print("========================================");
    
    let passed = 0;
    let failed = 0;
    
    // Test 1: Async Result Creation
    print("");
    print("[TEST 1] Async Result States");
    let pending = asyncPending();
    let resolved = asyncResolve("success");
    let rejected = asyncReject("error");
    
    if (asyncIsPending(pending) && asyncIsResolved(resolved) && asyncIsRejected(rejected)) {
        print("  ✓ PASS: Async states work correctly");
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Async states incorrect");
        failed = failed + 1;
    }
    
    // Test 2: Async Task
    print("");
    print("[TEST 2] Async Task Creation");
    let task = asyncTask("myTask");
    
    if (task["id"] > 0 && task["name"] == "myTask" && task["status"] == ASYNC_PENDING) {
        print("  ✓ PASS: Task created with id=" + task["id"]);
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Task creation failed");
        failed = failed + 1;
    }
    
    // Test 3: Task Completion
    print("");
    print("[TEST 3] Task Completion");
    asyncTaskComplete(task, "result_data");
    
    if (task["status"] == ASYNC_RESOLVED && task["result"] == "result_data") {
        print("  ✓ PASS: Task completed successfully");
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Task completion failed");
        failed = failed + 1;
    }
    
    // Test 4: Retry Configuration
    print("");
    print("[TEST 4] Retry Configuration");
    let retryConfig = asyncRetryConfig(5, 500, 2);
    
    if (retryConfig["maxRetries"] == 5 && retryConfig["delayMs"] == 500) {
        print("  ✓ PASS: Retry config created");
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Retry config invalid");
        failed = failed + 1;
    }
    
    // Test 5: Retry Delay Calculation
    print("");
    print("[TEST 5] Retry Backoff");
    let config = asyncDefaultRetry();
    let delay0 = asyncRetryDelay(config);
    asyncNextRetry(config);
    let delay1 = asyncRetryDelay(config);
    asyncNextRetry(config);
    let delay2 = asyncRetryDelay(config);
    
    if (delay0 == 1000 && delay1 == 2000 && delay2 == 4000) {
        print("  ✓ PASS: Exponential backoff works");
        print("  Delays: " + delay0 + " -> " + delay1 + " -> " + delay2);
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Backoff calculation wrong");
        print("  Got: " + delay0 + " -> " + delay1 + " -> " + delay2);
        failed = failed + 1;
    }
    
    // Test 6: Batch Processing
    print("");
    print("[TEST 6] Batch Processing");
    let items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let batches = asyncBatch(items, 3);
    
    if (len(batches) == 4) {
        print("  ✓ PASS: Batched 10 items into 4 batches");
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Expected 4 batches, got " + len(batches));
        failed = failed + 1;
    }
    
    // Test 7: Queue Operations
    print("");
    print("[TEST 7] Queue Operations");
    let queue = asyncQueue();
    asyncEnqueue(queue, "item1");
    asyncEnqueue(queue, "item2");
    asyncEnqueue(queue, "item3");
    
    let size1 = asyncQueueSize(queue);
    let first = asyncDequeue(queue);
    let size2 = asyncQueueSize(queue);
    
    if (size1 == 3 && first == "item1" && size2 == 2) {
        print("  ✓ PASS: Queue FIFO works");
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Queue operations failed");
        failed = failed + 1;
    }
    
    // Test 8: Cancellation Token
    print("");
    print("[TEST 8] Cancellation Token");
    let token = asyncCancellationToken();
    
    if (!asyncIsCancelled(token)) {
        asyncCancel(token, "User requested");
        if (asyncIsCancelled(token) && token["reason"] == "User requested") {
            print("  ✓ PASS: Cancellation works");
            passed = passed + 1;
        } else {
            print("  ✗ FAIL: Cancel didn't work");
            failed = failed + 1;
        }
    } else {
        print("  ✗ FAIL: Token started cancelled");
        failed = failed + 1;
    }
    
    // Test 9: Timeout Context
    print("");
    print("[TEST 9] Timeout Context");
    let timeout = asyncWithTimeout(5000);
    
    if (timeout["timeout"] == 5000 && timeout["startTime"] > 0) {
        print("  ✓ PASS: Timeout context created");
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Timeout context invalid");
        failed = failed + 1;
    }
    
    // Test 10: Debounce
    print("");
    print("[TEST 10] Debounce");
    let call1 = asyncDebounce("test_key", 100);
    let call2 = asyncDebounce("test_key", 100); // Should be skipped (same key, too soon)
    let call3 = asyncDebounce("other_key", 100); // Different key, should pass
    
    if (call1 == true && call3 == true) {
        print("  ✓ PASS: Debounce filtering works");
        passed = passed + 1;
    } else {
        print("  ✗ FAIL: Debounce not working");
        failed = failed + 1;
    }
    
    // Summary
    print("");
    print("========================================");
    print("   TEST SUMMARY");
    print("========================================");
    print("  Passed: " + passed);
    print("  Failed: " + failed);
    print("  Total:  " + (passed + failed));
    print("");
    
    if (failed == 0) {
        print("  ✓ ALL TESTS PASSED!");
    } else {
        print("  ✗ SOME TESTS FAILED");
    }
    
    return 0;
}
